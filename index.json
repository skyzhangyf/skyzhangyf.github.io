[
{
	"uri": "http://skyzhangyf.github.io/",
	"title": "Rainbond文档中心",
	"tags": [],
	"description": "",
	"content": " Rainbond文档中心 Rainbond简介 Rainbond是什么？用在什么场景？\n 安装Rainbond 跟着安装文档部署Rainbond\n 平台使用手册 系统的呈现Rainbond平台的功能使用方式\n 运维手册 运维维护生产环境就绪的Rainbond集群\n 进阶场景 应用架构和开发、管理和运维、交付和传播各方面的进阶使用场景\n 社区 使用过程中遇到了问题？想与大家分享经验？吐槽？我们在此恭候。\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/thirdparty-service/thirdparty-define/",
	"title": "第三方服务定义",
	"tags": [],
	"description": "Rainbond对第三方服务支持说明",
	"content": " 第三方服务定义 运行于Rainbond集群之外，运行生命周期不受Rainbond管理，且在网络上能够与Rainbond集群通信的服务称为第三方服务。例如单独运行的Oracle服务，或运行于Windows服务器的.net服务等。\nRainbond支持第三方服务管理的初衷 Rainbond作为一款云应用操作系统开源产品，在众多的企业中落地使用的过程中出现了两类共同的问题：\n 循序渐进的迁移策略，已经上Rainbond的服务如何与遗留服务通信和统一管理。  ​ Rainbond以应用为核心，应用的关键是服务，Rainbond提供了一套成体系的服务注册和发现机制来维护服务之间的配置共享和通信。但是过去的版本中对于未迁移到Rainbond的服务却鞭长莫及。用户不管是在传统应用架构向微服务架构转化过程，还是从传统运维向Rainbond迁移的过程，我们都非常推荐用户循序渐进的进行。那么在这个过程必然出现集群内外服务共存的现象，举个例子：我有一个传统服务化架构，都使用同一个Oracle数据库，Oracle数据库运行于一台特定的服务器中，第一阶段我们不改变它。首先将部分服务迁移到了Rainbond平台，这些服务即需要访问Oracle服务，还需要访问其他未迁移的服务。在Rainbond中我们推荐使用环境变量的方式定义配置，过去我们就需要重复的为每个服务定义相同的变量信息，如果后期有变化，又得全部重新改一遍。另外，服务需要访问其他服务，过去只能直接定义服务的IP地址，无法使用Rainbond提供的服务通信治理功能。再者在Rainbond平台可以可视化的观察服务拓扑关系和通信状态，然而对于处于集群外的服务无法在Rainbond中统一管理。\n Rainbond应用网关很好用，但是遗留的服务没办法与Rainbond上的服务共享外网端口或域名。  ​ Rainbond提供了让应用和服务向外网提供服务的能力，越来越多的用户希望Rainbond应用网关可以直接面向外网，即外网IP绑定到Rainbond网关节点，服务网关占用了80和443端口。但是这里马上就带来了问题，企业中可能还存在其他的服务需要被同一个域名访问到，因此过去我们没有办法，只能在Rainbond网关的前面继续添加一层nginx服务，这样带来的就是配置的巨大复杂性。同时未迁移到Rainbond的服务也没办法使用Rainbond网关提供的众多开箱即用的功能，比如域名访问监控。\n根据上诉的用户诉求，我们根据Rainbond的服务抽象定义，提出了支持第三方服务集成管理的新思路。\n第三方服务与内置服务的区别    对比项 内置服务 第三方服务     对接应用网关 支持 支持   被其他服务依赖 支持 支持   ServiceMesh治理 支持 支持上游通信治理   服务属性 全部属性 支持端口、连接信息、健康检查、权限\n支持静态或动态添加Endpoint   服务生命周期管理 全部支持 仅支持健康检查   分享应用市场 支持 V5.2版本支持   备份、恢复 支持 V5.2版本支持    "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/thirdparty-service/thirdparty-design/",
	"title": "第三方服务支持原理",
	"tags": [],
	"description": "讲解Rainbond支持第三方服务的支持原理",
	"content": " 第三方服务分类 第三方服务的最关键的是用户提供的服务通信地址，因此我们根据用户提供服务通信地址的方式将第三方服务分为两类：\n 静态注册第三方服务  顾名思义此类第三方服务是用户在创建时提供一个或多个固定的服务通信地址，我们称其为Endpoints。通信请求流量将固定的被负载到这些目标上去。\n 动态注册第三方服务  相对于静态注册，通常我们的服务还可能是一个动态的通信地址，因此我们支持基于第三方服务注册中心(etcd、zookeeper、consul)或Rainbond提供的API，让用户能够动态的更改服务的通信地址。这一类我们称为动态注册第三方服务。\n工作原理 第三方服务在Rainbond创建完成后，Rainbond应用运行时服务将自动开始维护服务的Endpoints, 通过上述两种方式Rainbond获取到服务的通信地址列表后，将会为每个服务创建一个模型来存储服务的Endpoints信息。此模型工作后将根据用户配置的健康检查策略来对服务进行健康检查，从而呈现服务Endpoints的健康状态。\n 健康检查  健康检查的方式分为TCP检查和HTTP检查，分别对应不同的服务类型。若实例处于不健康状态将会有两种处理方式：下线或不处理，当前默认设置为不处理，当用户设置为下线时，实例处于不健康将从集群中下线，从而网关或其他服务将不会访问到不健康的实例。\n Rainbond的服务访问安全控制  Rainbond服务通过设置端口的对内、对外开启属性来进行内部服务注册，这其实也类似于防火墙的概念。参考文档 ，对于第三方服务一样，通过设置端口的对内、对外开启属性来管控当前服务是否向网关或其他服务开启访问权限。\n 第三方服务端口设置  与内置服务一样，第三方服务也需要设置端口，不同的是第三方服务更加灵活。当前版本中我们规定第三方服务只能添加一个端口，那么这个端口与服务实际监听的端口有什么关系呢？\n通常情况下我们推荐设置端口与监听端口一致，便于理解。用户添加服务Endpoints时只需要提供服务的IP地址，服务多个实例就填写多个IP地址。对于这些服务我们默认为监听端口一致，因此Rainbond在与这些服务通信时将采用Endpoint定义的IP和服务定义的端口组成通信地址。\n 对接服务网关  第三方服务配置完端口后，开启对外服务对于HTTP类型即会与内置服务一样生成默认访问域名，应用网关接收到服务请求后将负载均衡到服务的Endpoints端点。此原理与内置服务一致，参考 应用网关\n 其他服务访问  与内置服务一样，其他服务需要访问第三方服务时需要依赖第三方服务，此时Rainbond ServiceMesh机制将会工作，根据用户配置的服务端口在访问端服务网络空间内建立本地监听，对服务的Endpoints进行负载均衡和其他服务治理。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/thirdparty-service/thirdparty-create/",
	"title": "第三方服务创建",
	"tags": [],
	"description": "讲解Rainbond支持第三方服务的创建方式和流程",
	"content": " 第三方服务创建 第三方服务创建依然存在两个入口，分别是平台左侧导航的 创建应用-添加第三方服务 和应用Dashboard页面的添加第三方服务按钮，创建流程一致。\n创建静态第三方服务  选择服务注册方式为静态注册\n 填写服务的通信地址\n  比如服务有两个运行实例，IP地址分别是192.168.0.1 192.168.0.2，为了设置方便，我们可以填写第一个实例时携带上端口配置，即提供如下的数据，告知Rainbond服务的监听端口是8080，且都一致。\n 192.168.0.1:8080\n192.168.0.2\n  提交创建，进入到服务的Dashboard页面对服务端口、连接信息、健康检查属性进行配置 参考第三方服务管理  创建动态第三方服务  选择服务注册方式为动态注册 选择动态注册类型 填写地址, Key 等服务注册中心的信息(用户名和密码为非必选项) 提交创建，进入到服务的 Dashboard 页面对服务端口、连接信息、健康检查属性进行配置。 参考第三方服务管理  服务注册中心中数据的格式 以 etcd 为例:\n/rainbond/service1/3201a2727b6445e9a9234a26284549e6 {\u0026quot;ip\u0026quot;:\u0026quot;192.168.0.1\u0026quot;, \u0026quot;port\u0026quot;: 5000} /rainbond/service1/728d17f86a5f3d834b6db984dd4a50ad {\u0026quot;ip\u0026quot;:\u0026quot;192.168.0.2\u0026quot;}  这是注册在 etcd 中的两条信息, 每一条代表一个第三方服务的实例. 其中 /rainbond/service1 为上面填写的服务注册中心的信息的 Key, 3201a2727b6445e9a9234a26284549e6 为这条数据的唯一标识(uuid), 以斜杠分割.\n{\u0026quot;ip\u0026quot;:\u0026quot;192.168.0.107\u0026quot;, \u0026quot;port\u0026quot;: 5000} 为第三方服务的实例的 IP 地址和端口. 如果没有\u0008提供端口, 那么 Rainbond 将会取你在参考第三方服务管理中添加的端口.\n创建基于API注册的第三方服务  选择服务注册方式为 API 注册\n 提交创建，进入到服务的Dashboard页面对服务端口、连接信息、健康检查属性进行配置 参考第三方服务管理\n 创建完成后, 可以根据总览页面中展示的API地址和密钥, 通过调用 API 的方式, 动态的更改服务的通信地址.\n  API 提供了 GET, PUT, DELETE 三种调用方式, 分别对应服务地址的查询, 添加(或修改)和删除.\nGET 下面是查询实例的 API 示例:\ncurl -s -G \\ --url http://ip:port/console/third_party/8ad4b1c7ffb305f2b59b6de625b1ee6a \\ --data secret_key=6RW0mYM3  执行完 curl 请求后, 会得到一个类似以下的响应:\n{ \u0026quot;msg\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;code\u0026quot;: 200, \u0026quot;msg_show\u0026quot;: \u0026quot;查询成功\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;list\u0026quot;: [ { \u0026quot;status\u0026quot;: \u0026quot;healthy\u0026quot;, \u0026quot;ip\u0026quot;: \u0026quot;192.168.0.1\u0026quot;, \u0026quot;is_static\u0026quot;: true, \u0026quot;is_online\u0026quot;: true }, ... ] } }  请求参数说明:\n   参数 是否必填 说明     secret_key 是 密钥, 可以从参考第三方服务管理的总览页中获取    响应参数说明:\n   参数 类型 说明     code int 业务码   msg string 对该请求的响应结果的详细描述   msg_show string 对该请求的响应结果的描述, 用于展示   status string 实例的状态, 可能的值为: healthy, unhealthy, unknown   ip string 实例的 IP 地址   is_static bool 实例是否属于静态类型, true: 静态类型; false: 动态类型   is_online bool 实例是否处于上线状态, true: 已上线; false: 已下线    PUT 下面是修改实例的 API 示例:\ncurl -X PUT \\ --url http://192.168.1.200:7070/console/third_party/8d545c3e8e7780b228b6dcc77561388b \\ -H \u0026quot;Content-Type: application/json\u0026quot; \\ -d '{\u0026quot;secret_key\u0026quot;:\u0026quot;4FsL5PWK\u0026quot;,\u0026quot;ip\u0026quot;:\u0026quot;192.168.0.1\u0026quot;,\u0026quot;is_online\u0026quot;:true}'  执行完 curl 请求后, 会得到一个类似以下的响应:\n{ \u0026quot;msg\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;code\u0026quot;: 200, \u0026quot;msg_show\u0026quot;: \u0026quot;修改成功\u0026quot; }  请求参数说明:\n   参数 是否必填 类型 说明     secret_key 是 string 密钥, 可以从参考第三方服务管理的总览页中获取   ip 是 string 服务实例地址, ipv4 格式   is_online 否 bool 是否上线, 默认 true    响应参数说明:\n   参数 类型 说明     code int 业务码   msg string 对该请求的响应结果的详细描述   msg_show string 对该请求的响应结果的描述, 用于展示    DELETE 下面是删除实例的 API 示例:\ncurl -X DELETE \\ --url http://192.168.1.200:7070/console/third_party/8d545c3e8e7780b228b6dcc77561388b \\ -H \u0026quot;Content-Type: application/json\u0026quot; \\ -d '{\u0026quot;secret_key\u0026quot;:\u0026quot;4FsL5PWK\u0026quot;,\u0026quot;ip\u0026quot;:\u0026quot;192.168.1.107\u0026quot;,\u0026quot;is_online\u0026quot;:true}'  执行完 curl 请求后, 会得到一个类似以下的响应:\n{ \u0026quot;msg\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;code\u0026quot;: 200, \u0026quot;msg_show\u0026quot;: \u0026quot;删除成功\u0026quot; }  请求参数说明:\n   参数 是否必填 类型 说明     secret_key 是 string 密钥, 可以从参考第三方服务管理的总览页中获取   ip 是 string 服务实例地址, ipv4 格式    响应参数说明:\n   参数 类型 说明     code int 业务码   msg string 对该请求的响应结果的详细描述   msg_show string 对该请求的响应结果的描述, 用于展示    PUT 和 DELETE 方法的请求内容的类型为 application/json  第三方服务创建示例 对接内部服务  如Rainbond平台的rbd-app-ui或者rbd-monitor组件\n 创建完成后,需要手动上线。\n针对示例来说，如果不想对外开放7070端口或者想通过80/443访问控制台可以通过此方式实现。\n对接阿里云RDS 目前不支持添加第三方服务地址为域名，将在下个版本里支持。  调整流程和对接平台内部服务一样，有几点需要注意，如果平台应用需要依赖第三服务安装的MYSQL,需要开启对内访问，同时需要手动添加应用连接信息。\n"
},
{
	"uri": "http://skyzhangyf.github.io/quick-start/",
	"title": "快速开始",
	"tags": [],
	"description": "",
	"content": " 快速开始 本章节将带你初步了解Rainbond项目，并选择适合的方式安装Rainbond。\n"
},
{
	"uri": "http://skyzhangyf.github.io/architecture/",
	"title": "架构",
	"tags": [],
	"description": "",
	"content": " 快速开始 本章节将从Rainbond的设计思想，技术架构等多方面带你了解Rainbond。\n"
},
{
	"uri": "http://skyzhangyf.github.io/quick-start/rainbond_overview/",
	"title": "简介",
	"tags": [],
	"description": "Rainbond支撑企业应用的开发、架构、交付和运维的全流程，通过“无侵入”架构，无缝衔接各类企业应用，底层资源可以对接和管理IaaS、虚拟机和物理服务器。",
	"content": " Rainbond是什么  Rainbond（云帮）是企业应用云操作系统。 Rainbond支撑企业应用的开发、架构、交付和运维的全流程，通过“无侵入”架构，无缝衔接各类企业应用，底层资源可以对接和管理IaaS、虚拟机和物理服务器。   企业应用包括： 各类信息系统、OA、CRM、ERP、数据库、大数据、物联网、互联网平台、微服务架构等运行在企业内部的各种系统。\n Rainbond可以做什么  企业应用开发  开发环境、微服务架构、服务治理及各类技术工具“开箱即用”，不改变开发习惯，让企业专注核心业务，提升10倍效率。\n 企业应用交付  支持持续交付、企业应用市场交付、SaaS化、企业应用销售、二次开发等交付流程，客户统一管理，兼顾标准化交付和个性化交付\n 企业应用运维  透明对接管理多种计算资源，天然实现多云和混合云，企业应用自动化运维，提高2倍资源利用率。\nRainbond主要特性    特性 描述     超越Kubernetes 平台底层基于Kubernetes，但用户无需学习和编辑复杂的yaml文件，通过应用级图形界面操作使用，现实业务流程开箱即用。   原生Service Mesh微服务架构 跨语言、跨协议、代码无侵入的Service Mesh微服务架构原生支持，传统应用直接变成微服务架构。同时支持常见微服务架构Spring Cloud、Dubbo等，通过插件扩展架构能力及治理功能。   一体化DevOps 衔接需求、开发、测试、构建、上线、运维的一体化DevOps。支持对接第三方软件（Jira、Sonar、Jenkins、Gitlab等）。   企业级应用市场 非镜像市场和服务目录，支持各类企业级应用，像手机应用即点即用，全流程管理（应用开发、应用发布、应用展示、应用离线导入/导出、应用安装/升级、应用运维）。   自动化运维 应用自动化运维。节点自动安装、扩容、监控、容错。平台支持高可用、多数据中心管理、多租户管理。   Serverless PaaS 以应用为核心，使用过程不需要了解服务器相关概念，简单灵活。通过对接行业应用，快速构建行业专有PaaS。     更多特性请见 功能列表 版本计划详见 开发计划  Rainbond的优势  只需要关注自身业务，业务之外的技术问题（资源管理、运维、架构、治理、环境等），一站式解决。 Rainbond结合行业应用，通过模块化组装和少量定制开发，就可实现行业专属开发、交付、运维平台。 通过“无侵入”架构，支持各类遗留系统，也不需要改变开发习惯。 系统兼容性强，Windows、国产系统均可支持。  我已经了解，开始安装\n 了解企业服务\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/quick-start/rainbond_overview1/",
	"title": "简介",
	"tags": [],
	"description": "Rainbond支撑企业应用的开发、架构、交付和运维的全流程，通过“无侵入”架构，无缝衔接各类企业应用，底层资源可以对接和管理IaaS、虚拟机和物理服务器。",
	"content": " Rainbond是什么  Rainbond（云帮）是企业应用云操作系统。 Rainbond支撑企业应用的开发、架构、交付和运维的全流程，通过“无侵入”架构，无缝衔接各类企业应用，底层资源可以对接和管理IaaS、虚拟机和物理服务器。   企业应用包括： 各类信息系统、OA、CRM、ERP、数据库、大数据、物联网、互联网平台、微服务架构等运行在企业内部的各种系统。\n Rainbond可以做什么  企业应用开发  开发环境、微服务架构、服务治理及各类技术工具“开箱即用”，不改变开发习惯，让企业专注核心业务，提升10倍效率。\n 企业应用交付  支持持续交付、企业应用市场交付、SaaS化、企业应用销售、二次开发等交付流程，客户统一管理，兼顾标准化交付和个性化交付\n 企业应用运维  透明对接管理多种计算资源，天然实现多云和混合云，企业应用自动化运维，提高2倍资源利用率。\nRainbond主要特性    特性 描述     超越Kubernetes 平台底层基于Kubernetes，但用户无需学习和编辑复杂的yaml文件，通过应用级图形界面操作使用，现实业务流程开箱即用。   原生Service Mesh微服务架构 跨语言、跨协议、代码无侵入的Service Mesh微服务架构原生支持，传统应用直接变成微服务架构。同时支持常见微服务架构Spring Cloud、Dubbo等，通过插件扩展架构能力及治理功能。   一体化DevOps 衔接需求、开发、测试、构建、上线、运维的一体化DevOps。支持对接第三方软件（Jira、Sonar、Jenkins、Gitlab等）。   企业级应用市场 非镜像市场和服务目录，支持各类企业级应用，像手机应用即点即用，全流程管理（应用开发、应用发布、应用展示、应用离线导入/导出、应用安装/升级、应用运维）。   自动化运维 应用自动化运维。节点自动安装、扩容、监控、容错。平台支持高可用、多数据中心管理、多租户管理。   Serverless PaaS 以应用为核心，使用过程不需要了解服务器相关概念，简单灵活。通过对接行业应用，快速构建行业专有PaaS。     更多特性请见 功能列表 版本计划详见 开发计划  Rainbond的优势  只需要关注自身业务，业务之外的技术问题（资源管理、运维、架构、治理、环境等），一站式解决。 Rainbond结合行业应用，通过模块化组装和少量定制开发，就可实现行业专属开发、交付、运维平台。 通过“无侵入”架构，支持各类遗留系统，也不需要改变开发习惯。 系统兼容性强，Windows、国产系统均可支持。  我已经了解，开始安装\n 了解企业服务\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/quick-start/rainbond_install/",
	"title": "平台安装",
	"tags": [],
	"description": "Rainbond安装教程引导",
	"content": " 快速安装Rainbond  此方式适用于你想快速安装和试用Rainbond平台, 最少只需要单台裸系统机器即可安装完成。此方式为基础安装方式，后续安装方案都是在本方案基础上的扩展和延伸。\n 安装请阅读： 快速安装\n阿里云安装Rainbond  此方式适用于你使用阿里云服务资源，此方式我们将使用阿里云 ECS+NAS+专有网络(弹性IP)等资源。\n 安装请阅读： 基于阿里云资源安装Rainbond\nRainbond高可用部署方案  此方式将首先引导你进行相关资源的规划和准备，以完成高可用集群的部署。\n 安装请阅读： 从零开始搭建Rainbond高可用集群\nRainbond与已存在Kubernetes集群对接安装  此方式适用于已安装Kubernetes集群的用户，此安装方式Rainbond将使用用户提供的Kubernetes集群。\n 安装请阅读： 基于已有Kubernetes集群安装\n离线安装Rainbond  此方式适用于外网网络受到严格限制的用户，此版本目前仅支持CentOS 7.4.1708系统。\n 安装请阅读： 离线安装\n自定义安装  此方式适用于熟悉ansible使用的用户\n 自定义安装请阅读: 自定义安装\n"
},
{
	"uri": "http://skyzhangyf.github.io/enterprise_service/",
	"title": "企业服务内容",
	"tags": [],
	"description": "Rainbond支撑企业应用的开发、架构、交付和运维的全流程，通过“无侵入”架构，无缝衔接各类企业应用，底层资源可以对接和管理IaaS、虚拟机和物理服务器。",
	"content": " 企业服务定位 Rainbond和容器平台最大的差异是抽象层次，Rainbond核心抽象是应用，支持应用的全生命周期管理，使用者无需学习容器技术，使用效率更高。\nRainbond企业服务在Rainbond之上，建设面向企业应用的业务交付流程，核心提升企业应用交付效率，并且支持各种复杂交付流程：\n 互联网公司交付流程 企业软件公司交付流程 行业云交付流程 大型企事业单位IT流程  Rainbond企业服务实现企业应用、企业计算资源和租户的互联互通，根据交付场景需要自定义交付流程。\n开源和企业版差异 企业服务场景 场景1：企业应用SaaS改造 随着社会和商业的不断发展，越来越多企业IT开始选择用「服务」取代传统的「产品」形式，更直接地为用户创造并传达价值，以此获得面向未来的竞争力。 软件企业同样如此——从提供软件产品到提供软件服务，SaaS化转型成为当今软件企业发展的必经之路和必定方向，但却面临着改造周期长、技术要求高、无法同时满足标准交付和个性化交付需求的难题。这些难题不仅是「SaaS改造」的关键点，也是增强软件企业竞争力的关键点。\n服务内容：\n 应用SaaS改造 （不修改或少修改原应用） 交付流程设计和实施 支撑自动化客户交付  场景2：建设企业应用市场 搭建专有企业应用生态，开发者或软件厂商可以自主开发和销售应用，使用者从应用市场挑选应用，按需购买付费，构建类似手机App Store的体验。\n服务内容：\n 企业应用市场设计方案 建设企业应用市场（商业流程定制） 企业应用市场运营  场景3：复杂的企业应用交付 复杂的交付场景，会降低交付效率，通过自动化改造，来提升交付效率，降低交付成本。 复杂的交付场景包括：\n 多云管理和交付 混合云交付 离线环境交付 私有云交付 远程定制开发 跨云应用和数据迁移 解决方案复制和交付  服务内容：\n 根据场景设计交付流程 建设自动化交付体系 辅助客户交付  场景4：行业云建设 Rainbond是一个通用的平台，只要结合行业应用和行业计算资源，就能快速形成行业云。\n服务内容：\n 行业云建设方案 行业云建设（行业应用迁移/平台定制）  场景5：遗留系统上云 企事业单位内部有大量老旧应用系统，不同开发语言，不同架构，不同操作系统，独立的安装和维护，导致运维成本很高，迁移上云也是一个大问题。Rainbond通过“无侵入架构”，能黑盒的迁移这些遗留系统，实现统一管理和运维。\n服务内容：\n 搭建应用管理平台 遗留系统迁移上线  申请免费试用\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/architecture/design-concept/",
	"title": "设计思想",
	"tags": [],
	"description": "",
	"content": " 企业应用云操作系统 \n对于企业IT来说，企业应用是企业IT价值的最主要体现，然而，当前不管是开发应用还是使用应用，都需要面对最底层的计算资源（IaaS/虚拟化/物理服务器），导致技术栈很长，需要做很多跟业务不直接相关的工作，比如：开发和运行环境搭建；服务器管理；网络管理；交付流程管理；技术架构支持；基础技术服务提供；技术工具维护等运维和技术工作，而这些工作对所有企业应用是有通用性的，如果把这些工作统一包装并自动化完成，企业专注自身业务，这样就能让企业IT的效率大幅度提高。\nRainbond 通过 以应用为中心 的方式包装以上重复性工作，并在此上支撑企业应用的开发、架构、交付和运维，这种抽象粒度，即能简化企业应用的管理，又能满足业务的灵活性。在对接底层基础设施时，通过软件定义实现和对接，能做到对接各类基础设施。通过以上设计，自然形成了企业应用的操作系统。\n无侵入架构 \nRainbond把广泛支撑企业应用作为首要目标，广泛支撑企业应用意味着各种企业应用都能在Rainbond上开发、架构、运维，这点也是影响使用体验的关键点，为了实现这个目标，Rainbond采用无侵入架构。无侵入架构表现在使用简单，已有应用不需要改动就能支持。\n具体从三方面入手：\n 在开发阶段，对接代码仓库，自动识别开发语言类型，不改变开发者习惯，尽量最大可能不修改现有代码，直接编译、构建和运行。\n 在架构阶段，如果已有系统没有分布式架构，Rainbond提供Service Mesh 架构，业务模块不改代码就能变成微服务架构。\n 在运维阶段，老的遗留系统很难找到原有开发人员，要迁移到新运行环境比较困难，Rainbond使用动态生成配置文件和网络关系的方式，迁移和运行遗留系统。运维和治理功能，Rainbond通过“无侵入”插件的形式提供，根据功能需要选择加载插件。\n  无侵入架构还表现在，对使用者无绑定，开发的应用程序可以脱离Rainbond开发和运行。\n以应用为中心，连接企业应用和企业计算资源 \n以应用为中心是Rainbond的核心设计理念，也是Rainbond的抽象思路，强调关注业务，跟业务相关技术概念对外暴露，跟业务不直接相关的技术概念统一包装。通过这种方式抽象，使用者不用过多考虑服务器的问题，也就是Serverless架构。\n通过以应用为中心抽象可以将企业应用和企业计算资源解耦，企业应用的生命周期管理跟计算资源不直接相关，也就是说企业应用的开发可以在任何类型的计算资源上，开发好的企业应用可以直接安装运行在任何类型的计算资源上，还可以随时从一个资源迁移到另一个资源。\n计算资源对使用者完全透明，根据使用场景差异对接计算资源，当计算资源对接的是公有资源，就是公有云，当计算资源对接的是私有资源，就是私有云，当计算资源同时对接公有资源和私有资源，就是混合云。\nRainbond通过解耦实现连接企业应用和企业计算资源，对接的各类企业应用积累形成企业应用市场，对接的各类企业计算资源积累形成企业计算资源市场，应用市场中的应用和资源市场中的资源可以自由组合使用。组合使用的过程，表现为SaaS和PaaS两种交互界面。SaaS实现不懂技术的即点即用，PaaS实现高级的定制开发。\n"
},
{
	"uri": "http://skyzhangyf.github.io/architecture/flow/",
	"title": "业务流程",
	"tags": [],
	"description": "",
	"content": " 抽象流程 \nRainbond的流程建立在以应用为中心抽象基础上，以交付为目的\n场景流程 互联网公司交付流程 \n企业软件公司交付流程 \n行业云交付流程 \n大型企事业单位IT流程 \n"
},
{
	"uri": "http://skyzhangyf.github.io/quick-start/edition/",
	"title": "功能列表",
	"tags": [],
	"description": "",
	"content": " 开发计划\n\n发布周期\n\n本文档列举Rainbond开源版具备的重点基础功能，随着版本升级本文档列举不一定完全，如有疑问请于社区留言咨询。\n应用的部署    功能 功能描述     支持源代码持续构建 支持PHP源码编译，支持PHP源代码、PHP5.3~7版本运行时，apace、nginx构建应用，并支持流行的PHP开发框架    支持Java源码编译，支持Java（maven）源代码、war包、jar包构建应用，并支持流行的java开发框架    支持Python源码编译，支持Python源代码、Python 2.6~3.2运行时构建应用，并支持流行的Python开发框架    支持Node.js源码编译，支持Node.js源代码、Nods.js 6.x~10.x运行时构建应用，流行的Node.js开发框架，包括前端类项目。    支持Golang源码编译、Golang 1.8.x，1.9.x运行时构建应用，并支持流行的Golang开发框架    支持dotnet源码编译、支持选择多个版本的编译和运行环境（.netcore linux运行）    支持Dockerfile识别和构建，支持Dockerfile源码的方式构建应用    支持Helm Chart源码识别和构建（TODO）       Docker镜像持续构建 支持基于DockerRun命令识别服务运行方式构建服务组件    支持解析DockerCompose文件识别服务运行方式批量构建服务组件    支持从私有镜像仓库、公有镜像仓库获取Docker镜像    支持镜像仓库Webhook服务的持续部署与发布       支持集成Git源码仓库 分租户的代码仓库管理，针对不同的团队隔离代码仓库    支持GitWebhook自动回调功能，实现应用的持续部署与发布    支持代码分支、tag部署，支持使用不同的代码分支、tag构建应用       支持集成Svn源码仓库 支持从Svn代码仓库获取源码，支持账户授权和子目录构建       支持Windows应用创建 支持基于Dockerfile、镜像创建Windows类服务（.net或mfc架构传统应用）（TODO）       支持第三方服务集成管理 支持管理运行于Rainbond集群外的服务，并与Rainbond应用网关和ServiceMesh网络无缝集成。       支持应用12要素原则 平台遵循或兼容PaaS平台应用的12要素原则       一键部署及回滚 实时显示部署及回滚过程，应用的部署与回滚过程要实时可见，方便排查问题    版本构建历史可追溯，显示版本详细信息，要可以追溯到应用的各个部署版本及详细的部署信息，包括代码提交信息，操作人员等    支持自动不间断滚动升级，应用部署，升级过程中不能影响现有业务，提供不间断业务的升级机制    支持一键回滚，支持应用的快速回滚，且不应影响现有业务       支持自定义的pipeline 支持基于API 对接Jenkins Pipeline, Jenkins处理完成后由Rainbond完成后续CI/CD流程        服务管理与运维    功能 功能描述     服务生命周期管理 支持对服务的启动、停止、更新、升级、持续构建管理    支持无状态应用的滚动升级，升级过程不影响业务    支持有状态应用的滚动升级，集群服务升级过程不影响业务    支持基于应用市场的服务升级策略    支持针对应用操作的严格的权限管理机制与审计机制       服务配置管理 支持基于环境变量的服务配置管理    直接基于动态配置文件的服务配置管理    支持基于动态注入的连接信息配置管理       服务构建源管理 支持持续调整服务构建源设置    支持设置服务源码构建参数，根据不同的语言设置Runtime版本，编译参数等       服务日志管理 支持实时应用级汇总，存储，分割和实时展示，能实时显示应用的日志、汇总分析日志、日志存储与下载功能    支持基于插件对接ELK等日志分析服务，能够对接业界流行的日志分析工具，如ELK进行展示与分析       服务伸缩管理 支持不中断服务的的水平伸缩和垂直伸缩操作，平台应用应具备生产级（不中断业务）水平与垂直伸缩服务的能力    支持基于业务级分析指标的自动伸缩策略，平台具备根据业务分析指标来达到自动伸缩服务的能力（TODO）       服务高可用保证 支持便捷部署高可用分布式服务，将数据与计算分离，网关与计算分离。    赋予大多数Web服务分布式部署能力       服务性能分析与监控 支持常用应用协议的实时性能（响应时间和吞吐率）分析，支持常用应用协议，如HTTP、TCP、MYSQL的实时性能分析，如响应时间，吞吐率等功能    支持请求Top实时展示，应用的性能分析以列表的形式展示，并能将影响性能最大的URL/SQL语句进行排序    支持历史分析数据查询，应用的性能分析日志支持按小时与日期进行查询    支持服务实例实时状态展示和 实例内存实时状态展示和监控       服务健康检测 支持基于多种策略的应用健康检测，平台对运行的不同协议类型的应用进行实时的监控检查    支持不健康应用实例的自动下线，针对异常的应用，支持配置不同的处理策略       服务管理终端 支持基于web的终端管理，平台应用具备web 控制台功能，方便开发人员登录应用内部临时调试程序。    支持基于命令行的终端管理，平台应支持命令行的方式进行管理，如创建应用，启/停应用，扩容应用等操作    应用管理    功能 功能描述     应用级生命周期管理 支持应用级启动、停止、构建、升级操作    支持动态维护应用内部服务直接依赖关系       拓扑图可视化 全局业务拓扑实时状态展示，能实时显示业务组的连接（网络）拓补图展示功能    支持可视化编辑服务服务注册和服务发现    支持拓扑流量实时展示，具备拓扑图的流量监控及监控状态显示功能       应用备份与恢复 支持应用级整体全量备份    支持备份跨租户、跨数据中心迁移和恢复    支持备份数据的导入和导出       应用分享 支持应用分享到企业或团队内部市场或企业公有云市场       应用升级 基于应用市场的应用自动化升级和回滚    应用网关管理    功能 功能描述     HTTP应用访问策略 支持基于域名、访问路径、请求头、Cookie的访问路由控制    支持HTTPs访问策略    支持HTTP与HTTPs共存，HTTP Rewrite HTTPs策略    支持泛域名策略    自定义负载均衡算法，支持轮询算法，一致性Hash算法，Session粘连算法       TCP/UDP应用访问策略 默认支持基于IP+端口的TCP\\UDP访问策略管理    支持内网IP和外网IP隔离的访问策略       TLS证书管理 支持导入第三方签发的TLS证书    支持证书的状态监控和管理    支持自动签发TLS证书（TODO）       虚拟IP池管理 支持集群虚拟IP资源池管理（TODO）       服务测试升级策略 支持A/B测试控制    支持灰度发布控制       服务安全控制 插件化支持JWT业务安全认证（5.2版本计划）    插件化支持白名单、黑名单控制管理（5.2版本计划）    插件化支持与第三方Auth2.0认证体系对接（5.2版本计划）    插件化支持WAF防火墙（5.2版本计划）       网关监控 对接Prometheus监控域名、服务的实时访问数据    监控网关运行的实时数据   服务访问日志管理 支持与第三方日志服务对接，发送服务访问日志到第三方平台（5.2版本计划）    应用插件的管理与设计    功能 功能描述     具备完善的应用高级功能扩展架构 服务除本身功能以外可以无侵入的扩展其他高级功能，例如防火墙，日志处理，性能分析，网络治理等，建立标准的应用插件体系规范非常关键。插件是独立存在，与应用绑定运行的程序，与应用具有相同的运行环境，可以定义插件独有的配置信息。    具备插件与应用协同工作的基础运行环境，例如提供服务发现，配置发现，环境配置等。    具有完善的应用插件开发，部署流程，与应用可以便捷的绑定。能够自助完成应用插件设计       应用插件支持标准化传播共享 应用插件具备标准化传播能力，可以单独或与应用绑定分享到应用市场    支持从应用市场安装和使用插件       提供常用的应用插件 提供生产可用的插件用例，例如日志分析、MySQL数据备份、应用性能分析、网络治理等。    微服务架构    功能 功能描述     提供Service Mesh架构支持 支持跨语言和跨协议服务调用    支持多种Service Mesh框架实现（envoy、linkerd等），针对不同场景可实时替换    支持服务自动注册和发现    支持透明的负载均衡，服务可以随时伸缩    支持服务治理：高级路由、限流、熔断机制       支持服务拓扑显示 通过拓扑图显示服务之间的依赖关系       支持服务动态编排 不需要修改配置文件，动态编排服务依赖关系       支持对接其他微服务架构 支持对接Dubbo    支持对接Spring cloud       支持API gateway 支持通过插件扩展API gateway的功能    支持对接第三方登录，对接Oauth 2.0    支持限流和熔断    支持访问控制       支持通过插件机制实现服务治理 故障处理及恢复，熔断/限流    传输加密    网络策略管理    性能分析    支持tracing    支持内部服务A/B测试和灰度发布    支持基于域名/Path/header的业务路由    应用市场管理    功能 功能描述 说明     应用发布和安装和升级 支持自助发布一组服务到应用市场，包括程序，环境与配置，数据，拓扑关系，插件扩展。     用户可以在应用市场一键安装，不需要懂技术     支持跨数据中心发布应用和安装应用     发布新版本后，应用可以一键升级         在线和离线的应用交付 支持应用市场间应用同步     支持应用导出安装包兼容 docker-compose。     支持应用离线导入与导出，导入后可以一键安装使用         应用市场展示功能 支持应用多级分类显示，用户可以分类筛选     支持应用搜索     显示应用名、logo、简介和版本     支持应用市场的审核机制         多级应用市场 支持三级应用市场隔离，发布应用时可选应用可见的粒度。     支持对接公有应用市场，其他应用市场     多数据中心管理 见企业服务支持\n系统运维平台    功能 功能描述     便捷的数据中心安装和升级 支持对数据中心内节点进行分类管理，例如分为：负载均衡节点，管理节点，存储节点，计算节点。实现对所有节点的统一管理    支持多个管理节点的在线，离线安装与升级，例如Kubernetes服务，平台管理服务    支持计算节点的安装与升级    支持对基础环境，如系统内核、docker、网络、存储的安装和升级       节点管理 支持基于命令行的节点管理        关于多租户管理，UI可视化运维，监控与报警系统等企业服务功能见企业服务支持\n平台其他功能及技术架构    功能 描述     标准RestfulAPI开放设计，支持二次开发 支持应用标准化管理API开放，基于用户授权的安全验证策略    平台管理API开放，支持对用户，租户，权限等管理    资源管理API开放，支持对集群节点，资源调度情况进行管理       应用与资源解耦合 架构思路上应用不与计算资源绑定，支持根据需要随处迁移       支持多功能命令行工具 命令行工具支持应用的启动，停止，调度，综合状态查询功能    命令行工具支持租户查询，批量操作功能    命令行工具支持集群节点管理，资源调度管理       权限管理 支持在租户级别自定义角色名称，自定义分配权限，用户自定义支持多种角色    支持应用级别权限精确控制，可继承租户级别权限    控制权限严格验证，做到API级别安全控制       Overlay网络架构支持 支持多租户网络隔离的Overlay网络模型    支持虚拟机、容器统一的网络资源（IP,路由）自动化分配，虚拟机与容器可以同时组成租户网络       支持多种类型的存储系统对接 支持应用级别自助设置多种存储设备对接，包括：分布式文件系统，块设备，内存虚拟存储等    支持存储数据的备份，快照与恢复       应用调度系统 基于Kubernetes的docker容器调度系统，不必要暴露过多的容器技术概念，支持平台级的应用调度参数设置    支持自定义调度策略的设置和二次开发       服务间内部负载均衡 内部服务之间的访问能够自动进行服务发现和负载均衡    应用之间的负载均衡功能可插件化扩展，支持高级的服务治理    更多功能 关于SaaS化应用交付体系、企业级应用市场、企业资源管理平台、企业级监控报警系统以及更多的Rainbond企业级支持见 企业服务支持\n"
},
{
	"uri": "http://skyzhangyf.github.io/architecture/architecture/",
	"title": "技术架构",
	"tags": [],
	"description": "",
	"content": " Rainbond技术架构 \nRainbond践行以应用为中心的理念，吸纳优秀的社区解决方案，形成了应用控制、应用运行时，集群控制三大模块结合的数据中心技术架构，结合跨数据中心的上层结构应用控制台和资源控制台，形成了完整的PaaS平台解决方案，下面将对每个组件集进行简述：\n数据中心服务组件说明 数据中心API服务 API服务作为数据中心级抽象的核心控制服务，对外提供Restful风格的API服务，是数据中心控制流的唯一入口，安全控制基于TLS双向安全认证。\nAPI服务处理三类请求：\n元数据操作请求 直接操作元数据存储数据库。\n异步任务请求 根据业务特性发送异步任务事件到消息中间件。\n代理请求 API服务同时代理了后端Websocket信息推送服务、监控服务、Web终端控制服务。\n应用网关服务 应用网关是\u0008外部\u0008\u0008流量进入Rainbond内部\u0008服务的唯一入口, 提供HTTP, HTTPs路由, TCP/UDP服务, 负载均衡器, 高级路由(A/B测试, 灰度发布)等功能.\n应用网关的大部分灵感来自于NGINX Ingress Controller, 通过kube-apiserver将监听到的Kubernetes资源(Ingress, Service, Secret, Endpoint)应用到Nginx上, 再由Nginx把Rainbond内部的服务暴露出去.\n应用网关的高可用和数据一致\u0008性:\n为了\u0008避免网络故障, 宕机或其它因素\u0008使得应用网关无法正常工作, 从而导致内部服务无法被访问, 有必要为应用网关高可用(尤其在生产环境中). Rainbond应用网关的高可用方案是: 配置两个或两个以上的状态完全一样的应用网关, 并且为这些应用\u0008网关配置\u0008一个四层的负载均衡器或VIP. 每一个应用网关的数据一致性由Kubernetes的Watch机制来保证, 另处, 应用网关会每10秒同步一次K8s的资源. 如下图所示:\n应用构建服务 Rainbond 应用构建服务处理CI过程，将输入源 包括 源代码 或 Docker镜像 或 应用市场应用 进行解析、编译、打包，最终生成 应用（服务）抽象 介质。\n传统意义上说，完整的CI过程会包括：设计、编码、打包、测试和发布，Docker镜像自推出以来逐步成为众多应用代码打包的新形式。现有的CI产品中已经在源码测试和Pipline方面做得非常成熟，例如Jenkins，Gitlab等，因此Rainbond在对于源码或Docker镜像的前置处理方面可以直接对接第三方服务，由第三方服务处理完成的源码或镜像再对接到 Rainbond-Chaos 模块进行应用抽象。\nChaos的输入源是支持Git、Svn协议的代码仓库，Docker镜像仓库。如果是源代码，Chaos智能判断源码的类型，例如Java, PHP , Python, Dockerfile等，根据不同的源码类型选择对应的BuildingPack(源码构建器)进行源码编译，同时识别源码中定义的运行环境要求参数，应用端口、环境变量等参数，形成应用抽象的配置雏形。除了Dockerfile以外的源码类型将被编译成应用代码环境包（SLUG）存储于分布式存储中，其他的生成Docker本地镜像存储于数据中心镜像仓库中，结合应用的各类属性信息形成应用抽象包。\n  关于源码编译的BuildingPack参考各语言支持文档。 应用构建服务支持多点高可用部署，多点部署从消息中间件获取应用构建任务。   应用运行时控制服务 应用运行时控制服务将应用构建服务构建出来的应用抽象进行实例化，配属应用运行需要的各类资源，完成应用生命周期中的运行态部分，可以认为是CD流程。\n应用生命周期中可能经历启停、升级与回滚。不同的应用类型需要进行不同的控制策略，例如无状态应用能够进行无序的滚动升级，而有状态应用的升级控制策略将更加复杂。\n应用运行需要各种外部环境支持，例如需要分配租户IP,端口等网络资源，需要根据应用设置配属持久化存储资源，例如共享文件存储分配存储目录，块存储等依托各类插件分配存储资源。根据应用依赖属性建立服务发现和负载均衡策略供给mesh插件。根据应用属性生成调度策略调用Kubernetes集群调度应用运行。\n目前Rainbond使用Kubernetes以下资源类型：Deployment、Statefulset、Service、Ingress、Secret、ConfigMap、Pod。对于用户来说，无需理解这些资源，我们产品中也不体现，其只是应用运行的载体。\n worker组件功能分为有状态部分和无状态部分，为了实现worker组件的集群部署，worker进行了主节点选举，选举为主节点的服务将提供应用存储Provider和存储统计服务。\n 监控服务 Rainbond集群需要多个维度的监控：\n 应用业务性能级 应用容器资源级 集群节点级 管理服务级  Rainbond借助Prometheus封装了Monitor组件，能够自动发现以上描述的各类监控对象并完成配置，将监控目标纳入Prometheus监控范围。Rainbond各组件也都实现了Prometheus的exporter端暴露监控指标。\nPrometheus有单点性能障碍，例如单节点服务监控目标越多，内存与磁盘使用量大等问题，对于大型集群，我们借助monitor组件实现了Prometheus多点数据分区运行，并建立了Prometheus的集群查询机制。\n除了监控我们还需要报警，monitor能够自动配置一些默认的报警规则，自定义的报警规则支持将在资源管理后台体现，后续将支持命令行控制。Prometheus发出报警信息到monitor,完成去重，忽略等操作后根据级别与用户需求完成邮件、微信、站内消息等报警方式。\n消息中间件服务 MQ组件是基于etcd实现的轻量级分布式、消息持久化和全局一致性的消息中间件。该组件维护异步任务消息，提供多种主题的发布和订阅能力。\n我们没有选择使用已有的消息中间件服务，主要是我们要实现分布式消息，还要保证消息的一致性，评估了现有的方案后都觉得不太合适且复杂，因此我们基于etcd的分布式能力实现了轻量级MQ组件，提供了gRPC和http两种接口实现pub/sub。\n事件与日志处理服务 Rainbond平台需要处理的日志和消息信息包含三大类，分别为：用户异步操作日志、应用构建日志和应用运行日志，下面针对这三类日志加以详细说明。\n 用户异步操作日志  对于用户操作日志，我们需要分布式跟踪每一次操作的最终状态，目前由eventlog组件根据每一次操作的日志汇聚判断操作的最终状态。其他组件在处理某一次异步任务过程中会将过程日志记录通过gRPC消息流发送到eventlog集群。\n 应用构建日志  主要展示源码构建或Docker镜像构建的输出信息，这些信息来自于应用构建服务。\n 应用运行日志等  关于应用日志，目前我们分为两种形式：\n (1) 标准输出/错误输出的日志   对于标准输出的日志，计算节点日志收集器通过Docker Daemon获取日志流后进行业务分离，默认基于TCP数据流通信实现将所有计算节点的容器日志实时送往Eventlog组件按照应用级别的汇聚，从而进行存储和实时推送到UI，后续版本中日志收集器将实现与第三方 日志系统对接直接将日志输送到第三方日志处理平台。\n  (2) 输出到持久化文件的业务日志（访问日志）   对于输出到持久化目录的业务日志，一般需要对其进行自动分析，例如对接ELK系统，因此在插件体系中安装日志处理插件，收集持久化目录的日志文件输送到第三方日志分析服务上。\n 随着集群规模越大，运行应用越多，日志处理量非常大，因此我们实现了Eventlog的集群，每一个应用的日志在传输之前会选择送往的eventlog服务节点，类似于数据分区。选择过程中做了均衡分配处理，例如当前有10000个应用，3个eventlog服务节点，将做到每个eventlog节点分别处理3000左右应用日志。\n 由于各种实时推送的需要，eventlog组件实现了websockt服务。\n 集群、节点管理服务 \nNode组件是Rainbond集群组建的基本服务，集群内所有节点都需要运行该组件。\n运行于管理节点的Node具有master角色，维护所有节点的状态与健康检查。在监控方面，Node暴露出节点的操作系统级别各类指标（集成promethes node-exporter），同时定时检查不同属性的节点上运行的各类服务状态，网络状态等。监控到问题并尝试自动处理，以提供集群自动化运维能力。\n第二方面，所有计算节点运行的Node服务组建起租户网络内运行应用的运行环境支持，特别是ServiceMesh支持。\n \nNode提供了envoy的全局化配置发现支持，跟应用绑定的envoy插件通过宿主机网络跳出租户网络，访问到Node服务，并最终获取全局的服务网络治理配置。其他应用插件使用同样的机制从node服务中动态获取配置，应用运行信息等。\n应用Web终端控制服务 该组件实现了通过web的方式连接到容器控制台的功能。该组件通过与UI进行WebSocket通信，用户可以通过模拟Web终端发送各类shell命令，webcli通过kube-apiserver提供的exec方式在容器中执行命令并返回结果到Web终端。\n Webcli属于无状态组件，天然支持多点高可用部署。\n 元数据存储服务 Rainbond数据中心元数据目前支持存储于Mysql数据库或CockroachDB数据库。\nKubernetes Master服务 Kubernetes Master包含1.10.11版本的Kube-apiserver、Kube-ControllerManager、Kube-Scheduler三个组件。\nDNS服务 DNS服务为集群提供DNS解析服务, 基于Kube-DNS二次开发。\n镜像仓库服务 基于开源Distribution项目，用于当前数据中心下的容器镜像存储。\n包仓库（Artifactory） 基于开源 Artifactory项目，服务于应用基于源码构建，存储或代理应用构建所需要的所有第三方类库和文件包。是源码构建必须的组件，其可对接企业内部的其他包仓库。\n业务逻辑层组件说明 应用控制台 应用控制台UI组件作为Rainbond以应用为中心抽象的关键模块，面向应用开发者和应用使用者。基于Django+Ant design前后端分离架构设计，提供用户对应用抽象、应用组抽象，数据中心抽象，应用市场抽象提供交互体验。实现完整的应用创建、管理流程，应用交付分享流程等。\n资源管理控制台（企业版） 资源控制台UI组件提供Rainbond集群资源管理，计划支持对接IaaS的资源管理能力，面向运维人员设计。关注节点物理资源，集群资源，管理服务资源，应用实际使用资源，租户资源等管理。Rainbond自动化运维能力的关键展示平台。\n组件部署 组件部署架构文档\n"
},
{
	"uri": "http://skyzhangyf.github.io/quick-start/roadmap/",
	"title": "RoadMap",
	"tags": [],
	"description": "This document defines the roadmap for Rainbond development.",
	"content": " 功能列表\n\n发布周期\n\n本文档定义了Rainbond开发的路线图。\nV5.1.X版本规划 支持由JavaMaven多模块源代码批量创建服务 支持服务基于应用市场应用完整的升级 支持服务基于应用市场应用升级后的完整回滚 支持应用基于应用市场应用完整的升级  V5.2版本规划 应用运行时 支持基于Helm-Chart源码创建服务组件 基于业务级监控指标（吞吐率、响应时间）的从0开始的服务自动伸缩 支持基于Operator规范的有状态服自动化运维管理 支持服务生命周期操作事件的跟踪和取消 支持完整的服务生命操作和属性变更操作的记录和回滚  Windows支持 支持Windows服务组件Dockerfile构建 支持Windows插件构建,默认提供性能分析插件和网络治理插件 支持智能Windows服务类型检测 支持Windows节点安装  V5.1版本规划  已发布Release\n 应用运行时 支持第三方服务管理集成 支持内部服务ServiceMesh架构集成 支持网关对接集成 支持基于Etcd发现第三方服务 支持对第三方服务进行健康检查和状态维护  ServiceMesh支持envoy XDS规范 支持服务批量操作时控制服务批量启动顺序  应用网关 支持暴露域名、服务的访问情况实时监控数据 支持访问策略的高级配置参数（超时时间，上传限制等）  UI控制台 团队总览改版，支持更多监控数据可视化 支持各语言编译参数设置 支持从应用市场跨版本进行应用升级 支持服务构建源的重新检测  源码构建 支持NodeJS前端项目源码构建 静态语言类型增加对Nginx的支持 支持各语言编译参数的UI设置  安装\u0026amp;基础环境 默认安装Docker版本升级到18.06.3-ce 支持安装时指定NFS Server地址  关于5.1版本规划如果你有建议请于Rainbond社区t.goodrain.com反馈\n5.1以前版本规划详情\n"
},
{
	"uri": "http://skyzhangyf.github.io/quick-start/roadmap.5.0/",
	"title": "RoadMap(历史)",
	"tags": [],
	"description": "This document defines the roadmap for Rainbond development.",
	"content": " 功能列表\n\n发布周期\n\nV5.0版本规划（已发布Release） 应用网关 HTTP、TCP服务访问策略管理 HTTP策略支持基于域名、访问路径、请求头、Cookie访问路由控制 配置HTTPs规则、HTTP转HTTPs规则 支持泛域名规则 支持SSL证书管理 支持A/B测试、灰度发布控制 TCP策略支持基于IP、端口访问控制 自定义负载均衡算法，目前支持支持轮询算法，后续测试版本支持一致性Hash算法，Session粘连算法 支持集群部署，高可用与流量均摊，可工作于4层高性能软硬件负载均衡之后。  应用运行时 应用运行时完整重构，提供以应用为核心的控制器抽象 无状态服务部署类型更改为Kubernetes Deployment资源 有状态服务本地存储、共享存储提供更改为动态PV，运行时提供Provider 应用状态维护由集中式更改为分布式，去除单点间歇性故障 有状态服务、无状态服务皆提供自动化滚动升级策略 默认Kubernetes版本升级到1.10版本 Docker版本升级到17.06版本 支持社区版本Kubernetes集群对接  应用构建（CI） Java PHP Python NodeJS Golang .NetCore 各语言可选Runtime版本全面升级 支持UI配置各语言编译参数选项 Java语言支持Gradle源码构建 ，支持War、Jar包部署 Dockerfile支持多阶段构建 支持离线环境下的源码持续构建（离线环境已具有必要的使用语言包仓库）  控制台UI 明确定义 应用/服务 两级抽象 应用Dashboard页面拓扑图应用状态实时刷新 应用Dashboard页面增加快捷创建服务组件的流程 应用Dashboard页面增加应用级启动、停止、升级控制 增加应用网关完整的控制流程页面 服务组件支持（更新升级）操作, 取代原重启操作。 服务组件支持源码构建配置 服务组件支持CI/CD流程分离 拓扑图增加编辑模式，动态编辑服务依赖关系 支持服务组件UI添加配置文件或模版  Windows 支持 node 组件支持windows节点部署，管理windows节点和平台服务 rbd-chao 组件支持windows节点部署，构建windows应用 服务构建调度支持区分windows和linux应用。 服务运行调度，存储支持Windows节点。 数据中心镜像仓库升级支持Windows镜像。  安装与运维 系统安装策略由SaltStack更换为Ansible 新加windowsutil组件支持传统程序或脚本部署为windows服务 支持多配置文件配置节点服务 支持Windows节点下服务守护和健康检查 grctl多个命令升级改造 内置支持安装flannel host-gateway网络  History version V3.7 2018-08-15 About system stability\nmanagement service progress guardian by systemd uniformly. support management node offline. support for all node and management service health checks. support for automatic offline of major fault nodes. tenant resource statistics task single node run. Support to set alarm rules and connect Prometheus-Altermanager alarm system  About application manage\nsupport .netcore(2.1) source code build application in linux os. support SVN code repository. support application build automatically based on API ,gitea webhook and gogs webhook support application + plugin share to market  About Security policy upgrade\nRegion api support TLS Two-way authentication [UI] support user registration for secondary verification by manager.  About install\nSupport complete offline installation Support install mulit manage nodes  V3.6 Estimated release time: 2018-06-15\nThe current version focuses on supporting the infrastructure of the microservice architecture, service governance, service backup \u0026amp; restore \u0026amp; migration.\nSupport the ServiceMesh micro service framework out of the box Support Application for grayscale publishing and A/B testing Support Limiting and Circuit breaker Support Intelligent routing Support flow analysis that differentiates sources,This is shown in the topology  Support Application group backup and restore Support Application group migration across datacenters and across tenants Support share plugin to market and install from market MySQL backup and restore plugin PostgreSQL backup and restore plugin MongoDB backup and restore plugin Log collect plugin\n WAF plugin  Support Export applications from the application market Export dockercompse specification Export rainbond-app specification  Support batch offline import applications to the application market\n Management service HA support Region DB support CockroachDB UI DB support TiDB  Support auto-building based on git webhook\n Support In-station letter announcement Monitoring module automatically finds monitoring targets and automatically configures them Compute node monitoring Management service monitoring  Accurate user permission control, support custom roles Update rbd-dns to support for custom generic domain name resolution and cluster level one domain default resolution  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/component-description/",
	"title": "平台组件架构",
	"tags": [],
	"description": "",
	"content": " 本文主要介绍完整部署Rainbond所需要的所有服务组件，帮助用户了解Rainbond技术栈与组件架构。\n目前版本，所有服务都通过Systemd进行管理。\n一、服务组件概述 以下是通过一键部署方式将会在服务器安装的Rainbond各服务组件及其版本信息。\n   组件 版本 安装属性 说明     docker 18.06 Master/Worker 应用容器引擎   node 5.x Master/Worker 集群监控与控制服务   kube-apiserver/kube-controller-manager/kube-scheduler v1.10.13 Master 应用编排和管理   kubelet v1.10.13 Master/Worker 节点复用时仅第一个管理节点启用   etcd/etcd-proxy 3.2.25 Master/Worker 管理节点etcd/计算节点etcd-proxy   calico v3.3.1 Master/Worker 集群SDN服务，为应用提供网络支持   rbd-dns 5.x Master Rainbond内部dns服务，可作为集群dns服务使用 源码   rbd-db 5.x Master 云帮数据库服务，支持MySQL，Tidb与CockroachDB   rbd-mq 5.x Master 消息队列服务   rbd-hub 2.6.2 Master 基于Docker Registry封装，提供docker镜像存储服务   rbd-repo 6.5.9 Master 源码构建仓库服务，基于Artifactory OSS封装   rbd-eventlog 5.x Master 云帮事件处理与日志汇聚服务   rbd-worker 5.x Master 云帮应用操作与处理服务   rbd-webcli 5.x Master 提供应用web方式进入容器命令行的服务   rbd-chaos 5.x Master 应用构建服务，提供源码，Docker镜像等方式创建应用   rbd-monitor 5.x Master 云帮服务监控组件，基于Prometheus封装   rbd-api 5.x Master 云帮区域中心API服务，提供底层服务接口   rbd-app-ui 5.x Master 应用控制台web服务   rbd-gateway 5.x Master/Lb 通向应用的全局网关，提供A/B测试、灰度发布等高级功能    组件高级用法可以通过点击组件的链接方式阅读。  二、逻辑架构图 \n三、附录 3.1 DNS服务说明 rbd-dns服务，除提供平台用户应用的域名解析之外，还提供内部组件互相访问的域名解析。\n   域名 说明     goodrain.me rainbond内部docker镜像仓库地址，rbd-hub提供服务   kubeapi.goodrain.me kube-apisever服务   region.goodrain.me 数据中心API服务   lang.goodrain.me 源码构建依赖包下载地址，rbd-repo提供服务   maven.goodrain.me maven仓库地址，rbd-repo提供服务   repo.goodrain.me 本地软件源,rbd-gateway提供服务,仅离线环境    3.2 部分服务端口说明  公网访问: 如部署在公有云环境需要公网访问需要安全组放行\n    端口号 说明 公网访问     7070 应用控制台web 需要安全组放行   6060 Websocket服务，提供日志、性能监控实时推送 需要安全组放行   2379,2380,4001 etcd服务    8181,6443 kube-apiserver服务    8443,8888 Rainbond API服务    53 rbd-dns提供的集群内部dns服务    80,443 rbd-gateway 提供的全局负载均衡服务 需要安全组放行    - etcd的4001为非安全端口，2379为安全端口 - kube-apiserver的8181为非安全端口，6442为安全端口, 6443为gateway代理端口 - rainbond API端口当只有一个数据中心时不需要对外开放，当多数据中心，且在不同网络时需要对外开放,8888非安全端口,8443为安全端口 - rbd-gateway提供的80与443端口是为HTTP协议应用提供，20001~60000是为TCP协议的应用提供。  更多具体端口信息请参考组件端口\n3.3 服务部署类型说明    部署类型 说明 组件名     二进制或者deb/rpm部署 通常使用apt或者yum方式安装,由systemd守护 node,docker,kubelet   容器化部署 通过docker run方式部署,由node生成systemd进行守护 其他组件都是容器化部署    "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/recommendation/",
	"title": "软件和硬件环境要求",
	"tags": [],
	"description": "",
	"content": " 概述 Rainbond 作为一款开源PaaS平台，可以很好的部署和运行在 Intel 架构服务器环境及主流虚拟化环境，并支持绝大多数的主流硬件网络。\nLinux 操作系统版本要求    Linux发行版本 版本     Red Hat Enterprise Linux 7.4 64位   CentOS 7.4.1708 64位   Ubuntu 16.04 64位   Debian 9 64位   中标麒麟 服务器版V7.4 64位     Rainbond在CentOS 7.4的环境下进行过大量的测试，因此，建议使用CentOS 7.4的Linux操作系统来部署Rainbond 以上 Linux 操作系统可运行在物理服务器以及 VMware、KVM、XEN 主流虚拟化环境上。  服务器要求 Rainbond 支持部署和运行在 Intel x86-64 架构的 64 位通用硬件服务器平台。对于开发测试，及生产环境的服务器硬件配置有以下要求和建议：\n开发测试环境    服务器角色 CPU 内存 本地存储 网络 实例数量     管理节点 4核 8G / 100G\n/cache 50G-100G\n/opt/rainbond/data 100G (推荐SSD)\n/var/lib/docker 100G+ 千兆网卡 1,3\u0026hellip;奇数   计算节点 16核 64G / 100G /var/lib/docker 100G+ 千兆网卡 不限制     验证测试环境中的计算节点可以和管理节点复用,复用时需要适当调高管理节点配置  生产环境    服务器角色 CPU 内存 本地存储 网络 实例数量     管理节点 8核 32G / 100G\n/cache 50G-100G\n/opt/rainbond/data 100G (推荐SSD)\n/var/lib/docker 100G+ 千兆网卡 3,5\u0026hellip;计数   计算节点 16核 64G / 100G /var/lib/docker 100G+ 千兆网卡 不限制   存储节点 4核 8G / 100G /data 1T+ 千兆网卡 3,4\u0026hellip;   网关节点 4核 8G / 100G /var/lib/docker 100G+ 千兆网卡 推荐至少3节点     生产环境中，建议管理节点，计算节点，网关节点,存储节点单独部署 生产环境强烈推荐使用更高的配置  节点类型说明:\n   节点类型 功能说明 备注     管理节点 Rainbond管理节点，集结平台自身组件，提供应用调度管理等高级功能 标识manage或master   计算节点 Rainbond计算节点，提供计算资源 标识compute或worker   Etcd节点 提供kubernetes所需etcd存储 默认部署于管理节点   网关节点 提供通向应用的网关 标识lb,默认部署于管理节点   存储节点 提供集群共享存储 标识storage,默认使用NFS存储，可对接其它存储(/grdata)    系统环境要求  确保机器重启，服务器IP地址和nameserver不发生改变，推荐配置静态ip 确定系统时间与时区(Asia/Shanghai)同步,节点间时间要同步 确定系统可以正常yum/apt-get install相关软件包，需要提前配置系统相关软件源 确定系统已禁用NetworkManager或者配置NetworkManager 节点资源：推荐要求4核,8G,100GB(2核4G40GB), 默认情况下节点会给系统预留1.5核CPU1.5G内存的资源 在线安装确定网络没有限制，如有请加如下域名添加到白名单 repo.goodrain.com, api.goodrain.com, hub.goodrain.com, docker.io, domain.grapps.cn, aliyun.com,aliyuncs.com  网络要求 管理员可根据实际环境中部署Rainbond的方案，自行开放相关端口\n管理节点和计算节点之间网络无限制 对外访问需要放行\n管理节点 6060,7070 网关节点 80,443,8443,20000-30000(tcp应用端口)  默认情况下网关节点和管理节点复用;更多端口使用请阅读[组件端口](/user-operations/op-guide/required_ports/)  客户端 Web 浏览器要求 建议用户采用高版本的Google Chrome访问\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/required_ports/",
	"title": "组件端口",
	"tags": [],
	"description": "",
	"content": "   Protocol Port Range Purpose Used By     TCP 53,8089 rbd-dns Self   TCP 80,443,6443,10254 rbd-gateway Self   TCP 2379\u0026frasl;23790,2380\u0026frasl;23800,4001\u0026frasl;40010 etcd server client API kube-apiserver, etcd,etcd-proxy   TCP 3228 rbd-chaos Self   TCP 3306 rbd-db Self   TCP 4999 rbd-ops-ui Self   TCP 5000 rbd-hub Self   TCP 6060,8443,8888 rbd-api Self   TCP 6100-6102,6666 node Self   TCP 6300-6301 rbd-mq Self   TCP 6362-6366 rbd-eventlog Self   TCP 6369 rbd-worker Self   TCP 6442,8181 Kubernetes API server All   TCP 7070 rbd-app-ui Self   TCP 7171 rbd-webcli Self   TCP 8081 rbd-repo Self   TCP 9999,3329 rbd-monitor Self   TCP 10250 Kubelet API Self, Control plane   TCP 10251 kube-scheduler Self   TCP 10252 kube-controller-manager Self    "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/reset_enterprise_password/",
	"title": "重置企业管理员密码",
	"tags": [],
	"description": "命令行快速重置企业管理员密码",
	"content": " 开源版本目前可通过如下命令修改企业管理员(默认是第一个注册用户)密码，后续会集成到grctl相关工具里.\n管理节点操作  数据库用户名和数据库密码(cat /opt/rainbond/rainbond-ansible/roles/rainvar/defaults/main.yml | grep \u0026quot;^db_\u0026quot;)\n docker run -it --rm --network host -e MYSQL_HOST=\u0026lt;数据库地址\u0026gt; -e MYSQL_PORT=3306 -e MYSQL_USER=\u0026lt;数据库用户名\u0026gt; -e MYSQL_PASS=\u0026lt;数据库密码\u0026gt; -e MYSQL_DB=console -e PASSWORD=\u0026lt;新密码\u0026gt; rainbond/tools:reset_password  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/op-repo/",
	"title": "rbd-repo指南",
	"tags": [],
	"description": "rbd-repo指南",
	"content": "  rbd-repo是基于artifactory-oss实现,rbd-repo源码参见goodrain/rbd-repo\n 更新自定义版本rbd-repo docker pull docker.bintray.io/jfrog/artifactory-oss docker tag docker.bintray.io/jfrog/artifactory-oss goodrain.me/rbd-repo docker push goodrain.me/rbd-repo node service stop rbd-repo  编辑/opt/rainbond/conf/base.yaml关于rbd-repo部分(先备份base.yaml文件)\n- name: rbd-repo endpoints: - name: REPO_ENDPOINTS protocol: port: 8081 health: name: rbd-repo model: http address: 127.0.0.1:8081/artifactory/ max_errors_num: 3 time_interval: 60 after: - docker type: simple pre_start: docker rm rbd-repo start: \u0026gt;- docker run --name rbd-repo --network host -v /grdata/services/artifactory-\u0026lt;随机id\u0026gt;:/var/opt/jfrog/artifactory -i goodrain.me/rbd-repo stop: docker stop rbd-repo restart_policy: always  目录权限配置\nchown 1030:1030 /grdata/services/artifactory-\u0026lt;随机id\u0026gt; -R  添加远程仓库    Repository Key Type URL     aliyun-central Maven http://maven.aliyun.com/nexus/content/groups/public/   central Maven http://repo1.maven.org/maven2/   jcenter Maven http://jcenter.bintray.com   lang-old Generic http://lang.d.goodrain.com   pkg_lang Generic http://buildpack.rainbond.com   spring Maven http://repo.spring.io/release/    添加Virtual仓库    Repository Key Type Included Repositories Selected Repositories     libs-release Maven 4 aliyun-central, central, jcenter, spring    启动rbd-repo node service update  验证rbd-repo是否可用 curl lang.goodrain.me/maven.goodrain.me可以正常列出目录  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/offline-package/",
	"title": "如何构建离线安装包",
	"tags": [],
	"description": "如何构建离线安装包",
	"content": " 构建离线软件包 install-repo\ngit clone https://github.com/goodrain/install-repo.git cd install-repo make build_offline  构建离线镜像包 参考 构建离线镜像\n构建离线安装包 默认rainbond-ansible项目的tgz压缩包\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/error_dialing_backend/",
	"title": "web进入容器报错",
	"tags": [],
	"description": "web进入容器提示Error from server",
	"content": " 报错信息 Error from server: error dialing backend: dial tcp: lookup 4c4c4544-0037-4d10-8057-b2c04f564c32 on 10.10.10.10:53: no such host  排查方式  管理节点dns解析发生改变 /etc/resolv.conf,应该是nameserver包含管理节点ip 管理节点能否ping 4c4c4544-0037-4d10-8057-b2c04f564c32 在确定上述都ok下,重启kube-apiserver  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/table_region_tenants_not_exist/",
	"title": "创建应用提示Table &#39;region.tenants&#39; doesn&#39;t exist",
	"tags": [],
	"description": "创建应用提示Table &#39;region.tenants&#39; doesn&#39;t exist",
	"content": " 错误信息如下:\nCallApiError: {\u0026quot;url\u0026quot;: \u0026quot;https://region.goodrain.me:8443/v2/resources/tenants\u0026quot;, \u0026quot;body\u0026quot;: {\u0026quot;msg\u0026quot;: \u0026quot;get resources error, Error 1146: Table 'region.tenants' doesn't exist\u0026quot;}, \u0026quot;httpcode\u0026quot;: 500, \u0026quot;method\u0026quot;: \u0026quot;POST\u0026quot;, \u0026quot;apitype\u0026quot;: \u0026quot;Not specified\u0026quot;}  排查方式  外部数据库类似.\n  检查数据库是否有相关表 docker exec rbd-db mysql -e \u0026quot;use region;show tables;\u0026quot; 重建数据库相关表\ndocker exec rbd-db mysql -e \u0026quot;drop database console;drop database region;\u0026quot; /opt/rainbond/.init/updatedb.sh prepare docker exec rbd-app-ui python /app/ui/manage.py migrate docker cp /opt/rainbond/.init/init.sql rbd-db:/root docker cp /opt/rainbond/.init/region_info.sql rbd-db:/root docker exec rbd-db mysql -e \u0026quot;use console;truncate table console_sys_config\u0026quot; docker exec rbd-db mysql -e \u0026quot;use console;source /root/init.sql;\u0026quot; docker exec rbd-db mysql -e \u0026quot;use console;source /root/region_info.sql;\u0026quot; systemctl restart rbd-api   "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/console_error/",
	"title": "控制台异常排查",
	"tags": [],
	"description": "控制台异常排查",
	"content": " 控制台[goodrain/rainbond-console](https://github.com/goodrain/rainbond-console/issues/new)反馈建议 控制台UI[goodrain/rainbond-ui](https://github.com/goodrain/rainbond-ui/issues/new)兼容性等问题反馈建议  控制台异常排查  首先需要确定是哪个接口报异常(通过浏览器DevTools来确定是哪个接口报异常了) 确定是rbd-app-ui服务有问题还是数据中心服务有问题(确定rbd-app-ui服务日志/opt/rainbond/logs/rbd-app-ui/goodrain.log) 如果数据中心无明显错误，请确定rbd-api是否有明显报错(使用journalctl/systemctl/docker logs来查看rbd-api的日志)  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/",
	"title": "使用手册",
	"tags": [],
	"description": "",
	"content": " 应用管理终端控制台功能及设计说明 本章节建议详细阅读，获取最全面的Rainbond功能设计思路、使用方式和应用场景\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/user-registration-login/",
	"title": "用户管理",
	"tags": [],
	"description": "",
	"content": " 用户管理 本章节将带你初步了解Rainbond用户管理机制和使用方式\n 用户、管理员注册  Rainbond 用户、管理员管理和注册文档说明\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/install/online_install/",
	"title": "快速部署",
	"tags": [],
	"description": "此方式适用于你想快速安装和试用Rainbond平台, 最少只需要单台裸系统机器即可安装完成。此方式为基础安装方式，后续安装方案都是在本方案基础上的扩展和延伸。",
	"content": " 一、操作系统准备和检查 1.1 检查操作系统，目前版本支持以下操作系统    系统 版本 说明     CentOS 7.3及以上 64位，推荐安装(7.4.1708)   Debian 9.6及以上 64位   Ubuntu 16.04 64位   中标麒麟 服务器版V7.4 64位    更多关于软硬件要求请参考 软件和硬件环境要求\n1.2 下载系统安装工具 wget https://pkg.rainbond.com/releases/common/v5.1/grctl chmod +x ./grctl  二、初始化数据中心 数据中心 是Rainbond资源集合的核心抽象。初始化数据中心操作需要在第一台服务器上执行安装命令。\n 初始化安装第一个节点(配置最低2核4G内存40G磁盘)  快速安装无需设置过多的参数，重点注意IP地址的设定。若当前机器存在多个内网IP地址时需要请务必指定内网IP地址(iip);\n 若当前机器同时具备内网和公网 IP地址时，务必指定公网IP地址(eip)，若无则无需指定;\n 如果想跳过系统配置检查，安装时指定--enable-check disable,如果配置过低可能会无法正常安装部署;\n 支持对接外部数据库; 更多参数说明请阅读节点初始化重要参数说明   # 建议使用root执行安装操作 ./grctl init --iip 内网ip --eip 公网ip  安装过程需要下载和处理大约2G的文件，需要一定时间，请耐心等待。若遇到无法解决的错误请于Rainbond社区留言。\n 安装完成后检查, 当所有服务和节点皆处于健康状态时平台即可正常使用。  # 集群整体状态 grctl cluster # 集群节点状态 grctl node list # 控制台访问地址 http://\u0026lt;节点IP地址\u0026gt;:7070  如果集群状态是不健康的，参考节点健康检测 文档解决故障。\n三、数据中心添加节点 上诉步骤完成默认将第一个节点安装成为第一个管理节点和第一个计算节点。\n若你需要增加你的集群计算资源池，可以快速扩容计算节点：\n 其中host/hostname可以根据排序顺序依次compute01-computeN,host/hostname不要重复。\n # 建议使用root执行安装操作 grctl node add --host computexx --iip 计算节点IP --root-pass root用户密码 --role compute --install 示例： grctl node add --host compute01 --iip 192.168.1.1 --root-pass 12345678 --role compute --install grctl node list # 确定节点处于健康状态上线节点 grctl node up \u0026lt;NodeID\u0026gt;  更多细节可以参考文档 节点扩容\n安装完成，开启Rainbond云端之旅\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/install/",
	"title": "部署集群",
	"tags": [],
	"description": "",
	"content": " Rainbond集群安装 部署前请务必先阅读软件和硬件环境要求文档,避免安装失败,请严格遵循相关配置要求。\n 快速部署  此方式适用于你想快速安装和试用Rainbond平台, 最少只需要单台裸系统机器即可安装完成。此方式为基础安装方式，后续安装方案都是在本方案基础上的扩展和延伸。\n 阿里云部署  此方式适用于你使用阿里云服务资源，此方式我们将使用阿里云 ECS\u0026#43;NAS\u0026#43;专有网络(弹性IP)等资源。\n 高可用部署  此方式将首先引导你进行相关资源的规划和准备，以完成高可用集群的快速安装。\n 基于已有Kubernetes集群部署  此方式适用于已安装Kubernetes集群的用户，此安装方式Rainbond将使用用户提供的Kubernetes集群。\n 离线部署  此方式适用于外网网络受到严格限制的用户，此版本目前仅支持CentOS 7.4.1708系统。\n 自定义部署方案  此方式适用于熟悉ansible使用的用户\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/install/install-base-alicloud/",
	"title": "阿里云部署",
	"tags": [],
	"description": "此方式适用于你使用阿里云服务资源，此方式我们将使用阿里云 ECS+NAS+专有网络(弹性IP)等资源。",
	"content": " 一、部署说明 通过阿里云相关产品快速部署Rainbond,主要使用阿里云ECS和NAS,弹性IP,NAT网关,负载均衡SLB可以选用。\n机器资源准备 我们在阿里云有大量生产实践经验，如下配置为推荐配置，建议参考\n 操作系统推荐,经过我们线上验证推荐\n    操作系统 版本     CentOS 7.4(推荐)   Debian 9.6   Ubuntu 16.04     单台服务器最低配置要求\n    服务器角色 CPU 内存     管理节点 4核 8G   计算节点 16核 64G     单台服务器磁盘配置\n 管理节点: / 100G /cache 50G-100G #源码构建cache /opt/rainbond/data 100G #etcd,数据库等相关数据持久化目录 (推荐使用SSD) /var/lib/docker 100G+ (至少100G起) 计算节点: / 100G /var/lib/docker 100G+ /var/lib/docker  磁盘推荐都使用SSD云盘\n安装前需要格式化云盘，将分别挂载到`/var/lib/docker`,`/opt/rainbond/data`(仅管理节点需要),并向fstab添加相关挂载信息，方便开机挂载  # /etc/fstab 管理节点 UUID=\u0026lt;uuid\u0026gt; /var/lib/docker ext4 defaults,noatime 0 0 UUID=\u0026lt;uuid\u0026gt; /opt/rainbond/data ext4 defaults,noatime 0 0 # /etc/fstab 计算节点 UUID=\u0026lt;uuid\u0026gt; /var/lib/docker ext4 defaults,noatime 0 0   NAS选型\n NAS默认选择 SSD性能型即可,满足Rainbond使用。也可以根据需求选用NASPlus等产品\n 网络选项\n 专有网络,确保管理节点和计算节点,NAS在同一地域,且所有节点可以互相通信.可以考虑使用NAT网关.\n 负载均衡SLB\n http,https应用推荐使用，即SLB对接后端管理节点80,443端口\n 安全方面限制\n 如果需要公网访问，安全组需要对外放行80,6060,7070端口，以及ssh端口,内部网络不限制。\n更多关于软硬件要求请参考 软件和硬件环境要求\n二、 部署流程 在阿里云同一个区域内开通ECS,NAS服务, 服务器内部网络未限制。\n创建ECS 参考ECS入门\n创建NAS 参考NAS\n2.1 节点规划 根据需求具体规划节点数目。\n管理节点：主要运行k8s组件和rainbond相关组件，推荐1或3节点，奇数节点；\n计算节点：主要运行应用节点，不作限制,在计算资源不足时可以方便扩容；\n网关节点：默认情况下是和管理节点复用，要求弹性ip需要绑定到网关节点所在机器，必要时可单独部署rbd-gateway服务。\n阿里云推荐使用NAS,经过我们大量的生产测试环境使用，挂载NAS需要使用v3版本，切勿使用v4版本，否则会存在文件锁问题。  要在 Linux 系统中将 NAS 的 NFS 文件系统挂载至 ECS 实例，您需要安装 NFS 客户端，目前所有节点都需要提前挂载好NAS。 操作步骤： ```bash # 登陆ECS实例 # 安装NFS客户端 ## CentOS系统 sudo yum install -y nfs-utils ## Debian/Ubuntu系统 sudo apt-get install -y nfs-common ## 创建NAS挂载点 mkdir /grdata ## 更新/etc/fstab示例,挂载点域名需要替换成在创建文件系统时自动生成的挂载点域名 vi /etc/fstab ## 添加以下配置信息，其中NAS挂载点地址在阿里云控制台获取 rainbond-test.cn-shanghai.nas.aliyuncs.com:/ /grdata nfs vers=3,nolock,noatime 0 0 ## 挂载 mount -a # 查看挂载信息 mount -l | grep grdata ``` -- 2.2 初始化数据中心 在第一个管理节点执行初始化数据中心命令\n# 建议使用root执行安装操作 wget https://pkg.rainbond.com/releases/common/v5.1/grctl chmod +x ./grctl ## 第一个节点管理节点和计算节点复用 ./grctl init --iip \u0026lt;内网ip\u0026gt; --eip \u0026lt;弹性ip/所在公网ip/slb ip\u0026gt; --role master,compute --storage nas --storage-args \u0026quot;goodrain-rainbond.cn-huhehaote.nas.aliyuncs.com:/ /grdata nfs vers=3,nolock,noatime 0 0\u0026quot; ## 第一个节点仅作为管理节点 ./grctl init --iip \u0026lt;内网ip\u0026gt; --eip \u0026lt;弹性ip/lb所在公网ip/slb ip\u0026gt; --role master --storage nas --storage-args \u0026quot;goodrain-rainbond.cn-huhehaote.nas.aliyuncs.com:/ /grdata nfs vers=3,nolock,noatime 0 0\u0026quot;  2.3 添加节点 # 添加管理节点 grctl node add --host \u0026lt;managexx\u0026gt; --iip \u0026lt;管理节点内网ip\u0026gt; -p \u0026lt;root密码\u0026gt; --role master ## 法2默认已经配置ssh信任登陆 grctl node add --host \u0026lt;managexx\u0026gt; --iip \u0026lt;管理节点内网ip\u0026gt; --key /root/.ssh/id_rsa.pub --role master # 添加计算节点 grctl node add --host \u0026lt;computexx\u0026gt; --iip \u0026lt;计算节点内网ip\u0026gt; -p \u0026lt;root密码\u0026gt; --role compute ## 法2默认已经配置ssh信任登陆 grctl node add --host \u0026lt;computexx\u0026gt; --iip \u0026lt;计算节点内网ip\u0026gt; --key /root/.ssh/id_rsa.pub --role compute # 安装节点，节点uid可以通过grctl node list获取 grctl node install \u0026lt;新增节点uid\u0026gt; # 确定计算节点处于非unhealth状态下，可以上线节点 grctl node up \u0026lt;新增节点uid\u0026gt;  节点安装日志在/grdata/downloads/log/目录下\n2.4 确定集群状态 安装完成后，在当前节点执行：\ngrctl cluster  如果有节点处于unhealth,通过grctl node get \u0026lt;unhealth节点uid\u0026gt;确定哪个服务异常，来排查哪个服务异常。\n2.5 阿里云slb配置(可选)  如果指定eip为slb的ip时:  slb健康检查配置如下,其他默认即可\n- 检查端口为：10254 - 检查路径为：/healthz - 健康状态返回码: http_2xx  目前阿里云slb负载均衡仅支持单一端口，故tcp/udp协议应用使用负载均衡操作比较麻烦。tcp协议应用不推荐使用slb，可以通过修改rbd-db的console.region_info表的tcpdomain值为rbd-gateway所在节点的公网ip或者其他自建负载均衡的ip地址。\n 如果指定eip为gateway所在节点公网ip或者其他自建负载均衡的ip地址  slb健康检查配置如下,其他默认即可\n- 检查端口为：10254 - 检查路径为：/healthz - 健康状态返回码: http_2xx  需要调整域名解析,将默认域名解析由eip改为slb的ip，grctl domain --ip \u0026lt;slb的ip\u0026gt;\n安装完成，开启Rainbond云端之旅\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/install/install-base-ha/",
	"title": "高可用部署",
	"tags": [],
	"description": "此方式将首先引导你进行相关资源的规划和准备，以完成高可用集群的快速安装。",
	"content": " 一、集群高可用说明 在生产环境下，可以调整Rainbond的部署结构，来提高其高可用性。Rainbond高可用性可以从以下几个层面提升：\n 存储高可用：选择合适的分布式存储系统作为集群的共享存储。\n 网络高可用：为集群选择合适的SDN网络。\n 管理节点集群： 部署多个管理节点，实现Rainbond管理功能高可用。\n 计算节点集群： 分布式部署多个计算节点，实现计算资源高可用。\n 网关节点集群： 部署多个网关节点，提供多个应用访问入口。\n  二、机器资源准备 2.1 机器资源要求与规划  操作系统要求\n    操作系统 版本     CentOS 7.4.1708(建议安装此版本)     单台服务器计算资源配置要求\n    服务器角色 CPU 内存     管理节点 16核 32G   计算节点 16核 64G   网络节点 8核 16G   存储节点 4核 8G   网关节点 4核 8G     管理节点磁盘分区\n    挂载点 磁盘大小 说明     / 100G 系统根分区，本地磁盘，最低要求40G，推荐100G   /var/lib/docker 100G docker镜像存储分区，本地磁盘   /opt/rainbond 50G 存储rainbond程序以及产生的日志、数据，本地磁盘   /cache 50G 存储应用构建使用的缓存，可以使用共享存储在管理节点间共享     计算节点磁盘分区\n    挂载点 磁盘大小 说明     / 100G 系统根分区，本地磁盘，最低要求40G，推荐100G   /var/lib/docker 100G docker镜像存储分区，本地磁盘   /grlocaldata 100G 应用本地持久化存储，本地磁盘     存储节点磁盘分区\n    挂载点 磁盘大小 说明     / 40G 系统根分区，本地磁盘   /data 500G+ 用于搭建集群共享存储，本地单独挂载磁盘     网络节点网络配置\n 如对于应用网络有较高要求，请对应提高网络节点网络配置：提高带宽并升级网卡。\n2.2 节点规划 根据用户具体要求，可以参见本节规划集群的节点配置。\n 管理节点：  管理节点为常规部署项，必然存在于集群之中。部署数量从1开始，按奇数递增（即可以部署 1、3、5···台），推荐3台。\n 计算节点：  计算节点为常规部署项，必然存在于集群之中。部署数量2至100台，并在集群资源不足时按需扩容。\n 存储节点：  特指在选择glusterfs作为集群共享存储解决方案时部署的存储节点。部署数量至少2台，并根据节点数量选择复制集数量。\n 网关节点：  网关节点特指具备Rainbond应用访问负载均衡组件rbd-gateway的节点，为常规部署项，必然存在于集群之中。默认部署于所有的管理节点，可以根据需要单独部署。部署数量参照管理节点，并配置VIP保证高可用。\n更多关于软硬件要求请参考 软件和硬件环境要求\n三、存储节点选择 准备存储是安装高可用集群的第一步。在这一步将解决集群共享目录 /grdata 的配置。\n3.1 支持的存储说明 Rainbond需要为管理节点与计算节点的 /grdata 目录配置共享存储。\n Rainbond支持多种共享存储解决方案，请根据如下场景进行选择：\n  NAS：  基于阿里云等IaaS设施部署Rainbond的情况下，可以选择其提供的NAS存储服务。\n GlusterFS：  基于用户自备的服务器或虚拟机部署Rainbond的情况下，推荐部署GlusterFS作为共享存储解决方案。\n 其它兼容NFS协议的共享存储  如果用户拥有可使用的兼容NFS协议的共享存储，可以直接使用。使 /grdata 目录在集群管理节点与计算节点间共享即可。\n3.2 存储节点部署方案  推荐节点先行部署或对接存储节点，确定所有节点都已经正常挂载/grdata\n GlusterFS 部署GlusterFS存储节点，请参见 GlusterFS双机复制集群安装\nNAS 对接阿里云文件存储NAS，请参见对接文件存储NAS\n四、网络方案选择 支持的网络方案 当前版本Rainbond支持三种网络类型，开源版本默认为 calico 可选项为 flannel 。需要在数据中心初始化时(执行 grctl init)，通过 --network 参数指定。 下面简单对比两种解决方案的优缺点： * calico 优点：通过网络路由实现容器间通信，性能损耗较小。 缺点： 对宿主机网络要求较高，且只能支持 TCP,UDP和ICMP协议，其他特殊通信协议不支持，此方案适用于网络拓扑简单的中小规模集群，不适用于大型集群。 * flannel flannel常用两种工作模式，hostgateway 和 overlay,使用hostgateway模式工作原理与calico类似但是其没有实现calico基于BGP协议共享路由的机制，限制性更大。overlay模式对于用户来说比较简单，但是其通过打包、解包过程，性能损耗较大。 该方案目前适用于需要安装Windows节点的集群和机器网络较为复杂的集群。\n如果你选择flannel网络，你在安装Rainbond时需要指定如下参数:\ngrctl init --network flannel 其他参数   Rainbond默认推荐使用calico网络\n 五、数据中心初始化 5.1 命令 这一步将初始化Rainbond数据中心，即安装首个管理节点。这一步非常重要，会配置访问应用所使用的IP、集群网络解决方案等信息。\n 更多初始化参数，请阅读节点初始化重要参数说明\n # 建议使用root执行安装操作 wget https://pkg.rainbond.com/releases/common/v5.1/grctl chmod +x ./grctl ./grctl init --role master --iip \u0026lt;内网ip\u0026gt; --eip \u0026lt;访问应用使用的公网IP/网关节点IP\u0026gt;  5.2 手动校验 安装完成后，在当前节点执行：\ngrctl cluster  若返回集群信息正常，则进行下一步；若返回不正常，请重新审查本节操作。\n 扩容前，请检查是否配置了共享存储，如果是，请先行挂载 /grdata\n 六、管理节点扩容 管理节点的扩容，实现了集群管理功能的高可用。考虑到 etcd 集群选举机制，应至少扩容到3个管理节点。\n6.1 扩容命令 按下列场景选择扩容命令\n 未做ssh免密操作时，需要知悉节点root密码  grctl node add --host manage02 --iip \u0026lt;管理节点ip\u0026gt; -p \u0026lt;root密码\u0026gt; --role manage --install   配置好ssh免密后  grctl node add --host manage03 --iip \u0026lt;管理节点ip\u0026gt; --key /root/.ssh/id_rsa.pub --role manage --install   更多扩容参数，请执行 grctl node add -h 获取\n 6.2 手动校验 安装完成后，在当前节点执行：\ngrctl cluster  若返回集群列表中显示出扩容节点且服务状态正常，则进行下一步；若返回不正常，请重新审查本节操作。\n七、网关节点扩容 如无特殊设置，网关节点将默认安装在所有的管理节点，故而会随管理节点同步扩容。扩容完成后，需要配置VIP实现高可用。\n VIP要保证和当前机器ip在同一网段内。\n 7.1 vip配置 借助 keepalived 完成VIP配置\n 安装  yum install -y keepalived\n 编辑配置文件  ##备份原有配置文件 cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak ##编辑配置文件如下 ##manage01 ! Configuration File for keepalived global_defs { router_id LVS_DEVEL } vrrp_instance VI_1 { #角色，当前为主节点 state MASTER #网卡设备名，通过 ifconfig 命令确定 interface ens6f0 virtual_router_id 51 #优先级，主节点大于备节点 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { \u0026lt;VIP\u0026gt; } } ##其他管理节点 ! Configuration File for keepalived global_defs { router_id LVS_DEVEL } vrrp_instance VI_1 { #角色，当前为备节点 state BACKUP #网卡设备名，通过 ifconfig 命令确定 interface ens6f0 virtual_router_id 51 #优先级，主节点大于备节点 priority 50 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { \u0026lt;VIP\u0026gt; } }   启动服务  启动服务，设置开机自启动\nsystemctl start keepalived systemctl enable keepalived   其他需要调整的配置  在第一个管理节点执行\ndin rbd-db mysql use console; UPDATE region_info set tcpdomain=\u0026quot;\u0026lt;VIP\u0026gt;\u0026quot;;  调整所有节点rbd-dns关于goodrain.me的解析(100.100.100.16为示例VIP,根据实际情况调整)\n# 编辑/opt/rainbond/conf/dns.yaml,将recoders修改为vip地址 --recoders=goodrain.me=100.100.100.16,*.goodrain.me=100.100.100.16 # 更新服务 node service update # 编辑 /etc/hosts 100.100.100.16 kubeapi.goodrain.me goodrain.me repo.goodrain.me lang.goodrain.me maven.goodrain.me region.goodrain.me  7.2 手动校验 在主节点执行如下命令：\nsystemctl stop keepalived ip a  如果在关闭服务后，vip成功在某一台备用节点上启动，则进入下一步；如果vip没有成功漂移，请重新审查本节操作。\n八、计算节点扩容  扩容前，请检查是否配置了共享存储，如果是，请先行挂载 /grdata\n 8.1 扩容命令 按下列场景选择扩容命令\n 未做ssh免密操作时，需要知悉节点root密码  grctl node add --host compute01 --iip \u0026lt;计算节点ip\u0026gt; -p \u0026lt;root密码\u0026gt; --role compute --install   配置好ssh免密后  grctl node add --host compute01 --iip \u0026lt;计算节点ip\u0026gt; --key /root/.ssh/id_rsa.pub --role compute --install  8.2 手动校验 安装完成后，在当前节点执行：\ngrctl cluster  若返回集群列表中显示扩容节点且状态正常，则表示扩容成功；若返回不正常，请重新审查本节操作。\n安装完成，开启Rainbond云端之旅\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/install/install-base-kubernetes/",
	"title": "基于已有Kubernetes集群部署",
	"tags": [],
	"description": "此方式适用于已安装Kubernetes集群的用户，此安装方式Rainbond将使用用户提供的Kubernetes集群。",
	"content": " Rainbond与Kubernetes集群的关系 Kubernetes是Rainbond调度和运行应用的基础平台，5.0版本开始Rainbond与Kubernetes进行了完全的解耦合以支持更多的Kubernetes版本。\nKubernetes集群要求  Kubernetes版本必须 \u0026gt;=1.10 Kubernetes集群必须正常工作 Kube-APIServer 开启了RBAC,支持ServiceAccount、NamespaceLifecycle、LimitRanger  Rainbond将对Kubernetes集群做的修改  创建多个Namespace（每个租户创建一个Namespace） 创建名为rainbondsssc 和 rainbondslsc 的StorageClass 应用创建后创建在所在租户空间内创建各类资源  由Rainbond创建的资源都携带Creater=Rainbond 标签，由Rainbond自动管理，你在未完全了解Rainbond工作机制的情况下请勿自行操作Kubernetes资源。  安装Rainbond 1. 准备Rainbond需要的Kubernetes的相关文件  当前节点路径下有/usr/bin/kubectl文件\nadmin.kubeconfig,Kube-Apiserver admin用户权限的配置文件\nkube-proxy.kubeconfig,用于Slave节点Kube-Proxy的配置文件,一般用户名为kube-proxy\n 需要将这个文件拷贝到/opt/rainbond/etc/kubernetes/kubecfg目录下\n# 查看是否复制成功 ls /opt/rainbond/etc/kubernetes/kubecfg admin.kubeconfig kube-proxy.kubeconfig   通过kubeadm安装的k8s集群相关文件获取方式\n  admin.kubeconfig文件，在master节点获取/etc/kubernetes/admin.conf或者$HOME/.kube/config\nkube-proxy.kubeconfig文件，示例如下\n # kube-proxy.kubeconfig apiVersion: v1 kind: Config clusters: - cluster: certificate-authority: \u0026lt;base64 ca.crt证书内容\u0026gt; server: \u0026lt;kube api https地址\u0026gt; name: default contexts: - context: cluster: default namespace: default user: default name: default current-context: default users: - name: default user: token: \u0026lt;token\u0026gt; # ca.crt 文件：/etc/kubernetes/pki/ca.crt # token 获取方式 kubectl -n kube-system get secret | grep kube-proxy | awk '{print \u0026quot;secret/\u0026quot;$1}' | xargs kubectl describe -n kube-system | grep token: | awk -F: '{print $2}' | xargs echo   其他途径安装部署的k8s集群配置文件获取  根据具体情况，自行生成相关文件，具体可以参考 创建 kubeconfig 文件一文。\n2. 调整集群节点的Docker配置(可选)  信任goodrain.me镜像仓库，推荐配置Insecure Registries，确定配置是否生效docker info查看Insecure Registries是否包含goodrain.me\n 配置日志驱动设置\nRainbond将实时通过Docker Daemon 获取容器日志，需要Docker配置为json-file驱动。若你已采用其他驱动，Rainbond可能无法正常获取服务日志。\n  参考daemon.json配置文件\n # /etc/docker/daemon.json { \u0026quot;insecure-registries\u0026quot;: [\u0026quot;goodrain.me\u0026quot;], \u0026quot;max-concurrent-downloads\u0026quot;: 10, \u0026quot;log-level\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;log-driver\u0026quot;: \u0026quot;json-file\u0026quot;, \u0026quot;log-opts\u0026quot;: { \u0026quot;max-size\u0026quot;: \u0026quot;20m\u0026quot;, \u0026quot;max-file\u0026quot;: \u0026quot;2\u0026quot; } }  3. 初始化Rainbond数据中心 在k8s管理节点执行安装，进行初始化Rainbond数据中心,安装Rainbond管理节点服务,如果有外网ip，则需要指定外网ip\nwget https://pkg.rainbond.com/releases/common/v5.1/grctl chmod +x ./grctl ./grctl init --iip \u0026lt;必须指定内网ip\u0026gt; --eip \u0026lt;可选外网ip\u0026gt; --deploy-type thirdparty  4. 将已有k8s节点纳入rainbond管理 下述安装操作前请务必执行信任goodrain.me镜像仓库步骤，否则会影响安装\n# worker节点NAME，通过如下命令获取 kubectl get node -o wide # 添加已有k8s worker计算节点 grctl node add --host \u0026lt;worker节点hostname\u0026gt; --iip \u0026lt;worker内网ip\u0026gt; --key /root/.ssh/id_rsa.pub --role compute --id \u0026lt;worker节点NAME\u0026gt; grctl node install \u0026lt;worker节点NAME\u0026gt; # 添加已有k8s master管理节点 grctl node add --host \u0026lt;master节点hostname\u0026gt; --iip \u0026lt;worker内网ip\u0026gt; --key /root/.ssh/id_rsa.pub --role manage --id \u0026lt;master节点NAME\u0026gt; grctl node install \u0026lt;master节点NAME\u0026gt;  示例\nroot@iZj6caqbup3uo1me2vt0qqZ:~# kubectl get node -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME izj6caqbup3uo1me2vt0qrz Ready \u0026lt;none\u0026gt; 117m v1.13.1 10.10.10.230 \u0026lt;none\u0026gt; Debian GNU/Linux 9 (stretch) 4.9.0-8-amd64 docker://17.3.3 grctl node add --host izj6caqbup3uo1me2vt0qrz --iip 10.10.10.230 --key /root/.ssh/id_rsa.pub --role compute --id izj6caqbup3uo1me2vt0qrz grctl node install izj6caqbup3uo1me2vt0qrz  5. 其他说明 默认情况下，rainbond默认会将节点纳入到管理中，可手动关闭当前节点自动禁止调度功能。\n# 修改 /opt/rainbond/scripts/start-node.sh 调整auto-scheduler为false即可禁用 systemctl restart node  安装完成，开启Rainbond云端之旅\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/install/offline_install/",
	"title": "离线部署",
	"tags": [],
	"description": "此方式适用于外网网络受到严格限制的用户，此版本目前仅支持CentOS 7.4.1708系统。",
	"content": " 目前我们仅提供CentOS 7.4.1708版本的离线包，其他版本离线包制作请参考[离线包制作文档](/user-operations/op-guide/offline-package/)  软硬件要求  检查操作系统，目前离线版本仅支持CentOS 7.4.1708版本 确保机器重启，服务器IP地址和nameserver不发生改变，推荐配置静态ip 多节点部署时，需要确保所有机器间时间要同步(很重要) 多节点时，机器间网络访问没有限制 支持使用root执行安装操作  更多关于软硬件要求请参考 软件和硬件环境要求,安装前请务必确定是否满足条件。\n同步离线包 # 有网环境下载离线包并同步到离线环境 wget https://pkg.rainbond.com/offline/dev/offline.2019-05-20-5.1.4.tgz  离线安装操作 准备工作 # 需要移除默认源 mv /etc/yum.repos.d/*.repo /tmp/ # 解压离线包 tar xf \u0026lt;离线包\u0026gt; # 进入解压目录下 cd offline # 执行准备工作 ./offline.sh # 安装前检查工作 yum makecache # 确定上述文件都存在后执行后续安装操作  初始化数据中心 离线情况下，初始化数据中心必须指定参数要求： 必须指定install-type为offline 可选参数要求： 1. 如果是多网卡情况下，需要指定iip 2. 离线情况下，默认使用`pass.grapps.cn`域名，需要自行指定离线域名，并需要配置相关解析工作如`*.pass.grapps.cn`解析到数据中心节点 3. role身份,赋予当前节点身份属性,默认为管理和计算节点复用;若role指定为manage，则表示当前节点仅具有管理节点属性  # 当前节点仅具有管理属性 ./grctl init --install-type offline --iip \u0026lt;当前机器内网ip\u0026gt; --domain \u0026lt;自定义域名\u0026gt; [--role manage]   安装完成后检查, 当所有服务和节点皆处于健康状态时平台即可正常使用。  # 集群整体状态 grctl cluster # 集群节点状态 grctl node list # 控制台访问地址 http://\u0026lt;节点IP地址\u0026gt;:7070  如果集群状态是不健康的，参考节点健康检测 文档解决故障。\n添加节点 # 添加计算节点,请不用使用offline目录下的grctl执行相关节点添加删除操作 ## 法一 密码 grctl node add --host \u0026lt;计算节点主机名\u0026gt; --iip \u0026lt;计算节点内网ip\u0026gt; --root-pass \u0026lt;计算节点root密码\u0026gt; --role compute ## 法二 key grctl node add --host \u0026lt;计算节点主机名\u0026gt; --iip \u0026lt;计算节点内网ip\u0026gt; --key /root/.ssh/id_rsa.pub --role compute # 安装计算节点 grctl node install \u0026lt;新添加计算节点的Uid\u0026gt; # 确定计算节点ok后，上线节点 当节点处于offline(unschedulable)状态后可以up grctl node up \u0026lt;新添加计算节点的Uid\u0026gt;  更多细节可以参考文档 运维手册, 节点扩容\n安装完成，开启Rainbond云端之旅\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/install/custom-install/",
	"title": "自定义部署方案",
	"tags": [],
	"description": "此方式适用于熟悉ansible使用的用户",
	"content": " 如何自定义安装部署方案  step 1: fork rainbond-ansible项目 step 2: 通过修改fork后的rainbond-ansible项目来自定义自己的需求 step 3: 安装时指定rainbond-version(分支名或tag),rainbond-repo(rainbond-ansible fork项目路径)  简析rainbond-ansible结构 |-- addmaster.yml # 添加管理节点ansible-playbook |-- addnode.yml # 添加计算节点ansible-playbook |-- ansible.cfg |-- callback_plugins |-- inventory | |-- hosts |-- log |-- roles | |-- bootstrap # 系统配置 | |-- db # 数据库rbd-db | |-- docker # 安装docker | |-- etcd # 管理节点配置etcd | |-- etcd-proxy # 计算节点配置etcd-proxy | |-- health # 服务health检查配置 | |-- image # 下载离线镜像包 \u0026amp; 解压镜像包 \u0026amp; 加载镜像 | |-- kube-master # k8s管理节点 | |-- kube-worker # k8s计算节点 | |-- lb # 网关服务rbd-gateway | |-- master # Rainbond核心组件配置 | |-- network_plugin # 集群网络插件calico等 | |-- node # node服务配置 | |-- nodeinit # 初始化数据中心，仅在第一个节点执行 | |-- nodeup # 上线节点, 仅在第一个节点执行 | |-- prepare # 准备工作 | |-- rainvar # 全局配置(setup.sh会根据global.sh或default.sh来调整rainvar配置) | |-- storage # 存储 | |-- thirdparty # 对接已有k8s集群 | `-- upgrade # 升级 |-- scripts | |-- installer | | |-- default.sh # 全局默认配置参数，仅setup.sh调用,优先级低于global.sh | | |-- functions.sh # 基本函数, 仅setup.sh调用 | | |-- global.sh # grctl init时生成,是参数配置，仅setup.sh调用 | | `-- global.sh.example # 手动安装时global.sh示例 | |-- node.sh # 添加节点脚本目录 | `-- upgrade # 升级脚本目录 |-- setup.sh # 初始化第一个节点prepare脚本 |-- setup.yml # 初始化第一个节点ansible-playbook |-- upgrade.yml # 升级节点ansible-playbook `-- version  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/management/",
	"title": "管理集群",
	"tags": [],
	"description": "",
	"content": " 管理集群 管理和运维Rainbond集群的知识和经验,主要涉及节点组件的管理配置相关.   节点管理(添加,删除,重置)  节点管理:添加节点,删除节点,重置节点\n Rainbond组件运维  节点组件配置说明及组件健康检查说明\n 应用域名运维  应用域名运维\n 自定义节点Pod CIDR  自定义节点Pod CIDR\n 扩容网关节点  添加网关节点或者迁移网关节点\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/management/node/",
	"title": "节点管理(添加,删除,重置)",
	"tags": [],
	"description": "节点管理:添加节点,删除节点,重置节点",
	"content": " 添加节点 1. 安装节点时，请勿使用之前wget下载的grctl工具即(./grctl)，直接使用grctl命令。 2. 管理节点不支持批量扩容操作，只能依次扩容。 3. 管理节点数目推荐为奇数1,3,5,7，两个节点无法保证高可用。 4. 支持使用root执行安装操作  # 添加管理节点 grctl node add --host \u0026lt;managexx\u0026gt; --iip \u0026lt;管理节点内网ip\u0026gt; -p \u0026lt;root密码\u0026gt; --role manage ## 法2默认已经配置ssh信任登陆 grctl node add --host \u0026lt;managexx\u0026gt; --iip \u0026lt;管理节点内网ip\u0026gt; --key /root/.ssh/id_rsa.pub --role manage # 添加计算节点 grctl node add --host \u0026lt;gatewayxx\u0026gt; --iip \u0026lt;网关节点内网ip\u0026gt; -p \u0026lt;root密码\u0026gt; --role gateway ## 法2默认已经配置ssh信任登陆 grctl node add --host \u0026lt;gatewayxx\u0026gt; --iip \u0026lt;网关节点内网ip\u0026gt; --key /root/.ssh/id_rsa.pub --role gateway # 添加计算节点 grctl node add --host \u0026lt;computexx\u0026gt; --iip \u0026lt;计算节点内网ip\u0026gt; -p \u0026lt;root密码\u0026gt; --role compute ## 法2默认已经配置ssh信任登陆 grctl node add --host \u0026lt;computexx\u0026gt; --iip \u0026lt;计算节点内网ip\u0026gt; --key /root/.ssh/id_rsa.pub --role compute # 安装节点，节点uid可以通过grctl node list获取 grctl node install \u0026lt;新增节点uid\u0026gt; # 确定计算节点处于health状态 grctl node up \u0026lt;新增节点uid\u0026gt;  删除计算节点   当前支持删除计算节点，仅仅将计算节点从集群中移除,不会停计算节点上运行的服务\ngrctl node down \u0026lt;被删除计算节点UUID\u0026gt; grctl node delete \u0026lt;被删除计算节点UUID\u0026gt;    重置计算节点(需要先从集群中删除)\n# 慎重操作，默认会删除数据 ssh \u0026lt;被删除计算节点\u0026gt; grctl reset    删除管理节点 多管理节点时，需要注意etcd服务.\n 先从etcd集群中移除需要删除的etcdctl member remove \u0026lt;member id\u0026gt; 停管理节点服务 grclis stop 卸载/grdata存储 umount /grdata 重置节点 grctl reset 如果多管理节点时需要手动清理etcd中已删除管理节点的数据 ETCDCTL_API=3 etcdctl get /rainbond/endpoint --prefix,具体可以参考删除冗余数据  如果单管理节点，多计算节点时，请勿操作否则会导致计算节点不可用  重置节点 当重置为计算节点时需要注意请勿删除grdata目录下数据  重置计算节点 systemctl stop node systemctl disable node systemctl stop kubelet systemctl disable kubelet dps | grep goodrain.me | grep -v 'k8s' | awk '{print $NF}' | xargs -I {} systemctl disable {} dps | grep goodrain.me | grep -v 'k8s' | awk '{print $NF}' | xargs -I {} systemctl stop {} cclear rm -rf /root/.kube/config rm -rf /root/.rbd/grctl.yaml rm -rf /tmp/* rm -rf /usr/local/bin/grctl rm -rf /usr/local/bin/node # 删除镜像 docker images -q | xargs docker rmi -f  重置管理节点 systemctl stop node systemctl disable node systemctl stop kubelet systemctl disable kubelet grclis stop dps | grep goodrain.me | grep -v 'k8s' | awk '{print $NF}' | xargs -I {} systemctl disable {} dps | grep goodrain.me | grep -v 'k8s' | awk '{print $NF}' | xargs -I {} systemctl stop {} cclear rm -rf /root/.kube/config rm -rf /root/.rbd/grctl.yaml rm -rf /tmp/* rm -rf /usr/local/bin/grctl rm -rf /usr/local/bin/node rm -rf /opt/rainbond rm -rf /grdata rm -rf /grlocaldata  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/management/component-op/",
	"title": "Rainbond组件运维",
	"tags": [],
	"description": "节点组件配置说明及组件健康检查说明",
	"content": " 目前Rainbond绝大多数组件都是由node维护，即由node生成服务的配置文件并启动。目前所有关于rainbond服务(除node外)的配置文件目录：/opt/rainbond/conf\n服务配置说明    配置文件 节点类型 具体组件 说明     base.yaml 管理节点* rbd-repo,rbd-hub 基础服务组件   db.yaml 管理节点 rbd-db 数据库组件   dns.yaml 管理节点/计算节点 rbd-dns dns组件   etcd.yaml 管理节点* etcd etcd组件   etcd-proxy.yaml 计算节点* etcd-proxy etcd-proxy组件   health.yaml 管理节点/计算节点  系统健康检查组件，如存储等   k8s-master.yaml 管理节点* kube-controller-manager,kube-scheduler,kube-apiserver k8s master组件   k8s-worker.yaml 计算节点*/复用的管理节点(仅第一个管理节点) kubelet k8s worker组件   master.yaml 管理节点*  Rainbond管理节点组件   network.yaml 管理节点/计算节点 calico/flannel 网络组件   only_health.yaml 管理节点/计算节点  docker/nfs server health检查组件   ui.yaml 管理节点* rbd-app-ui 控制台组件    调整服务配置 需要调整组件配置，只需修改组件对应的/opt/rainbond/conf/目录下的yaml文件即可。修改完成后只需执行node service update动态更新服务配置。\n# 停某服务 node service stop \u0026lt;服务名\u0026gt; # 更新并启动某服务 node service update \u0026lt;服务名\u0026gt; # 更新并启动所有服务配置 node service update  服务日志查看 默认所有服务组件都可以使用journalctl或systemctl命令来查看服务日志或者服务状态。\n另外除node和kubelet服务外，其他服务还可以使用docker logs命令来查看服务日志。\nrbd-app-ui的日志默认是写到文件，可以在`/opt/rainbond/logs`目录下看到相关日志信息。  节点健康检查机制 所有类型节点将由Node服务进行不间断的健康检查。节点是否健康取决于节点的物理状态、资源状态和服务状态等综合因素。Rainbond支持通过HTTP协议、TCP、UDP协议、SHELL命令三种策略定义检查项目。\n若某项检查项目标识为不健康状态，当前节点将被标识为不健康状态。\n对于不健康的节点Rainbond提供两级自动处理机制：\n 检测到异常的服务一段时间依然未恢复（取决于配置的时间段）将自动重启服务。 若计算节点被标注为不健康，节点控制器将会自动将其禁止应用调度直到节点恢复健康。  默认的节点检查项目    节点类型 检查项目 检查方式     管理节点 rbd-registry HTTP   管理节点 rbd-repo HTTP   管理节点 rbd-db TCP   管理节点, 计算节点 rbd-dns TCP   管理节点 etcd TCP   计算节点 etcd-proxy TCP   管理节点, 计算节点 docker CMD   管理节点, 计算节点 storage CMD   管理节点, 计算节点 local-dns CMD   管理节点 kube-apiserver HTTP   管理节点 kube-scheduler TCP   管理节点 kube-controller-manager TCP   管理节点, 计算节点 kubelet TCP   管理节点 rbd-gateway HTTP   管理节点 rbd-api HTTP   管理节点 rbd-chaos HTTP   管理节点 rbd-mq HTTP   管理节点 rbd-webcli HTTP   管理节点 rbd-worker HTTP   管理节点 rbd-monitor HTTP   管理节点 rbd-eventlog HTTP   管理节点, 计算节点 calico CMD   管理节点 rbd-app-ui HTTP    确定节点状态是否健康 # 在管理节点执行如下命令,观察节点状态，如果节点处于unhealth,说明节点不健康 grctl node list # 查看不健康节点哪些服务异常 grctl node get \u0026lt;unhealth节点的UID\u0026gt;  常见的异常错误处理方式 grctl cluster 或 grctl node list 报 500错误 此错误一般是由于node组件或api组件运行异常导致，查询node组件日志查询原因。\n# 查询node组件日志 journalctl -fu node # 查询api组件日志 journalctl -fu rbd-api  查询日志若不能自己解决问题，请到Rainbond社区发帖咨询。\n存储健康检测不通过 大部分情况下，存储健康检测不通过主要是存储同步有问题。\n 确定异常节点是否挂载了/grdata\n 确定存储是否同步\n 手动执行/opt/rainbond/health/storage.sh,看退出码是否为0\n 确定GlusterFS存储安装正确，且所有节点上存储服务可用  Rainbond组件异常 可以通过系统工具来查看服务状态,如\nsystemctl status rbd-worker journalctl -fu rbd-worker  Rainbond自己的组件如果有异常可以来排除是否是etcd服务或者rbd-db服务异常，然后手动重启相关服务 systemctl restart \u0026lt;相关服务\u0026gt;\nrepo组件异常 大部分情况下请确定主机名是否能反解ip即 主机名能否ping通。\n自定义检查项目 默认情况下，所有服务配置文件都在/opt/rainbond/conf/目录下\n示例自定义检查项\n主要配置就是health部分检查项,其他地方默认即可\n目前检测方式有3种\n cmd 使用脚本或者命令行 tcp 使用ip:port模式 http 使用http协议检测  version: '2.1' services: - name: docker health: name: docker model: cmd address: /opt/rainbond/health/check_docker.sh max_errors_num: 5 time_interval: 10 after: - network.target requires: - network.target only_health_check: true start: none restart_policy: always restart_sec: 10  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/management/domain/",
	"title": "应用域名运维",
	"tags": [],
	"description": "应用域名运维",
	"content": "  Rainbond平台上运行起来的应用，如果需要外部访问，都需要一个域名与之对应。这个域名是应用的标示，同时也是平台负载均衡区分后端服务的方法。Rainbond在线安装未指定自定义域名时，默认会自动注册一个*.\u0026lt;random\u0026gt;.grapps.cn的泛域名并进行dns的解析工作\n 自定义域名 离线安装环境，如果未指定自定义域名，默认域名为pass.example.com或者pass.grapps.cn\n安装完成后修改自定义域名 需要编辑/opt/rainbond/conf/master.yaml文件中关于EX_DOMAIN的值,示例\nsed -i \u0026quot;s#\u0026lt;默认域名\u0026gt;#\u0026lt;自定义域名\u0026gt;#g\u0026quot; /opt/rainbond/conf/master.yaml  更新完成后需要更新服务\nnode service update  更新数据库相关值 docker exec rbd-db mysql -e 'use console;update region_info set httpdomain=\u0026quot;自定义域名\u0026quot;'  自定义域名需要泛解析到当前管理节点。如自定义域名(www.a.com),管理节点ip(1.1.1.1),需要在域名解析记录里添加如下A记录\n*.www.a.com A 1.1.1.1  调整已有域名解析  只支持默认分配的grapps.cn域名,示例将默认域名解析记录有内网改为外网\n domain-cli -newip \u0026lt;公网ip\u0026gt;/grctl domain --ip \u0026lt;公网ip\u0026gt; #两者都可以 # 更新成功后，稍等几分钟。如果没生效，请检查dns。 docker exec -it rbd-db mysql -e \u0026quot;update console.region_info set wsurl='ws://\u0026lt;公网ip\u0026gt;:6060',tcpdomain='\u0026lt;公网ip\u0026gt;';\u0026quot; # 特别说明一下：如果已经修改过域名解析，需要再次修改域名解析请使用domain-cli domain-cli -newip \u0026lt;newip\u0026gt; -oldip \u0026lt;oldip\u0026gt;  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/management/reset-pod-cidr/",
	"title": "自定义节点Pod CIDR",
	"tags": [],
	"description": "自定义节点Pod CIDR",
	"content": "  主要是针对calico网络而言\n 安装前自定义 grctl init --pod-cidr 192.168.0.0/16  如果不自定义的话,默认会根据宿主机ip段选择对应的pod的cidr. calico 宿主机(`192.168.0.0/16`)则pod的cidr为`10.0.0.0/16`,否则pod的cidr为`192.168.0.0/16` flannel 默认pod cidr为`10.244.0.0/16`  安装后自定义 这里以调整为 172.16.0.0/16为例，请注意，此调整将重启所有应用：\n 1. 调整所有节点的calico启动参数  vi /opt/rainbond/conf/network.yaml 将： -e CALICO_IPV4POOL_CIDR=192.168.0.0/16 更改为： -e CALICO_IPV4POOL_CIDR=172.16.0.0/16    调整所有节点的calico启动参数\nETCDCTL_API=3 etcdctl del /calico --prefix    重启calico服务\nnode service update    重启所有应用分配ip   "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/management/add-lb-node/",
	"title": "扩容网关节点",
	"tags": [],
	"description": "添加网关节点或者迁移网关节点",
	"content": " 5.1.4版本之后支持扩容网关节点(具体可参考节点管理部分),历史版本只能手动扩容添加网关节点  手动添加网关节点 1. 准备工作  生成node的systemd文件  cat \u0026gt; /etc/systemd/system/node.service \u0026lt;\u0026lt;EOF [Unit] Description=Goodrain Rainbond node After=network.target [Service] Type=simple User=root LimitCORE=infinity LimitNOFILE=102400 LimitNPROC=102400 EnvironmentFile=-/opt/rainbond/envs/node.sh PermissionsStartOnly=true ExecStart=/opt/rainbond/scripts/start-node.sh Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF   生成node启动脚本  cat \u0026gt; /opt/rainbond/scripts/start-node.sh \u0026lt;\u0026lt;EOF #!/bin/bash NODE_OPTS=\u0026quot;--log-level=info --auto-scheduler=true --kube-conf=/opt/rainbond/etc/kubernetes/kubecfg/admin.kubeconfig --etcd=http://\u0026lt;etcd地址\u0026gt; --hostIP=\u0026lt;新增网关节点ip\u0026gt; --run-mode master --noderule manage\u0026quot; exec /usr/local/bin/node $NODE_OPTS EOF   生成node的uuid  cat \u0026gt; /opt/rainbond/etc/node/node_host_uuid.conf \u0026lt;\u0026lt;EOF host_uuid=\u0026lt;node_uuid, 可以用uuidgen生成\u0026gt; EOF   从管理节点同步文件\n 从第一个管理节点同步/opt/rainbond/conf目录下的network.yaml,lb.yaml文件到新增网关节点同样目录下 从第一个管理节点同步/opt/rainbond/etc/kubernetes/kubecfg目录到新增网关节点同样目录下 从第一个管理节点同步/opt/rainbond/health目录到新增网关节点同样目录下 从第一个管理节点同步/opt/rainbond/etc/tools/bin/node到新增网关节点/usr/local/bin/node  编辑新增网关节点 /opt/rainbond/conf/network.yaml\n  IP为新增网关节点 NODENAME为新增网关节点node的uuid  如果计算节点复用情况下,仅需要copy lb.yaml到计算节点   安装docker并启动  # 安装docker export VERSION=18.06 \u0026amp;\u0026amp; curl -fsSL http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/releases/docker/install-docker.sh | bash -s docker cat \u0026gt; /etc/docker/daemon.json \u0026lt;\u0026lt;EOF { \u0026quot;insecure-registries\u0026quot;: [\u0026quot;goodrain.me\u0026quot;], \u0026quot;bip\u0026quot;: \u0026quot;172.30.42.1/16\u0026quot;, \u0026quot;userland-proxy\u0026quot;: false, \u0026quot;storage-driver\u0026quot;: \u0026quot;overlay2\u0026quot;, \u0026quot;max-concurrent-downloads\u0026quot;: 10, \u0026quot;log-driver\u0026quot;: \u0026quot;json-file\u0026quot;, \u0026quot;log-level\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;log-opts\u0026quot;: { \u0026quot;max-size\u0026quot;: \u0026quot;20m\u0026quot;, \u0026quot;max-file\u0026quot;: \u0026quot;2\u0026quot; } } EOF # 启动docker systemctl daemon-reload systemctl restart docker   更新dns或许更新hosts  编辑 /etc/resolv.conf,添加管理节点ip,支持goodrain.me等域名解析 编辑 /etc/hosts,添加域名解析\u0026lt;管理节点ip\u0026gt; kubeapi.goodrain.me goodrain.me repo.goodrain.me lang.goodrain.me maven.goodrain.me region.goodrain.me   2. 启动node systemctl enable node systemctl start node # node启动后根据/opt/rainbond/conf目录下配置文件生成对应服务systemd配置文件并启动  调整配置 有两种方案:\n 1. 对接外部负载均衡设备(如阿里云slb) 可以参考 阿里云slb配置-可选 2. 使用vip  阿里云slb目前仅支持http或者https应用负载均衡  更新配置  调整域名解析 将域名解析到vip或者是slb的ip\ngrctl domain --ip \u0026lt;vip/slb\u0026gt;  更新数据库信息\n# 仅vip方案 docker exec -it rbd-db mysql -e \u0026quot;update console.region_info set tcpdomain='\u0026lt;vip\u0026gt;';\u0026quot;   "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/monitor/",
	"title": "监控集群",
	"tags": [],
	"description": "",
	"content": " 集群监控报警 主要介绍的是Raibond监控报警体系中对节点监控，各服务组件监控及应用服务监控\n 监控  主机、服务、容器(应用异常)监控\n 监控报警配置项说明  基于Prometheus监控说明\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/storage/glusterfs/",
	"title": "对接GlusterFS",
	"tags": [],
	"description": "存储对接GlusterFS",
	"content": " 存储节点部署示例环境，仅供参考\n   主机名 IP 系统     gfs01 10.10.10.13 CentOS 7.4.1708   gfs02 10.10.10.14 CentOS 7.4.1708    一、GlusterFS的安装 1.1 存储节点配置hostname解析 所有节点都需要配置存储节点hostname解析\n# gfs01节点更新hostname hostname gfs01 echo \u0026quot;gfs01\u0026quot; \u0026gt; /etc/hostname # gfs02节点更新hostname hostname gfs02 echo \u0026quot;gfs02\u0026quot; \u0026gt; /etc/hostname # gfs01/gfs02配置hosts解析 [root@gfs01 ~]# cat /etc/hosts 10.10.10.13 gfs02 10.10.10.14 gfs01  配置完成后确定存储节点可以正常ping通gfs01和gfs02\n1.2 格式化磁盘、创建目录并挂载 # 查看可用磁盘 fdisk -l # 分区并格式化 mkfs.xfs /dev/vdb1 mkdir -p /data echo \u0026quot;/dev/vdb1 /data xfs defaults 1 2\u0026quot; \u0026gt;\u0026gt;/etc/fstab # 挂载 mount -a  gfs01和gfs02节点都需要执行如上操作。\n# 确定/data挂载 df -h | grep data  1.3 安装启动glusterfs服务 yum install centos-release-gluster -y yum install glusterfs-server -y systemctl start glusterd.service systemctl enable glusterd.service systemctl status glusterd.service  1.4 配置信任池 仅在其中1个节点执行操作即可\n[root@gfs01 ~]# gluster peer probe gfs02 peer probe: success.  在gfs02上验证\n[root@gfs02 ~]# gluster peer status Number of Peers: 1 Hostname: gfs01 Uuid: f88992e2-4a3f-4cbd-b79b-a5b7e28881dd State: Peer in Cluster (Connected)  1.5 创建卷 # 节点gfs01,gfs02都需执行 mkdir -p /data/glusterfs # 在gfs01执行创建卷操作 gluster volume create data replica 2 gfs02:/data/glusterfs gfs01:/data/glusterfs Replica 2 volumes are prone to split-brain. Use Arbiter or Replica 3 to avoid this. See: http://docs.gluster.org/en/latest/Administrator%20Guide/Split%20brain%20and%20ways%20to%20deal%20with%20it/. Do you still want to continue? (y/n) y volume create: data: success: please start the volume to access data # 在gfs02 查看卷信息 [root@gfs02 ~]# gluster volume info Volume Name: data Type: Replicate Volume ID: 1c27e490-af0c-4794-af45-60e960c6eb47 Status: Created Snapshot Count: 0 Number of Bricks: 1 x 2 = 2 Transport-type: tcp Bricks: Brick1: gfs02:/data/glusterfs Brick2: gfs01:/data/glusterfs Options Reconfigured: transport.address-family: inet nfs.disable: on performance.client-io-threads: off # 启动卷 gluster volume start data  1.6 简单挂载测试 # 挂载 [root@gfs01 ~]# mount -t glusterfs gfs02:/data /mnt [root@gfs02 ~]# mount -t glusterfs gfs01:/data /mnt # gfs02 写文件 touch /mnt/{1..10}.txt # gfs01 验证是否生成{1..10}.txt ls /mnt/ | wc -l  二、 对接存储GlusterFS  此步骤应该在执行安装前操作，避免安装完成后切换存储不正确导致集群不可用，下述步骤集群所属节点都需要执行。\n 2.1 所有节点配置存储节点hostname解析 所有节点(管理，计算，网关)都更新配置hosts文件\n10.10.10.13 gfs02 10.10.10.14 gfs01   验证方式： 任意集群中节点都可以正常ping通gfs01和gfs02\n 2.2 安装GlusterFS客户端程序 yum install -y glusterfs-fuse  2.3 挂载GlusterFS数据卷 # 创建挂载点 mkdir /grdata # 开机挂载,更新/etc/fstab gfs01:/data /grdata glusterfs backupvolfile-server=gfs02,use-readdirp=no,log-level=WARNING,log-file=/var/log/gluster.log 0 0 # 挂载 mount -a # 验证,应该存有安装时的验证文件 ls /grdata/ rm -rf /grdata/*.txt  2.4 其他事项说明 如果是已经安装好集群想切换到GlusterFS上,请参考如下流程:\n1. 先切换计算节点，后切换管理节点 2. 计算节点将默认的nfs存储摘掉，编辑fstab文件，切换到GlusterFS,重新挂载 3. 管理节点需要先停服务 systemctl stop node systemctl stop rbd-repo systemctl stop rbd-hub systemctl stop rbd-app-ui systemctl stop rbd-gateway systemctl stop rbd-eventlog systemctl stop rbd-worker systemctl stop rbd-chaos systemctl stop rbd-api cclear 4. 确定服务都停了之后,第一个管理节点操作 mv /grdata /backup 5. 编辑/etc/fstab mkdir /grdata mount -a 6. 同步数据 cp -a /backup/. /grdata/ 7. 其他管理节点，修改/etc/fstab重新挂载/grdata(如果有) 8. 迁移完成确定集群状态: grctl cluster 9. 第一个管理节点关闭nfs服务 systemctl stop nfs-server systemctl disable nfs-server  三、 通过ansible安装GlusterFS # 下载源码 git clone https://github.com/goodrain/rainbond-glusterfs.git cd rainbond-glusterfs # 编辑 inventory/hosts 文件 all下为所有节点信息 gfscluster下为gfscluster server端(存储节点) rainbondcluster下为gfscluster client端(即管理节点，计算节点) # 执行安装 ./setup.sh   需要注意disk_volume_device_1值为实际GlusterFS存储使用的磁盘(fdisk -l)\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/monitor/monitor/",
	"title": "监控",
	"tags": [],
	"description": "主机、服务、容器(应用异常)监控",
	"content": " 概述 本节主要介绍的是Raibond监控体系中对Node机器监控，各服务组件监控及容器监控。监控服务由Rainbond组件rbd-monitor完成，在monitor组件中采用Sidecar设计模式思想整合Prometheus服务，并基于ETCD动态发现需要监控的targets，自动配置与管理Prometheus服务。monitor会定期到每个targets刮取指标数据，并将数据持久化在本地，提供灵活的PromQL查询与RESTful API查询。通过Granfana将监控数据可视化。在Rainbond资源管理后台与控制台中，基于monitor组件刮取的监控数据对应用与容器实现资源可视化等。monitor组件支持自定义报警规则，对接Alertmanager向用户发送报警信息。\n当前rbd-monitor是冗余的工作模式，即对集群中所有节点的监控数据进行收集，当节点数量或监控数据量庞大时，对监控服务务必带来很大的压力。在后面的版本中我们会持续优化监控体系，支持多点部署、分布式数据采集、查询汇总等。\nrbd-monitor提供Prometheus服务，在浏览器中访问管理节点的9999端口即可。Prometheus默认保存七天的数据，如果你需要更改配置，在/opt/rainbond/conf/master.yaml文件中的rbd-monitor配置中修改启动参数对应的值即可。\nNode资源监控 有许多第三方组件提供导出现有的Prometheus指标供Prometheus拉取。Prometheus社区提供的NodeExporter项目可以对于主机的关键度量指标状态监控，Rainbond整合实现了NodeExporter并暴露在Node端口6100上，Prometheus可以通过http://node_ip:6100/metrics刮取本节点的主机监控指标及数据。\n在Rainbond的monitor组件中，通过etcd中注册的node信息来发现各节点，将各节点主机监控的Metrics地址配置到Prometheus配置文件，Prometheus按配置的间隔时间定时到所有Node拉取指标数据，存储数据并可用PromQL提供丰富的查询。你可以使用Prometheus的查询语句查询各资源使用情况，或者配置Granfana模版更加直观展示主机的监控信息，在下面会详细介绍如何在Granfana配置Noed监控模版。\n服务组件监控 我们在Rainbond的各服务组件中自定义了Prometheus的Exporter，定义组件健康与工作等一些指标，并将指标与数据生成Prometheus可以识别的格式，通过metrics地址供Prometheus刮取。\n在Prometheus的Targets中你可以看到这些服务组件，并可以查询这些服务组件暴露的指标及数据。\n容器监控 Cadvisor是google开源的监控项目，Cadvisor对Node机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况。\nCAdvisor 启动通过调用 Linux 系统 inotify 监测 cgroup docker 目录的文件变化判断 docker 的创建和删除。找出Container对应的系统文件读取监控数据。\nKubernetes的生态中，cAdvisor是作为容器监控数据采集的Agent，cAdvisor集成在Kubelet中，其部署在每个计算节点上的kubelet启动时会自动启动cAdvisor，一个cAdvisor仅对一台Node机器进行监控，默认端口为4194，在URLhttp://node_ip:4194/metrics 提供监控指标及数据供Prometheus刮取，默认的刮取间隔为15s一次。\n在Rainbond的monitor组件中通过etcd发现计算节点，将该节点CAdvisor提供的metrics地址配置Prometheus的配置文件，通过Prometheus指标丰富的label对容器及pod进行分类查找。并可实现对Rainbond应用的资源监控等。具体的监控项可在Granfana中配置模版，下面会详细说明如何在Granfana中配置容器监控模版。\n应用异常事件监控 应用异常事件监控是捕捉并记录在RainBond中部署应用的OOM，运行异常情况等事件。便于发现并调整存在异常的应用，避免由于应用的持续异常影响资源及各服务的正常工作。\n实现机制 Rainbond实现的worker组件中，对应用实例出的pod进行状态观察，当pod发生异常退出时触发事件来处理pod的退出信息，并将错误类型、错误原因、触发次数、最后出现时间等信息记录在数据库中供我们查询。\n具体处理流程参考文档应用异常处理\n使用Granfana 可视化监控 grafana是用于可视化大型测量数据的开源程序，他提供了强大和优雅的方式去创建、共享、浏览数据。dashboard中显示了你不同metric数据源中的数据。使用它可以快速搭建起主机及容器监控的可视化仪表盘，直观优雅的展示监控数据。通过每个仪表盘定义的Prometheus查询语句获取结果后渲染出可视化图形，还可以根据定义的标签对查询条件灵活的切换。\nGrafana安装 当安装Rainbond时，默认不安装Grafana服务。如你想安装自己的Grafana，可参阅文档安装。\n创建Prometheus数据源  单击Grafana徽标以打开侧边栏菜单。 单击侧栏中的设置图标，点击Data Sources。 单击“Add data source”。 选择“Prometheus”作为类型。 设置适当的Prometheus服务器URL（例如，http://localhost:9090/） 根据需要调整其他数据源设置（例如，关闭代理访问）。 单击“添加”以保存新数据源。  导入Node主机监控模版 Grafana支持通过json文件快速导入你需要的仪表盘模版。点击这里获取Node Exporter的json文件，点击左侧菜单栏的加号，选择Import，将json数据复制粘贴到Or paste JSON一栏中，点击load按钮，输入名称，选择刚才添加的Prometheus数据源，点击Import即可添加模版或者输入我们提供的基础资源可视化Dashboard id(10014)\n 效果展示如下，可选择Host标签切换节点\n 导入容器监控模版 容器监控模版的导入方法与上面Node主机监控的导入方法一致，点击这里获取json文件。导入后可根据标签pod_name来查看某一个pod中容器的监控情况。Node标签可切换节点，interval可切换间隔时间。\n自定制 你可以点击每个仪表盘的名字，选择Edit进入编辑页面，在这里你可以看到该仪表盘对应的Prometheus查询语句，该语句查询的数据结果渲染出该仪表盘。你可以根据自己的需求修改这些参数及设置等。\n你也可以点击上方的设置按钮，来编辑整个模版的信息，添加Variables标签等。修改后记得点击Save保存更改哦。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/monitor/monitor-alter-items/",
	"title": "监控报警配置项说明",
	"tags": [],
	"description": "基于Prometheus监控说明",
	"content": " 监控组件说明  rbd-monitor组件基于Prometheus，默认监听端口9999\n具体支持监控报警请访问 http://\u0026lt;rbd-monitor所在节点ip\u0026gt;:9999\n以下仅作为参考\n 监控项说明 节点资源监控项    监控项 所属组件 说明     cadvisor_version_info cadvisor 计算节点系统信息   machine_memory_bytes cadvisor 当前主机内存大小   machine_cpu_cores cadvisor 当前节点CPU数目   node_filesystem_size node 存储   node_load1 node 负载1m   node_load5 node 负载5m   node_load5 node 负载15m   node_memory_MemTotal node 节点内存total   node_memory_MemFree node 节点内存free   node_uname_info node 节点信息    Rainbond服务组件监控项    监控项 所属组件 说明     acp_mq_dequeue_number rbd-mq    acp_mq_enqueue_number rbd-mq    acp_mq_exporter_health_status rbd-mq    acp_mq_exporter_last_scrape_error rbd-mq    acp_mq_exporter_scrapes_total rbd-mq    builder_exporter_builder_task_error rbd-chaos    builder_exporter_builder_task_number rbd-chaos    builder_exporter_health_status rbd-chaos 1   event_log_exporter_chan_cache_size rbd-eventlog    event_log_exporter_collector_duration_seconds rbd-eventlog    event_log_exporter_container_log_store_cache_barrel_count rbd-eventlog    event_log_exporter_container_log_store_log_count rbd-eventlog    event_log_exporter_event_store_barrel_count rbd-eventlog    event_log_exporter_event_store_cache_barrel_count rbd-eventlog    event_log_exporter_event_store_log_count rbd-eventlog    event_log_exporter_health_status rbd-eventlog    event_log_exporter_last_scrape_error rbd-eventlog    event_log_exporter_monitor_store_barrel_count rbd-eventlog    event_log_exporter_monitor_store_log_count rbd-eventlog    event_log_exporter_scrapes_total rbd-eventlog    gateway_request_duration_seconds_bucket rbd-gateway 在规定请求时间(bucket)内, 客户端请求的数量   gateway_request_duration_seconds_count rbd-gateway 客户端请求的总数   gateway_request_duration_seconds_sum rbd-gateway 客户端请求时间的总数   gateway_request_size_bucket rbd-gateway 在规定出请求大小(bucket)内, 满足条件的请求的数量   gateway_request_size_count rbd-gateway 客户端请求的总数   gateway_request_size_sum rbd-gateway 客户端请求大小的总数   gateway_requests rbd-gateway 客户端访问的次数   gateway_response_duration_seconds_bucket rbd-gateway 在规定响应时间(bucket)内, 响应的次数   gateway_response_duration_seconds_count rbd-gateway 响应的总次数   gateway_response_duration_seconds_sum rbd-gateway 响应的总时间   gateway_response_size_bucket rbd-gateway 在规定出响应大小(bucket)内, 满足条件的响应的次数   gateway_response_size_count rbd-gateway 响应的总次数   gateway_response_size_sum rbd-gateway 响应的总大小   gateway_upstream_latency_seconds rbd-gateway 在规定出延迟时间(bucket)内, 满足条件的延迟的次数   gateway_upstream_latency_seconds_count rbd-gateway 延迟的总次数   gateway_upstream_latency_seconds_sum rbd-gateway 延迟时间的总和   worker_exporter_health_status rbd-worker    worker_exporter_worker_task_number rbd-worker    worker_exporter_collector_duration_seconds rbd-worker    worker_exporter_last_scrape_error rbd-worker    worker_exporter_scrapes_total rbd-worker    worker_exporter_worker_task_error rbd-worker    worker_exporter_worker_task_number rbd-worker    worker_up rbd-worker    scrape_samples_scraped     scrape_samples_post_metric_relabeling     scrape_duration_seconds     statsd_exporter_build_info     statsd_exporter_events_total     statsd_exporter_lines_total     statsd_exporter_loaded_mappings     statsd_exporter_samples_total     statsd_exporter_tag_errors_total     statsd_exporter_tags_total     statsd_exporter_tcp_connection_errors_total     statsd_exporter_tcp_connections_total     statsd_exporter_tcp_too_long_lines_total     statsd_exporter_udp_packets_total     up  组件状态    k8s集群监控项    监控项 所属组件 监控值 说明     etcd* etcd etcd监控项     应用级监控项    监控项 说明     app_resource_appmemory 应用内存，根据service_id,tenant_id筛选   app_resource_appfs 应用   app_resource_appmemory 应用   app_client_request 应用   app_client_requesttime 应用   app_request 应用   app_request_unusual 应用   app_requestclient 应用   app_requesttime 应用    应用级基于CAvisor获取典型监控指标\n   监控项 类型 说明     container_cpu_load_average_10s gauge 过去10秒容器CPU的平均负载   container_cpu_usage_seconds_total counter 容器在每个CPU内核上的累积占用时间 (单位：秒)   container_cpu_system_seconds_total counter System CPU累积占用时间（单位：秒）   container_cpu_user_seconds_total counter User CPU累积占用时间（单位：秒）   container_fs_usage_bytes gauge 容器中文件系统的使用量(单位：字节)   container_fs_limit_bytes gauge 容器可以使用的文件系统总量(单位：字节)   container_fs_reads_bytes_total counter 容器累积读取数据的总量(单位：字节)   container_fs_writes_bytes_total counter 容器累积写入数据的总量(单位：字节)   container_memory_max_usage_bytes gauge 容器的最大内存使用量（单位：字节）   container_memory_usage_bytes gauge 容器当前的内存使用量（单位：字节   container_spec_memory_limit_bytes gauge 容器的内存使用量限制   container_network_receive_bytes_total counter 容器网络累积接收数据总量（单位：字节）   container_network_transmit_bytes_total counter 容器网络累积传输数据总量（单位：字节）    其他监控项    监控项 说明     process_cpu_seconds_total    process_max_fds    process_open_fds    process_virtual_memory_bytes    process_start_time_seconds    process_resident_memory_bytes    process_open_fds    process_max_fds    process_cpu_seconds_total     报警规则说明 组件监控报警  源码构建异常任务数大于30 BuilderTaskError 源码构建组件状态异常 BuilderUnhealthy eventlog服务下线 EventLogDown eventlog组件状态异常 EventLogUnhealthy mq组件状态异常 MqUnhealthy mq队列数大于200 TeamTaskMany webcli组件状态异常 WebcliUnhealthy worker执行任务错误数大于50 WorkerTaskError worker组件状态异常 WorkerUnhealthy 服务下线 monitoring_service_down  节点监控报警  节点CPU使用率高于70 high_cpu_usage_on_node 节点5分钟内负载大于5 high_la_usage_on_node 节点内存使用率大于80 high_memory_usage_on_node 节点根分区磁盘使用率大于80 node_running_out_of_disk_space  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/storage/alinas/",
	"title": "对接阿里云NAS",
	"tags": [],
	"description": "存储对接阿里云NAS",
	"content": " 阿里云文件存储（Network Attached Storage，简称 NAS）是面向阿里云 ECS 实例、HPC 和 Docker 等节点的文件存储服务，提供标准的文件访问协议，即可使用具备无限容量及性能扩展、单一命名空间、多共享、高可靠和高可用等特性的分布式文件系统。\n本文默认已创建了文件系统，如果未创建，请参考阿里云NAS文档\n快速配置指南 提前准备好NAS，安装时指定存储类型为nas,具体示例如下：\n./grctl init --storage nas --storage-args \u0026quot;82b554a292-rvg38.cn-huhehaote.nas.aliyuncs.com:/ /grdata nfs vers=3,nolock,noatime 0 0\u0026quot;  手动对接NAS 安装配置NFS客户端程序 # Debian/Ubuntu apt-get update apt-get install nfs-common # CentOS yum install nfs-utils  配置NFS请求数量 cat /proc/sys/sunrpc/tcp_slot_table_entries  {{site.data.alerts.callout_danger}} Linux NFS 客户端对于同时发起的NFS请求数量进行了控制，若该参数配置较小，会降低 IO 性能。默认编译的内核中该参数最大值为256。您可以使用root用户执行以下命令来提高该参数的值，取得较好的性能。 {{site.data.alerts.end}}\necho \u0026quot;options sunrpc tcp_slot_table_entries=128\u0026quot; \u0026gt;\u0026gt; /etc/modprobe.d/sunrpc.conf echo \u0026quot;options sunrpc tcp_max_slot_table_entries=128\u0026quot; \u0026gt;\u0026gt; /etc/modprobe.d/sunrpc.conf sysctl -w sunrpc.tcp_slot_table_entries=128  参数修改完成后，请重启系统。\n节点挂载NFS文件系统  推荐使用NFS v3协议\n mkdir /grdata # 编辑/etc/fstab file-system-id-xxxx.region.nas.aliyuncs.com:/ /grdata nfs vers=3,nolock,noatime,proto=tcp,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport 0 0 # 挂载 mount -a # 查看挂载 mount -l  其他说明注意事项  如果安装前所有节点挂载/grdata,则默认会跳过存储操作\n 如果安装后切换/grdata存储操作\n# 计算节点 umout /grdata # 修改/etc/fstab部分，由NFS调整为阿里云NAS，重新挂载 # 多管理节点，所有节点都需要停服务 systemctl stop node systemctl stop rbd-repo systemctl stop rbd-hub systemctl stop rbd-app-ui systemctl stop rbd-gateway systemctl stop rbd-eventlog systemctl stop rbd-worker systemctl stop rbd-chaos systemctl stop rbd-api cclear # 确定服务都停了之后,第一个管理节点操作 mv /grdata /backup # 编辑/etc/fstab mkdir /grdata mount -a # 同步数据 cp -a /backup/. /grdata/ # 其他管理节点，修改/etc/fstab重新挂载/grdata   迁移完成确定集群状态: grctl cluster\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/storage/",
	"title": "存储解决方案",
	"tags": [],
	"description": "",
	"content": " 对接分布式存储  对接GlusterFS  存储对接GlusterFS\n 对接阿里云NAS  存储对接阿里云NAS\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/network/calico/",
	"title": "Calico网络",
	"tags": [],
	"description": "Rainbond默认使用Calico",
	"content": " 一、Calico介绍 Rainbond默认使用Calico定义容器虚拟网络。\nCalico是一个纯3层的数据中心网络方案。能够提供可控的VM、容器、裸机之间的IP通信。\n通过将整个互联网的可扩展IP网络原则压缩到数据中心级别，Calico在每一个计算节点利用Linux Kernel实现了一个高效的vRouter来负责数据转发，而每个vRouter通过BGP协议负责把自己上运行的workload的路由信息像整个Calico网络内传播——小规模部署可以直接互联，大规模下可通过指定的BGP route reflector来完成。\n这样保证最终所有的workload之间的数据流量都是通过IP路由的方式完成互联的。\nCalico节点组网可以直接利用数据中心的网络结构（无论是L2或者L3），不需要额外的NAT，隧道或者Overlay Network。\n如上图所示，这样保证这个方案的简单可控，而且没有封包解包，节约CPU计算资源的同时，提高了整个网络的性能。\n此外，Calico基于iptables还提供了丰富而灵活的网络Policy，保证通过各个节点上的ACLs来提供Workload的多租户隔离、安全组以及其他可达性限制等功能。\n1.1 Calico 架构  Felix，Calico Agent,跑在每台需要运行Workload的节点上，主要负责配置路由及ACLs等信息来确保Endpoint的连通状态；\n etcd，分布式键值存储，主要负责网络元数据一致性，确保Calico网络状态的准确性；\n BGP Client（BIRD）, 主要负责把Felix写入Kernel的路由信息分发到当前Calico网络，确保Workload间的通信的有效性；\n BGP Route Reflector（BIRD），大规模部署时使用，摒弃所有节点互联的 mesh 模式，通过一个或者多个BGP Route Reflector来完成集中式的路由分发；\n  二、对接Rainbond 2.1 Rainbond-Calico架构图 2.2 Calico在Rainbond实现的功能  容器网络的互连  Calico在每一个计算节点利用Linux Kernel实现了一个高效的vRouter来负责数据转发，而每个vRouter通过BGP协议负责把自己上运行的workload的路由信息像整个Calico网络内传播——小规模部署可以直接互联，大规模下可通过指定的BGP route reflector来完成。 这样保证最终所有的workload之间的数据流量都是通过IP路由的方式完成互联。\n 隔离租户  Calico基于iptables提供了丰富而灵活的网络Policy，保证通过各个节点上的ACLs来提供Workload的多租户隔离、安全组以及其他可达性限制等功能。\n2.3 k8s结合calico的使用  k8s与calico流程架构图   通过k8s创建启动网络容器，通过calico-cni插件根据cni的配置然后分配calico的网络。\n CNI配置文件介绍\n  cat /opt/rainbond/etc/cni/10-calico.conf { \u0026quot;name\u0026quot;: \u0026quot;calico-k8s-network\u0026quot;, ##网络的名字 \u0026quot;cniVersion\u0026quot;: \u0026quot;0.1.0\u0026quot;, ##CNI标准的版本号 \u0026quot;type\u0026quot;: \u0026quot;calico\u0026quot;, ##网络插件的类型 \u0026quot;etcd_endpoints\u0026quot;: \u0026quot;http://127.0.0.1:2379\u0026quot;, ##etcd地址 \u0026quot;log_level\u0026quot;: \u0026quot;info\u0026quot;, ##日志级别 \u0026quot;ipam\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;calico-ipam\u0026quot; ##ipam的类型 }, \u0026quot;kubernetes\u0026quot;: { \u0026quot;kubeconfig\u0026quot;: \u0026quot;/opt/rainbond/etc/kubernetes/kubecfg/admin.kubeconfig\u0026quot;. ##kubeconfig文件路径 } }  三、Calico性能测试 3.1 测试环境    系统 CentOS7.4      宿主机的主机名 宿主机IP 容器IP   calico1 10.80.84.49 172.19.183.195   calico2 10.81.9.113 172.19.189.196     测试工具：iperf 命令  3.2 宿主机测试  calico2执行命令  [root@calico2 ~]# iperf -s calico1 iperf: ignoring extra argument -- calico1 ------------------------------------------------------------ Server listening on TCP port 5001 TCP window size: 85.3 KByte (default) ------------------------------------------------------------   calico1执行命令  [root@calico1 ~]# iperf -c calico2 -i 2 ------------------------------------------------------------ Client connecting to calico2, TCP port 5001 TCP window size: 85.0 KByte (default) ------------------------------------------------------------ [ 3] local 10.80.84.49 port 33618 connected with 10.81.9.113 port 5001 [ ID] Interval Transfer Bandwidth [ 3] 0.0- 2.0 sec 186 MBytes 781 Mbits/sec [ 3] 2.0- 4.0 sec 130 MBytes 547 Mbits/sec [ 3] 4.0- 6.0 sec 124 MBytes 522 Mbits/sec [ 3] 6.0- 8.0 sec 124 MBytes 519 Mbits/sec [ 3] 8.0-10.0 sec 124 MBytes 521 Mbits/sec [ 3] 0.0-10.1 sec 689 MBytes 571 Mbits/sec   以上测试是客户端calico1到服务端calico2的上行带宽测试  3.3 容器测试  在calico1宿主机上的容器端执行命令  rain@36a969da35df472eaab75d71c6b27c11-fr3c2:~$ iperf -s 172.19.189.196 iperf: ignoring extra argument -- 172.19.189.196 ------------------------------------------------------------ Server listening on TCP port 5001 TCP window size: 85.3 KByte (default) ------------------------------------------------------------   在calico2宿主机的容器执行命令  rain@36a969da35df472eaab75d71c6b27c11-8k3kw:~$ iperf -c 172.19.183.195 -i 2 ------------------------------------------------------------ Client connecting to 172.19.183.195, TCP port 5001 TCP window size: 85.0 KByte (default) ------------------------------------------------------------ [ 3] local 172.19.189.196 port 54252 connected with 172.19.183.195 port 5001 [ ID] Interval Transfer Bandwidth [ 3] 0.0- 2.0 sec 179 MBytes 750 Mbits/sec [ 3] 2.0- 4.0 sec 115 MBytes 481 Mbits/sec [ 3] 4.0- 6.0 sec 126 MBytes 530 Mbits/sec [ 3] 6.0- 8.0 sec 115 MBytes 481 Mbits/sec [ 3] 8.0-10.0 sec 113 MBytes 476 Mbits/sec [ 3] 0.0-10.0 sec 648 MBytes 543 Mbits/sec   以上测试是客户端calico1的容器到服务端calico2中容器的上行带宽测试  3.4 结论  通过测试对比我们发现使用calico中容器之间的网络与宿主机的消耗是非常小的。  四、Calico维护 4.1 Calico的常用资源    资源 说明     node 物理机连接数   ipPool calico的ip池   policy 节点的资源   profile 配置文件的资源     资源使用yaml文件描述  详细资源与格式介绍\n4.2 Calico对资源的常用操作  资源常用命令\n   命令 用途     create 创建   apply 增加   delete 删除   replace 修改   get 查看    操作资源格式\n  calicoctl \u0026lt;COMMAND\u0026gt; -f \u0026lt;FILE_NAME\u0026gt;\n 例：添加一个calico的ip池\n  calicoctl apply -f ippool.yaml\n   查看 命令     查看节点连接状态 calicoctl node status   查看状态信息命令格式 calicoctl get \u0026lt; NAME \u0026gt;   以文件格式查看详细信息的命令格式 calicoctl get \u0026lt; NAME \u0026gt; -o yaml     例：以文件形式查看calico的ip池信息  calicoctl get ippool -o yaml\n4.3 Calico启动参数 calico启动配置文件路径为 /etc/systemd/system/calico.service\n[Unit] Description=calico After=docker.service [Service] ExecStartPre=-/bin/bash -c 'docker rm calico' ExecStart=/bin/bash -c '/usr/bin/docker run --net=host --privileged --name=calico --restart=always -e NO_DEFAULT_POOLS= -e CALICO_LIBNETWORK_ENABLED=true -e CALICO_IPV4POOL_IPIP=always -e IP=10.10.10.19 -e CALICO_IPV4POOL_CIDR=10.20.0.0/16 -e CALICO_LIBNETWORK_CREATE_PROFILES=true -e CALICO_LIBNETWORK_LABEL_ENDPOINTS=false -e CALICO_LIBNETWORK_IFPREFIX=cali -e NODENAME=node1 -e CALICO_NETWORKING_BACKEND=bird -e IP6_AUTODETECTION_METHOD=first-found -e ETCD_ENDPOINTS=http://10.10.10.19:2379 -v /var/log/calico:/var/log/calico -v /var/run/calico:/var/run/calico -v /lib/modules:/lib/modules -v /var/lib/calico:/var/lib/calico -v /run/docker/plugins:/run/docker/plugins -v /var/run/docker.sock:/var/run/docker.sock goodrain.me/calico-node:v3.3.1' ExecStop=/bin/bash -c 'docker stop calico' Restart=always RestartSec=10 [Install] WantedBy=multi-user.target  五、其它可支持的网络组件 Rainbond还支持midonet、flannel网络组件。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/network/",
	"title": "网络解决方案",
	"tags": [],
	"description": "",
	"content": " 软件定义网络  Calico网络  Rainbond默认使用Calico\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/tools/",
	"title": "周边工具集",
	"tags": [],
	"description": "",
	"content": "汇总了 Rainbond 周边工具集，安装时已经默认内置了，其默认路径为`/opt/rainbond/etc/tools/bin`。   grclis  Rainbond grclis\n grctl  Rainbond CLI工具集\n 其他命令行工具  其他命令行工具(dps,din等)\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/trouble-shooting/pt-faq/",
	"title": "平台问题排查FAQ",
	"tags": [],
	"description": "",
	"content": " 当安装使用 Rainbond 遇到问题时，请先参考本篇文档快速索引部分。如果问题未解决，请按要求收集必要的信息通过[社区(用户帮助)](https://t.goodrain.com/)或者[Github](https://github.com/goodrain) 提供给Rainbond开发者。尽可能提供具体信息，方便排查问题。 ```yaml # 参考模板 Rainbond版本(grctl version/docker run --rm goodrain.me/rbd-api:5.1.1 version): 操作系统/内核版本: 节点配置(CPU核数,内存大小,硬盘类型(SSD/机械硬盘),网络类型,网络拓扑): 安装类型(是否离线或者对接已有集群): 集群状态(是否health，是否有计算节点，是否多管理节点): 如何复现(什么操作导致的): 尝试解决(重启相关组件): 相关截图(具体日志部分截图): ```  安装指南  安装问题建议反馈至 rainbond-ansible\n  安装如何自定ssh port\n# 目前不支持多节点的SSH端口都不同 export INSTALL_SSH_PORT=12306 ./grctl init   使用指南  企业管理员密码忘记如何处理 对接自己私有Artifactory指南 控制台报系统等错误服务排查 web容器管理报错 创建应用提示Table \u0026lsquo;region.tenants\u0026rsquo; doesn\u0026rsquo;t exist  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/trouble-shooting/app-faq/",
	"title": "应用问题排查FAQ",
	"tags": [],
	"description": "",
	"content": " 当安装使用 Rainbond 遇到问题时，请先参考本篇文档快速索引部分。如果问题未解决，请按要求收集必要的信息通过[社区(用户帮助)](https://t.goodrain.com/)或者[Github](https://github.com/goodrain) 提供给Rainbond开发者。尽可能提供具体信息，方便排查问题。 ```yaml # 参考模板 1. 集群是否正常（grctl node list） 2. 应用是否正常 (grctl service get ) 3. 应用监听端口是否正确，是否开启了健康检测，持久化目录是否设置正确 4. 应用构建失败报错 5. 应用日志是否有明显报错 6. rbd-repo服务是否正常 ```  使用指南  源码构建失败提示gzip stdin not in gzip format 应用状态处于启动中排查  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/upgrade/",
	"title": "版本升级",
	"tags": [],
	"description": "",
	"content": "汇总了5.1.x版本升级文档,具体细节请参考[社区版本升级公告](https://t.goodrain.com/c/announcements)   5.0.4升级至5.1.0文档  Rainbond 5.1.0升级文档\n 5.1.0升级至5.1.1文档  本文档记录了Rainbond v5.1.1 中功能的优化和BUG修复记录及升级文档\n 5.1.1升级至5.1.2文档  本文档记录了Rainbond v5.1.2 中功能的优化和BUG修复记录及升级文档\n 5.1.2升级至5.1.3文档  本文档记录了Rainbond v5.1.3 中功能的优化和BUG修复记录及升级文档\n 5.1.3升级至5.1.4文档  本文档记录了Rainbond v5.1.4 中功能的优化和BUG修复记录及升级文档\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/manage-team/",
	"title": "团队管理",
	"tags": [],
	"description": "",
	"content": " 团队管理 本章节将带你了解Rainbond团队管理机制和使用方式\n 团队介绍和创建方式  Rainbond团队概念讲解和创建方式说明\n 成员和角色管理  团队成员管理方式和角色管理方式\n 团队开通数据中心管理  Rainbond团队开通数据中心管理\n 权限管理  Rainbond团队权限管理\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/manage-team/create-team/",
	"title": "团队介绍和创建方式",
	"tags": [],
	"description": "Rainbond团队概念讲解和创建方式说明",
	"content": " 什么是Rainbond团队 通常的意义是由若干个用户组成的组织就叫做团队，在Rainbond中，团队是一个资源集合的概念，这个资源集合包括了用户、应用、插件等。每一个团队会在某个数据中心开通一个租户空间，一个团队可在此租户空间内创建和使用允许的各类资源。\n为什么要创建团队  Rainbond平台的宗旨是以应用为核心，应用只属于团队。 Rainbond在企业使用过程中可能需要被不同的开发人员和团队、运维人员和团队、测试人员和团队使用。Rainbond平台的团队概念可以与企业内部的组织架构相呼应。 某个团队在一个数据中心下开通一个租户来使用资源，只有创建团队才能使用资源  团队的创建 平台管理员新建团队 平台管理员注册完毕后，可以新建团队\u0008。 团队重命名 数据中心  如果您具有开通数据中心权限，\u0008才可以执行开通数据中心操作。 开通数据中心是团队级别的，添加数据中心是企业级别的。 平台的核心是\u0008应用定义一切，但是团队和数据中心是平台的基础。  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/manage-team/manage-user/",
	"title": "成员和角色管理",
	"tags": [],
	"description": "团队成员管理方式和角色管理方式",
	"content": "  成员管理 为了让用户能够更好的管理团队及分配相关功能，我们设计了基于角色的权限系统。该系统基于角色来控制成员的行为，并支持用户自定义团队中的角色，平台默认设置了三个角色，分别为：\n Admin：团队管理员 Developer：开发者 Viewer：观察者  权限系统拥有灵活定制性的同时也使权限控制的粒度更加细腻。\n添加团队成员 如果您在本团队拥有的角色中包含团队权限设置这一权限，那么您可以在团队管理中的团队成员一栏中查看您当前团队下的所有成员，并点击添加成员可以为团队新添加一个成员，并给该成员授予一个您当前团队中存在的角色，这样该成员就拥有该角色所对应的所有权限操作了。\n\n删除团队成员 如果您在本团队拥有的角色中包含团队权限设置这一权限，那么您可以在团队管理中的团队成员一栏中点击您想要删除成员后方的删除按钮，再次确认后即可将此成员在本团队中移除。\n\n修改成员角色 如果您在本团队拥有的角色中包含团队权限设置这一权限，那么您可以在团队管理中的团队成员一栏中点击您想要修改的成员后方的修改角色按钮，给该成员选择一些您团队中已经存在的角色，点击确认即可修改该成员在此团队中的角色。\n\n角色管理 添加角色 如果您是团队的owner(创建者)或者admin(管理员)，您可以在团队管理中的角色管理一栏中点击添加角色来为本团队新添加一个角色，同时为这个角色绑定您需要的权限选项。\n- 如果您想定义一个角色来参与团队或者应用的相关操作，那请您务必赋予这个角色一些基本的权限，比如`登入团队`，`查看应用信息`。 - 您添加的角色名称不可以与系统默认的角色名称相同 - 角色名称是三十个字符内的数字/字母/中文字符/下划线/中划线的任意组合  \n删除角色 您可以删除团队中自定义的角色，但您在本团队中的角色必须是owner(创建者)或者admin(管理员)才可以进行删除自定义角色的操作。您可以在团队管理中的角色管理一栏中点击想要删除角色后方的删除`按钮，再次点击确认后即可删除本角色。\n- 如果您的团队中已经有成员拥有此角色，那您不能直接删除该角色  \n编辑角色 您可以修改自定义角色的名称以及这个角色对应的权限选项。但您在本团队中的角色必须是owner(创建者)或者admin(管理员)才可以进行修改自定义角色的操作。您可以在团队管理中的角色管理一栏中点击想要修改的角色后方的修改按钮，修改角色名称以及对应的权限选项，确认无误后点击确认即可完成对次角色的修改，\n\n参考： 团队权限管理\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/manage-team/manage-datacenter/",
	"title": "团队开通数据中心管理",
	"tags": [],
	"description": "Rainbond团队开通数据中心管理",
	"content": " 团队开通数据中心管理 什么是Rainbond数据中心 数据中心是由Rainbond定义的一个抽象模型，它实际上是由一个Rainbond集群构成，对外提供标准的Restful API服务。当前企业能够开通的数据中心列表由资源管理后台维护，团队可以由团队管理员选择开通多个数据中心，开通一个数据中心的实质是在数据中心内创建一个租户空间，并允许当前团队创建和使用相应的分配的可用资源池。\n 提示：\u0008数据中心的维护管由企业版的管理后台完成，开源版通过命令行进行管理。\n 开通数据中心 "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/manage-team/manage-permision/",
	"title": "权限管理",
	"tags": [],
	"description": "Rainbond团队权限管理",
	"content": " 权限管理 什么是权限 权限与可执行的操作对应，具备某个权限的意思就是运行进行某项操作。Rainbond的权限系统设计为两级控制，团队级控制和应用级控制。他们是继承关系。Rainbond可选的权限是确定的，随着版本的变化而改变。用户可以管理的是角色和权限的关系，即某个角色具备哪些权限。\n 如果您在团队管理中新建一个团队角色，并给这个角色绑定了一个应用相关的权限，那么这些应用相关的权限在所有的应用中都有效。 在某一应用中添加一个应用成员并赋予一些应用相关的权限，并不会覆盖掉该成员在团队的中角色所对应的那些应用相关的权限，而是取两者的权限并集。 如果您想让一个成员查看到应用组的信息总览，那么请您给该成员团队中的角色添加查看应用信息的权限。  权限功能说明    权限功能 说明     登入团队 该权限控制一些团队信息的获取，如果您定义的角色是为了使用该团队，那么请您务必选择该权限   开通数据中心 控制该角色能否为团队开通数据中心   团队权限设置 为团队添加团队成员，删除团队成员，修改团队成员角色   自定义角色 能否在团队中添加自定义角色，删除自定义角色，修改自定义角色对应的权限。目前只有团队的owner与admin拥有此权限   应用导入导出 控制云市应用的导入和导出操作   查看插件信息 团队中我的插件板块的查看权限   插件管理 在团队中新建插件，删除插件，安装插件，管理插件等操作权限   应用组管理 新建应用(组)，删除应用(组)，应用(组)内应用的移动   应用组分享 应用(组)分享的权限   创建应用 创建服务的权限   删除应用 删除一个服务的权限   查看应用信息 应用(组)总览信息查看，应用的信息获取和查看   部署应用 服务的构建和部署权限   启动应用 启动一个服务的权限   关闭应用 关闭一个服务的权限   重启应用 重启一个服务的权限   回滚应用 回滚一个服务的权限   应用容器管理 获取容器节点与进入容器   应用伸缩管理 服务伸缩板块的操作权限   应用扩展管理 服务扩展板块的操作权限   应用配置管理 服务依赖，存储，端口，特性，环境变量，健康监测，自动部署等应用的配置操作权限   应用权限设置 在一个服务中添加应用成员，删除服务成员，修改应用成员在本服务中的权限   查看访问控制 查看访问控制的权限   访问证书管理 查看证书管理的权限   访问控制操作 \u0008对策略操作(增加、删除、编辑)的权限   证书管理操作 对证书操作(增加、删除、编辑)的权限    "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/",
	"title": "应用&amp;服务创建",
	"tags": [],
	"description": "",
	"content": " 应用\u0026amp;服务创建 应用 由一个或多个服务组件组成, 能够提供一种或多种IT业务处理能力。应用是一个整体，具备生命周期属性，能够进行统一的管理，比如安装/升级、启动/停止、备份/恢复等。\n通常意义的应用包括： 各类信息系统、OA、CRM、ERP、数据库、大数据、物联网、互联网平台、微服务架构等运行在企业内部的各种系统.  服务组件 是Rainbond的控制核心承载体，是指提供某项服务的最小单元，其应该具有一个或多个服务端口，可以单独部署。其一般由一个源码仓库或一个容器镜像创建而来，也可以是运行于Rainbond集群外的第三方服务。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/service_create/",
	"title": "服务创建方式",
	"tags": [],
	"description": "",
	"content": " 这篇文章将会为你介绍Rainbond的服务的创建方式.\n应用的定义中已经提到,应用是由各个不同的服务组件构成,那么应用的创建就离不开服务组件的创建.服务组件创建的方式有4种,分别是:从源码创建,从Docker镜像创建,从应用市场安装和创建第三方服务。\n从源码创建 Rainbond支持多种流行的编程语言的源码创建,同时也支持通过Dockerfile进行创建，从源代码创建和持续部署服务是Rainbond最常用的创建方式，其是DevOps流程中最关键的一环。\nRainbond目前支持的\u0008语言有:\n Java源码创建服务 PHP源码创建服务 Python源码创建服务 Node.js源码创建服务 Golang源码创建服务 .Net源码创建服务 Html静态源码创建服务 Dockerfile源码创建服务  通过源码的方式创建服务组件,需要把源码托管在版本控制系统上,Rainbond目前支持的版本控制系统有\u001d*Git*和SVN,也是目前大家常用的版本控制系统。相应的源码必须符合Rainbond的源码支持规范，当然定义的规范都是与各语言推荐规范一致。 需要注意的是对于一些聚合工程,我们想要构建服务所需的源码,可能位于仓库下的某一个子目录下，获取对应子目录下的源码的方式如下：\n Git:使用dir请求参数指定源码主目录。例如： 源码仓库地址为: https://github.com/demo/demo.git, 所需源码位于子目录/subdir1/subdir2下，则构建应用使用的仓库地址为: https://github.com/demo/demo.git?dir=subdir1/subdir2   我们不推荐使用子目录的方式对项目进行区分,应该尽可能地给每个项目建立独立的Git仓库.这样可以使代码的结构更加地清晰,不至于太臃肿,方便管理。\n  SVN:svn原生支持处理子目录，例如：  源码仓库地址为:http://svn.demo.net/trunk/subdir, 则构建应用使用仓库地址为: http://svn.demo.net 分支选择为子目录路径:trunk/subdir\n从Docker镜像创建 从标准的Docker镜像创建一些中间价或其他开源项目服务是最便捷的途径，但是对于企业自研的业务系统要求用户必须掌握容器化相关知识。\n你可以\u0008将项目的代码,运行时环境,依赖库,配置等资源或信息\u0008通过Dockerfile打包成一个或多个镜像,上传到DockerHub或其他公有镜像仓库中,或是自己的私有仓库。对于项目中所需要的数据库,\u0008消息队列等中间件,或者ElasticSearch,Kibana,Grafana\u0008等日志收集\u0008\u0008工具,你甚至可以直接在DockerHub找官方制作好的镜像,不需要自己去制作.然后,你可以通过镜像的名字,DockerRun命令,或者DockerCompose,将的镜像直接跑在Rainbond平台。\n从Docker镜像创建和持续构建服务也是DevOps流程中使用较为广泛的方式，特别是对于已经搭建了CI流程的企业，通过第三方的CI系统（比如Jenkins）将代码处理完成打包为Docker镜像存储于私有镜像仓库中。Rainbond完成后续的CD流程，将镜像转化为集群服务与应用中其他组件进行架构关联，调度运行，生命周期管理等。\n以下的镜像不能安装:  发行版及软件包镜像：Debian,Ubuntu,Centos,Fedora,FreeBSD 编程语言或其他基础运行环境镜像：Golang,Ruby,Openjdk 命令行工具类软件镜像:\u0008Docker,HomebrewBottles  指定镜像 Rainbond可以通过直接拉取Docker官方或者第三方Docker镜像的方式创建服务,但需要注意的是,第三方Docker仓库一定要支持HTTPS协议,否则需要就修改管理节点的Docker配置,使其支持非HTTPS的Docker仓库.\n指定DockerRun命令 使用DockerRun命令创建是Rainbond支持Docker镜像基础上提供的一项便捷操作,Rainbond会解析出DockerRun命令中的镜像,端口,环境变量，内存和存储等服务属性信息,然后生成Rainbond应用（服务）抽象。因此此过程的体验效果与你在单机上运行DockerRun命令可以直接运行容器一样，直接在集群下快捷创建并启动一个服务。\n Rainbond支关心镜像,端口,环境变量，内存和持久化挂载等信息,其它\u0008信息将会被\u0008忽略。此方式支持大多数Dockerhub上提供的镜像运行方式执行。\n 指定DockerCompose 对DockerCompose的支持是在对DockerRun命令的基础上进一步升级，用户在单机环境下可以基于DockerCompose快捷部署多个容器，在Rainbond平台一样，基于Docker Compose配置可以便捷生成多个服务（通常是一个完整的应用抽象），直接在集群环境下运行。Rainbond提供的服务间通信机制可以完美支持常用的DockerCompose配置，目前支持的DockerCompose版本有：\n\u0026ldquo;1\u0026rdquo;, \u0026ldquo;1.0\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;2.0\u0026rdquo;, \u0026ldquo;2.1\u0026rdquo;, \u0026ldquo;2.2\u0026rdquo;, \u0026ldquo;2.3\u0026rdquo;, \u0026ldquo;2.4\u0026rdquo; \u0026ldquo;3\u0026rdquo;, \u0026ldquo;3.0\u0026rdquo;, \u0026ldquo;3.1\u0026rdquo;, \u0026ldquo;3.2\u0026rdquo;, \u0026ldquo;3.3\u0026rdquo;, \u0026ldquo;3.4\u0026rdquo;, \u0026ldquo;3.5\u0026rdquo;, \u0026ldquo;3.6\u0026rdquo;, \u0026ldquo;3.7\u0026rdquo;\n从应用市场安装 从应用市场安装和分享到应用市场是一个循环的过程，例如企业中某个团队制作了一个生成可用的Mysql集群应用分享到应用市场，其他团队就无需再自己优化复杂的Mysql配置，直接一键安装应用到自己的业务系统中作为一个服务即可。因此从应用市场安装和升级是企业内方案共享和应用交付的关键流程。除了企业私有的应用市场以为，Rainbond提供了市场间同步的能力，可以实现完整业务系统的多平台共享和交付能力。\n关于应用市场的更多信息,请前往:应用市场\n添加第三方服务 关于第三方服务请参阅： 第三方服务说明文档\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/creation-process/",
	"title": "服务创建流程",
	"tags": [],
	"description": "Rainbond服务创建流程指南",
	"content": " 本节内容就上文提到的三种创建方式在Rainbond平台上如何操作提供指南。\n从源码创建 下面将会以Java源码创建服务为例, 介绍在Rainbond上用源码创建服务流程。 \u0026gt; 源码地址: https://github.com/goodrain/java-maven-demo.git\n服务的创建目前有两个入口，分别是左部导航的创建应用入口和应用管理的添加服务组件入口，创建流程一致。\n Step 1: 提供服务名称和所属应用，最关键的是提供构建源信息，源码构建即提供代码仓库地址，授权等信息。\n Step 2: 等待Rainbond对源代码进行检测，这个过程Rainbond将根据代码源信息获取源代码并进行语言类型、语言规范等检测，并从rainbondfile文件中读取服务属性。\n Step 3: 如果检测结果通过即会根据检测回的服务属性创建服务，如果不通过用户需要根据提示更改相关信息。\n Step 4: 检测完成后用户可以选择构建启动或进行高级设置，设置更多服务属性。若选择构建启动Rainbond将再次获取源代码根据代码检测的语言类型进行源码构建。请注意，源码类型只会在源码检测中读取，因此后续的开发过程如果更改了语言类型，需要触发重新代码检测。\n Step 5: 服务构建完成后即可通过端口绑定的默认域名进行访问。后续的管理维护流程参阅 服务管理文档\n  其他语言源码支持参阅下述文档  Java源码创建服务 PHP源码创建服务 Python源码创建服务 Node.js源码创建服务 Golang源码创建服务 .Net源码创建服务 Html静态源码创建服务 Dockerfile源码创建服务  Git 和 SVN 的使用 在创建服务时，根据代码仓库的类型选择 Git 或 SVN, 并正确填写该应用的代码仓库地址以及要使用的代码分支或 tag. Git的默认分支是 master, SVN 的默认 tag 是 trunk.\n 账号密码连接代码仓库  如果需要用账号密码连接代码仓库, 则点击填写仓库账号密码, 正确填写你的登陆用户名及密码即可.\n SSH 连接代码仓库  如果需要用 SSH 秘钥连接代码仓库, 则点击下方的配置授权 Key, 会为你生成一段秘钥, 然后把这段秘钥添加到你代码仓库的部署秘钥中.\n从Docker镜像创建 下面将会以Nginx的官方镜像为例, 介绍并演示在Rainbond上用Docker镜像创建服务的过程。 与源码创建流程一样，不同的是提供的构建源信息和类型不同，流程如下：\n Step 1: 提供服务名称和所属应用，最关键的是提供构建源信息，镜像构建即提供镜像名称和授权信息。\n Step 2: Rainbond将根据提供的镜像信息获取镜像，Rainbond能够获取到指定的镜像是创建成功的基础。目前Rainbond对于镜像的检测规范较为灵活，因此务必注意通过检测的镜像不一定能够正常的运行，比如上文提到的Rainbond不能运行的镜像类型。Rainbond获取镜像成功会解析镜像的元数据获取创建服务所需的属性信息。\n Step 3: 应用检测通过后即可创建服务。\n Step 4: 构建完成后即可访问服务。后续的管理维护流程参阅 服务管理文档\n  这样, 一个由 Docker 镜像创建的服务就完成了。如果从私有镜像仓库的镜像创建服务，需要注意下述几类问题：\n 私有仓库Https配置完善，可以直接拉取镜像。 如果私有仓库使用自签证书，Rainbond管理节点需要配置私有仓库信任，参考运维文档。 如果镜像仓库是私有的，请提供正确的账号密码信息。  示例部署带启动命令的镜像应用  通过docker run命令方式部署: docker run -p 8490:8490 goodrain.me/test -s \u0026quot;ws://192.168.1.1:8490\u0026quot; 通过指定镜像方式:  镜像地址: goodrain.me/test 并构建 应用构建源处修改启动命令为 -s \u0026quot;ws://192.168.1.1:8490\u0026quot;   `goodrain.me/test`请替换为自己镜像  从应用市场安装 从应用市场安装过程非常简单，只需要提供需要安装到的应用即可。 这样, 一个从应用市场安装的应用就完成了。从应用市场安装将是应用交付的关键流程，应用市场的应用支持一键安装和持续升级。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/image-support/docker-compose/",
	"title": "DockerCompose支持规范",
	"tags": [],
	"description": "本章节将带你认识Rainbond基于DockerCompose配置创建多个服务的支持规范",
	"content": " 支持原理 DockerCompose是Docker生态中的一个子项目，它提出了定义多个容器服务守护启动参数或构建方式的一种规范，它主要应用于单机容器化环境场景，类似于容器环境下的systemd。使用DockerCompose定义的多组件服务从通信方式、依赖关系上限制了只能单机部署，这与Kubernetes对服务的处理方式有一定区别。如何让DockerCompose定义的所有服务能够运行于Kubernetes集群中，这就是Rainbond提供的基于DockerCompose创建服务提供的功能。\n用户提供可以正常运行的DockerCompose定义文件，Rainbond将解析此文件并分别读取内部的所有服务的关键配置，包括：服务名称、镜像名称及仓库地址、环境变量、依赖关系（启动顺序）、持久化存储、服务端口。基于这些属性创建Rainbond服务抽象，再通过Rainbond的服务抽象模型的管理运行机制部署于底层的Kubernetes集群。从而实现DockerCompose到Kubernetes的转化。\n其中较为关键的是依赖关系、DockerCompose中服务之间建立依赖关系使用的是Docker的同网络空间原理，结合Docker默认的DNS服务对依赖服务别名进行域名解析从而实现服务间通信。这种模式在Kubernetes场景中无法直接实现，但是基于Rainbond的默认ServiceMesh机制，就实现了一直的效果，Rainbond dns服务将解析服务别名到127.0.0.1, 服务通过别名访问其他服务时，实际就是访问服务本地的代理，本地的ServiceMesh Sidecar容器完成服务动态发现和负载均衡。 从效果上看与单机运行的DockerCompose是一致的，但是实际上整个应用已经是在集群环境下分布式运行，每一个服务都可以运行多个实例。\n创建方式及注意事项 通过导航-创建应用-从Docker镜像创建-选择DockerCompose即可进入DockerCompose创建流程。由于DockerCompose创建出一个完整应用（包含N个服务组件），因此创建时必须创建并指定一个新的应用。\n有以下几点注意事项\n 如果DockerCompose配置中设置有需要读取环境变量的信息，请先手动完成更改。Rainbond不支持动态基于环境变量渲染DockerCompose配置。 确保yaml格式的DockerCompose配置正常，否则无法通过检测。 检测过程中Rainbond将通过镜像信息解析镜像仓库地址并发生验证镜像是否存在请求，只有通过所有验证检测才会通过。在5.1.3以前版本中，验证方式是直接pull镜像，因此检测过程时间比较长。 5.1.3及以后版本中Rainbond只会从DockerCompose配置中读取属性，不再从镜像从解析属性。尽量将有用的属性信息（环境变量、端口、存储）显式配置。  镜像仓库账号密码设置  整体设置  在DockerCompose表单设置中可以添加镜像仓库账号密码，此设置将在此DockerCompose中的所有镜像生效，如果个别镜像不需要账号密码或账号不同，请使用分别设置方式。\n 分别设置  分别设置是指在DockerCompose配置中为每个服务增加特殊的环境变量来定义当前服务镜像的镜像仓库账号密码。设置方式是：\nHUB_USER 设置账号\nHUB_PASSWORD设置密码\n 注意：当两种方式同时存在时，分别设置的优先级高于整体设置。\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/image-support/",
	"title": "Docker镜像支持规范",
	"tags": [],
	"description": "本章节将带你认识Rainbond基于Docker镜像创建服务的支持规范",
	"content": " 本章节将带你认识Rainbond基于Docker镜像创建服务的支持规范。\n镜像支持规范 Rainbond基于已有标准制作镜像创建服务的方式是最快，兼容性最强的途径。这里我们将从以下几个方面描述什么镜像可以在Rainbond运行：\n不能运行的镜像 这里我们首先来说明哪些镜像不能运行，这个非常重要。\n 基础系统环境类  以alpine centos debian 为代表的基础系统镜像是我们制作服务镜像必然会用到的，但是它们是不能直接在Rainbond上运行，为什么？ 因为它们启动进程默认是非前台运行的，即容器启动则会退出。只能在本地运行时打开stdin进行TTL交互式运行。\n 基础语言\u0026amp;工具类  目前有比较多的开发者使用Docker镜像的方式来分发命令行工具，比如golang编译环境、docker编译环境、maven编译环境等等。它们不能运行的原因与第一类相同。\n可运行镜像 除了上述描述的镜像类型外，如下类型的服务我们推荐基于镜像创建：\n 中间价类  比如Mysql Mongo Redis Tomcat nginx 等经常使用的中间价服务。\n web工具类  比如phpmyadmin等\n 基础服务类  比如sFTP服务、minio对象存储服务等\n 其他提供TCP或UDP协议服务的各类服务镜像  镜像检测规范  镜像是可以被Rainbond管理节点正常获取的\n 提供的镜像名称准确，且存在于对应的镜像仓库中\n 私有仓库镜像请务必提高账号密码\n 自建仓库请配置HTTPs或为Rainbond管理节点Docker配置信任\n  Rainbond将从镜像中获取以下属性信息：\n 端口，dockerfile中配置的Expose端口信息将被获取。 环境变量，环境变量是云原生下推荐的自定义配置方式，也是Docker镜像自定义配置的推荐用户。 存储挂载，dockerfile中配置的volume信息将被获取    Docker compose创建的服务只从compose配置中获取，docker run创建从创建命令和镜像中获取。\n  服务内存分配的设定：  以镜像创建的服务默认使用512M内存分配，通过dockerrun或者docker compose创建的服务如果显示设置了内存参数的，将以设定的为准。\n 服务部署类型的设定：  以镜像创建的服务默认设定为无状态部署类型，5.1.3版本以后，镜像名称为以下值时默认设置为有状态部署类型 : * mysql * mariadb * mongo * redis * tidb * zookeeper * kafka * mysqldb * mongodb * memcached * cockroachdb * cockroach * etcd * postgres * postgresql * elasticsearch * consul * percona * mysql-server * mysql-cluster\n例如以下镜像将部署为有状态类型：\n mysql:latest hub.example.com/xxx/mysql:5.5 xxx/mysql:5.7  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/",
	"title": "开发语言支持规范",
	"tags": [],
	"description": "本章节将带你认识Rainbond基于源码创建和持续构建服务的规范",
	"content": " 开发语言支持规范  Dockerfile  Dockerfile语言类型Rainbond支持规范介绍\n Java  Java语言类型Rainbond支持规范介绍,支持Maven、Gradle构建和Jar包、War包部署\n Python  Python语言类型Rainbond支持规范介绍\n PHP  PHP语言类型Rainbond支持规范介绍\n .NetCore  .NetCore语言类型Rainbond支持规范介绍\n Golang  Golang语言类型Rainbond支持规范介绍\n 静态HTML  静态Html语言类型Rainbond支持规范介绍\n Node.JS  NodeJS语言类型Rainbond支持规范介绍\n NodeJS前端语言  NodeJS前端语言类型Rainbond支持规范介绍, 部署Vue React Angular源码部署到Rainbond\n .slugignore文件  讲解.slugignore文件的用法和作用\n Procfile文件  讲解Procfile文件的用法\n rainbondfile源码定义环境配置文件  讲解rainbondfile文件的用法\n 其他环境变量设置  其他环境变量设置\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/dockerfile/",
	"title": "Dockerfile",
	"tags": [],
	"description": "Dockerfile语言类型Rainbond支持规范介绍",
	"content": " Dockerfile类型识别策略 代码主目录下有 Dockerfile 文件，Rainbond会识别代码语言类型为Dockerfile，此策略优先级最高，当代码同时符合其他语言类型识别策略时，依然以Dockerfile为主。\n编译原理 识别为Dockerfile类型的源码将使用类似于docker build -t xxx/xxx .的命令进行镜像构建，因此此方式是灵活性最高的源码编译方式，理论上可以应用于所有开发语言的支持（如果Docker支持）。\n构建过程支持 docker multi-stage(多阶段构建)和 ARG参数指定。\nDockerfile规范 Dockerfile 是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。\nRainbond在源码检测阶段会读取Dockerfile定义的如下参数：\n   参数类型 名称 说明     ENV 环境变量 识别为服务可设置的环境变量配置   ARG 构建参数 识别为构建可设置的参数配置   EXPOSE 暴露端口 识别为服务的端口配置   VOLUME 持久化存储 识别为服务的共享持久化存储配置    Dockerfile的定义方式详见官方文档： https://docs.docker.com/engine/reference/builder/\n在此给出Dockerfile编译部署Golang源码的用例：\nFROM muninn/glide:alpine AS build-env ADD . /go/src/app WORKDIR /go/src/app RUN glide install RUN go build -v -o /go/src/app/app-server FROM alpine RUN apk add -U tzdata RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime COPY --from=build-env /go/src/app/app-server /usr/local/bin/app-server EXPOSE 80 CMD [\u0026quot;app-server\u0026quot;]  完整示例代码  https://github.com/goodrain/dockerfile-demo.git  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java/",
	"title": "Java",
	"tags": [],
	"description": "Java语言类型Rainbond支持规范介绍,支持Maven、Gradle构建和Jar包、War包部署",
	"content": "Rainbond 可以快速将 Java 源码程序轻松部署到平台，并提供灵活伸缩的高可用特性。您可以部署标准的基于 Tomcat 或 Jetty 的Web应用，同时也支持 SpringBoot 等框架构建的应用程序。我们致力于在不改变开发习惯情况下将您的 Java 应用在云端快速部署、运行、灵活伸缩！\nRainbond支持以下几种程序部署类型：\n部署Java Maven源码项目\n\n部署Java Gradle源码项目\n\n直接部署Java Jar包\n\n直接部署Java War包\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/python/",
	"title": "Python",
	"tags": [],
	"description": "Python语言类型Rainbond支持规范介绍",
	"content": " Python语言识别策略 平台默认会根据源码根目录是否有requirements.txt文件来识别为Python项目.\n平台编译运行机制  预编译处理会探测是否定义了启动命令配置文件Procfile,如果未定义会生成默认Flask/Django启动配置文件; 预编译处理完成后,会根据语言类型选择Python的buildpack去编译项目.在编译过程中会安装定义的Python版本以及相关Python依赖; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  Python项目源码规范 在此步骤中，你需要提供一个可用的Python源码程序用来部署在Rainbond平台上,此应用程序至少需要满足如下条件:\n 本地可以正常运行部署的Python程序\n 项目可以托管到git仓库\n 项目根目录下必须存在requirements.txt,用来管理Python项目的依赖,也是Rainbond识别为Python语言的必要条件\n 项目根目录下需要定义Procfile,用来定义程序启动方式 项目根目录下存在runtime.txt,用来定义当前项目的Python使用版本\n  requirements.txt 规范 若程序没有依赖关系，可使requirements.txt为空文件。 若无requirements.txt可用如下命令生成\npip freeze \u0026gt; requirements.txt  Procfile规范 如果项目未定义Procfile文件,平台默认会生成默认Procfile来运行War包。\nweb: gunicorn app:app --log-file - --access-logfile - --error-logfile -  上述是默认Procfile,如果需要扩展更多启动参数,可以自定义Procfile。\n1. `web:`和`gunicorn`之间有一个空格 2. 文件结尾不能包含特殊字符  编译运行环境设置 配置Python版本 推荐使用runtime.txt来定义Python版本,若未定义,Rainbond将会默认使用python-3.6.6版本。\n$ cat runtime.txt python-3.6.6  推荐的python版本\n Python-2.7.15 Python-3.6.6  默认支持python版本\n# python 2.7.x python-2.7.9 python-2.7.10 python-2.7.13 python-2.7.14 python-2.7.15 # python 3.x python-3.4.3 python-3.5.3 python-3.6.0 python-3.6.1 python-3.6.2 python-3.6.3 python-3.6.4 python-3.6.5 python-3.6.6 python-3.7.0  高级构建选项 在构建高级设置或构建源处启用高级构建特性\n   环境变量 默认值 说明     BUILD_PIP_INDEX_URL https://pypi.tuna.tsinghua.edu.cn/simple Pypi源    Django 静态文件支持 由于 Django 的静态文件支持（CSS、图片等）不是很容易配置而且不方便调试，这里给出一个示例：\nsettings.py\n# Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/1.7/howto/static-files/ BASE_DIR = os.path.dirname(os.path.abspath(__file__)) STATIC_ROOT = 'staticfiles' STATIC_URL = '/static/' STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'), )  默认情况下系统会在构建 Django 应用时自动执行以下命令尝试检测（\u0026ndash;dry-run）静态文件配置是否正确：\n$ python manage.py collectstatic --dry-run --noinput  如果此命令没有出错，将执行真正的命令拷贝静态文件到 STATIC_ROOT 目录：\n$ python manage.py collectstatic --noinput  用户可以手工禁用上述特性，只需要在应用的环境变量里配置 BUILD_DISABLE_COLLECTSTATIC 的值为 1。\n示例demo程序 示例https://github.com/goodrain/python-demo\n参考文档： 具体细节请查看 Django 文档的 [Managing static files](https://docs.djangoproject.com/en/1.7/howto/static-files/) 和[Deploying static files](https://docs.djangoproject.com/en/1.7/howto/static-files/) 章节。 ### 7.1 安装 Whitenoise ```bash $ pip install whitenoise ... $ pip freeze  requirements.txt ``` **settings.py** ```python # Simplified static file serving. # https://warehouse.python.org/project/whitenoise/ STATICFILES_STORAGE = 'whitenoise.django.GzipManifestStaticFilesStorage' ``` **wsgi.py** ```python from django.core.wsgi import get_wsgi_application from whitenoise.django import DjangoWhiteNoise application = get_wsgi_application() application = DjangoWhiteNoise(application) ``` -- "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/php/",
	"title": "PHP",
	"tags": [],
	"description": "PHP语言类型Rainbond支持规范介绍",
	"content": " PHP语言识别策略 平台默认会根据源码根目录是否有index.php 文件或者 composer.json来识别为PHP项目.\n平台编译运行机制  预编译处理会探测是否定义了启动命令配置文件Procfile,如果未定义会生成默认War包启动配置文件; 预编译处理完成后,会根据语言类型选择PHP的buildpack去编译项目.在编译过程中会安装定义的PHP版本,安装相关依赖包; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  # 安装依赖包，解决依赖关系 composer install --no-dev --prefer-dist --optimize-autoloader --no-interaction  PHP项目源码规范 在此步骤中，你需要提供一个可用的PHP源码程序用来部署在Rainbond平台上,此应用程序至少需要满足如下条件:\n 本地可以正常运行的PHP程序 源码程序必须托管在gitlab等相关git或者svn服务上 源码程序根目录下必须需要存在php文件 源码程序根目录下必须存在composer.json,用来管理PHP项目的依赖,也是Rainbond识别为PHP语言的必要条件,同时文件中必须定义项目需要的php版本，定义方式见下文。 源码程序项目根目录下必须存在composer.lock文件\n 源码程序项目根目录下需要定义Procfile,用来定义程序启动方式  Procfile规范 如果项目未定义Procfile文件,平台默认会生成默认Procfile来运行PHP。\n# apache (默认) web: vendor/bin/heroku-php-apache2 # nginx web: vendor/bin/heroku-php-nginx  上述是默认Procfile,如果需要扩展,可以自定义Procfile。\nComposer文件 默认源码根目录需要存在composer.json和composer.lock文件, 即使应用程序没有Composer依赖项，它也必须至少包含一个空（{}）。composer.lock其中可以通过如下命令生成\ncomposer update --ignore-platform-reqs  PHP应用程序可以使用Composer安装的依赖项,通常会将依赖项安装到`vendor/`目录，但是部分项目会重新定义这个目录，执行`composer config vendor-dir`配置正确的路径。大多数情况下避免本地安装影响，通常需要将Composer `vendor`目录添加到你的`.gitignore` 当在composer.json中定义了verndor-dir时需注意,需要自行定义Procfile否则会导致应用无法正常运行，Procfile格式类似`web: /heroku/heroku-buildpack-php/bin/heroku-php-apache2` ```json \"config\" : { \"vendor-dir\": \"lib/composer\", \"optimize-autoloader\": true }, ```  编译运行环境设置 平台提供了不同的PHP版本，您可以使用PHP，HHVM(PHP代码编译器)，或者同时使用二者，通过HHVM提高PHP性能。\nPHP版本支持  PHP 5.5.38 (5.5.38) PHP 5.6.35 (5.6.35) PHP 7.0.29 (7.0.29) PHP 7.1.16 (7.1.16)  可以通过composer.json文件来指定上述支持的PHP或HHVM版本\n{ \u0026quot;require\u0026quot;: {\u0026quot;php\u0026quot;: \u0026quot;5.6.35\u0026quot;} }  PHP 的版本支持 ~5.5.35 这种 [Semantic Versioning](http://semver.org/) 的形式，如果用户指定~5.5.35系统会从平台中选择5.5分支版本最高的版本，因此会选择5.5.35版本。  扩展支持 PHP 5.6 在Rainbond上自动启用以下内置扩展(此列表不包括默认情况下PHP启用的扩展，例如DOM，JSON，PCRE或PDO):\n Bzip2\n cURL FPM mcrypt MySQL (PDO) (uses mysqlnd) MySQLi (uses mysqlnd) OPcache OpenSSL PostgreSQL PostgreSQL (PDO) Readline Sockets Zip Zlib  以下内置扩展已经构建为“共享”，可以通过composer.json（括号中给出的内部标识符名称）启用：\n BCMath (bcmath) Calendar (calendar) Exif (exif) FTP (ftp) GD (gd; with PNG, JPEG and FreeType support) GMP (gmp) gettext (gettext) IMAP (imap; with SASL and Kerberos support) intl (intl) LDAP (ldap; with SASL support) mbstring (mbstring) MySQL (mysql; note that this extension is deprecated since PHP 5.5, please migrate to MySQLi or PDO) PCNTL (pcntl) Shmop (shmop) SOAP (soap) SQLite3 (sqlite3) SQLite (PDO) (pdo_sqlite) XMLRPC (xmlrpc) XSL (xsl)  可以通过composer.json启用以下第三方扩展（括号中给出的内部标识符名称）：\n APCu (apcu; provides an apc extension for compatibility with legacy software) Blackfire (blackfire) Cassandra (cassandra) ev (ev) event (event) ImageMagick (imagick) memcached (memcached; built against a version of libmemcached with SASL support) Mongo (mongo) MongoDB (mongodb) New Relic (newrelic; will automatically be enabled when the New Relic Add-On is detected during a build) OAuth (oauth) Phalcon (phalcon) pq (pq) rdkafka (rdkafka) PHPRedis (redis)  PHP 7.0 在Rainbond上自动启用以下内置扩展(此列表不包括默认情况下PHP启用的扩展，例如DOM，JSON，PCRE或PDO):\n Bzip2\n cURL FPM MySQL (PDO) (uses mysqlnd) MySQLi (uses mysqlnd) OPcache OpenSSL PostgreSQL PostgreSQL (PDO) Readline Sockets Zip Zlib  以下内置扩展已经构建为“共享”，可以通过composer.json（括号中给出的内部标识符名称）启用：\n BCMath (bcmath) Calendar (calendar) Exif (exif) FTP (ftp) GD (gd; with PNG, JPEG and FreeType support) GMP (gmp) gettext (gettext) IMAP (imap; with SASL and Kerberos support) intl (intl) LDAP (ldap; with SASL support) mbstring (mbstring) mcrypt (mcrypt) PCNTL (pcntl) Shmop (shmop) SOAP (soap) SQLite3 (sqlite3) SQLite (PDO) (pdo_sqlite) XMLRPC (xmlrpc) XSL (xsl)  可以通过composer.json启用以下第三方扩展（括号中给出的内部标识符名称）：\n APCu (apcu; provides an apc extension for compatibility with legacy software) Blackfire (blackfire) Cassandra (cassandra) ev (ev) event (event) ImageMagick (imagick) memcached (memcached; built against a version of libmemcached with SASL support) MongoDB (mongodb) New Relic (newrelic; will automatically be enabled when the New Relic Add-On is detected during a build) OAuth (oauth) Phalcon (phalcon) pq (pq) rdkafka (rdkafka) PHPRedis (redis)  PHP 7.1 在Rainbond上自动启用以下内置扩展(此列表不包括默认情况下PHP启用的扩展，例如DOM，JSON，PCRE或PDO):\n Bzip2\n cURL FPM MySQL (PDO) (uses mysqlnd) MySQLi (uses mysqlnd) OPcache OpenSSL PostgreSQL PostgreSQL (PDO) Readline Sockets Zip Zlib  以下内置扩展已经构建为“共享”，可以通过composer.json（括号中给出的内部标识符名称）启用：\n BCMath (bcmath) Calendar (calendar) Exif (exif) FTP (ftp) GD (gd; with PNG, JPEG and FreeType support) GMP (gmp) gettext (gettext) IMAP (imap; with SASL and Kerberos support) intl (intl) LDAP (ldap; with SASL support) mbstring (mbstring) mcrypt (mcrypt) PCNTL (pcntl) Shmop (shmop) SOAP (soap) SQLite3 (sqlite3) SQLite (PDO) (pdo_sqlite) XMLRPC (xmlrpc) XSL (xsl)  可以通过composer.json启用以下第三方扩展（括号中给出的内部标识符名称）：\n APCu (apcu; provides an apc extension for compatibility with legacy software) Blackfire (blackfire) Cassandra (cassandra) ev (ev) event (event) ImageMagick (imagick) memcached (memcached; built against a version of libmemcached with SASL support) MongoDB (mongodb) New Relic (newrelic; will automatically be enabled when the New Relic Add-On is detected during a build) OAuth (oauth) Phalcon (phalcon) pq (pq) rdkafka (rdkafka) PHPRedis (redis)  Composer是PHP的依赖管理器，composer.json则是Composer的配置文件，强烈建议使用 “*” 来标识扩展包的版本号。  ##### 第三方扩展 以下第三方扩展可以通过 composer.json 开启（包名已在括号内给出）： - [APCu(apcu)](http://pecl.php.net/package/apcu)(apcu) - [ImageMagick(imagick)](http://docs.php.net/imagick)(imagick) - [memcached](http://docs.php.net/memcached)(memcached) - [MongoDB](http://docs.php.net/mongo)(mongo) - [New Relic](http://newrelic.com/php)(newrelic) - [PHPRedis](http://pecl.php.net/package/redis)(redis) - [Yaf](http://pecl.php.net/package/yaf)(yaf) - [Phalcon](http://phalconphp.com/)(phalcon) ##### 扩展特例 官方出品过2个mongodb的扩展，一个叫mongo，一个是mongodb。前者已经被官方废弃，不再提供稳定的更新，官方推荐使用后者，并且后者是支持php7的。所以在使用mongodb扩展时，需要在composer.json中指定扩展为mongodb。 ```json { \"require\": { \"php\": \"~7.1.16\", \"ext-memcached\": \"*\", \"ext-mongodb\": \"*\", \"ext-mbstring\": \"*\" } } ``` 更多细节扩展支持说明请参考：不同版本PHP扩展支持说明  -- 示例demo程序 示例https://github.com/goodrain/php-demo\n推荐阅读  自定义Web Server与PHP环境 Procfile文件说明  系统会在每次运行的时候使用`composer self-update` 将Composer自动更新到最新版本。  ## 六、配置启动命令 云帮支持 [Apache](http://httpd.apache.org/)，如果您在Profile文件中没有设置加载其中任一服务器，或代码根目录没有 Procfile 文件，应用创建向导会提示用户选择Apache作为Web服务器。 ### Apache服务器 Apache接口与PHP-FPM或HHVM通过FastCGI使用 `mod_proxy_fcgi`。  名词释义：   **FastCGI**：快速网关接口，是一种让交互程序与Web服务器通信的协议，早期通用网关接口(CGI)的增强版本   **PHP-FPM**：是一个FastCGI管理器，旨在将FastCGI进程管理整合进**PHP**包中   **HHVM**：PHP代码编译器 在您代码的根目录下创建 Procfile 文件，填写以下内容来开启 PHP-FPM： ```bash web: vendor/bin/heroku-php-apache2 ``` 如果要运行 HHVM 的话，Procfile 内容如下： ```bash web: vendor/bin/heroku-hhvm-apache2 ``` 您可以通过 .htaccess 文件来自定义 Apache 的行为，也可以使用自定义 Apache 配置文件的方式。例如； 将以下内容保存在根目录下命名为 apache_app.conf： ```bash RewriteEngine On RewriteCond %{REQUEST_URI}::$1 ^(/.+)/(.*)::\\2$ RewriteRule ^(.*) - [E=BASE:%1] RewriteCond %{ENV:REDIRECT_STATUS} ^$ RewriteRule ^app\\.php(/(.*)|$) %{ENV:BASE}/$2 [R=301,L] RewriteCond %{REQUEST_FILENAME} -f RewriteRule .? - [L] RewriteRule .? %{ENV:BASE}/app.php [L] ``` 然后修改 Procfile 文件加载此配置： ```bash web: vendor/bin/heroku-php-apache2 -C apache_app.conf ``` ### 5.2 Nginx Nginx 使用 FastCGI 连接 PHP-FPM，使用下面的 Procfile 开启 Nginx： ```bash web: vendor/bin/heroku-php-nginx ``` 如果要运行 HHVM 的话，Procfile 内容如下： ```bash web: vendor/bin/heroku-hhvm-nginx ``` Nginx 服务器同样支持自定义配置，以下是一个 URL 重写的例子： ```bash location / { # try to serve file directly, fallback to rewrite try_files $uri @rewriteapp; } location @rewriteapp { # rewrite all to app.php rewrite ^(.*)$ /app.php/$1 last; } location ~ ^/(app|app_dev|config)\\.php(/|$) { fastcgi_pass heroku-fcgi; fastcgi_split_path_info ^(.+\\.php)(/.*)$; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param HTTPS off; } ``` 将其保存在根目录下命名为为 nginx_app.conf ，修改 Procfile 文件为以下内容即可： ```bash web: vendor/bin/heroku-php-nginx -C nginx_app.conf ``` -- "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/netcore/",
	"title": ".NetCore",
	"tags": [],
	"description": ".NetCore语言类型Rainbond支持规范介绍",
	"content": " .NetCore语言类型识别策略 代码主目录中包含以.sln或者.csproj结尾的文件并且不包含Dockerfile文件时，平台识别项目语言类型为.NetCore\n目前仅支持单项目代码维护形式，如果你一个代码仓库维护了多个 Project, 例如一个微服务架构，那么首先建议你将每个 Project 分离到不同仓库或同个仓库不同二级目录下。  代码规范 源码主目录必须具有Procfile 文件定义服务启动方式，详见项目运行部分\n编译原理 对于.NetCore语言的支持与Dockerfile一样将构建出镜像而不是slug程序包，因此.NetCore不能使用Procfile文件定义。\nNetCore语言构建过程默认使用`microsoft/dotnet:2.2-sdk-alpine` 编译镜像和`microsoft/dotnet:2.2-aspnetcore-runtime`运行环境镜像，若设置其他版本同理。若你未提前下载镜像在构建过程容易出现拉取镜像失败的错误。强烈建议先在Rainbond管理节点提前手动获取上诉镜像。  如果你的源码对系统环境有依赖，需要单独安装系统类库，目前无法直接使用Rainbond提供的默认编译环境编译，你可以采用直接定义[Dockerfile](../dockerfile)的方式支持。  编译环境选择 当前版本平台默认使用 microsoft/dotnet:2.2-sdk-alpine 镜像环境进行源码编译。你可以根据需要设置编译环境版本，可选版本目前还包括包括：\n 3.0-sdk 2.1-sdk  设置服务环境变量 BUILD_DOTNET_SDK_VERSION=3.0-sdk 即可选择构建环境版本。\n编译方式设置 默认编译方式如下：\ndotnet restore dotnet publish -c Release  若需要在dotnet restore之前执行的命令可以通过 BUILD_DOTNET_RESTORE_PRE环境变量指定。\n若需要改变默认的 dotnet restore命令可以通过BUILD_DOTNET_RESTORE 环境变量指定。比如设置如下环境变量：\nBUILD_DOTNET_RESTORE_PRE=dotnet restore --ignore-failed-sources  关于环境变量的设置参考 服务环境变量\n项目运行 运行环境选择 通常情况下运行环境与编译环境版本一致，当前版本默认提供的运行环境是microsoft/dotnet:2.2-aspnetcore-runtime，可选的运行环境版本为：\n 3.0-aspnetcore-runtime\n 2.1-aspnetcore-runtime\n  通过设置环境变量BUILD_DOTNET_RUNTIME_VERSION 设置你需要的版本\n编译的结果文件存放于运行环境的/app目录下。由于平台咱无法很好的感知项目的入口运行文件，需要在源码主目录中定义rainbondfile定义项目的运行启动方式，例如：\nports: - port: 5000 procotol: http cmd: dotnet aspnetapp.dll  ports定义项目监听的端口（必须监听泛地址 *或者0.0.0.0）\ncmd定义项目启动方式，根据项目 publish 后生成的入口运行文件为准。\n示例代码 https://github.com/goodrain-apps/dotnet-demo\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/golang/",
	"title": "Golang",
	"tags": [],
	"description": "Golang语言类型Rainbond支持规范介绍",
	"content": " Golang语言识别方式 平台默认会根据源码根目录是否有go.mod或Gopkg.lock或glide.yaml或src目录含有go文件来识别为Golang项目.\n编译原理  预编译处理完成后,会根据语言类型选择Go的buildpack去编译项目.在编译过程中会安装定义的Golang版本; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  Golang项目源码规范 在此步骤中，你需要提供一个可用的Go源码程序用来部署在Rainbond平台上,此应用程序至少需要满足如下条件:\n 本地可以正常运行的go build,go run 源码程序必须托管在gitlab等相关git或者svn服务上 在根目录的/Godeps目录下有Godeps.json文件，标识应用由godep管理;在根目录的/vendor目录下有Govendor.json文件，标识应用由govendor管理;在根目录的/src目录下包含\u0026lt;文件名\u0026gt;.go文件，标识应用由gb管理。  Procfile规范 必须定义Procfile\nweb: hello  1. `web:`和`hello`之间有一个空格 2. 文件结尾不能包含特殊字符 3. `hello`为编译后的二进制  编译运行环境设置 配置Golang版本 主流支持版本 go1.10.5,go1.11.2，云帮默认版本 go1.11.2。\n#支持版本 go1.9.7 go1.8.7 go1.11.2 go1.11 go1.11.1 go1.10.5 go1.10.4  Go Tools版本  Dep 默认支持版本v0.4.1 Glide 默认支持版本v0.12.3 Govendor 默认支持版本v1.0.8 GB 默认支持版本 0.4.4 PkgErrors 默认支持版本 0.8.0 HG 默认支持版本3.9 TQ 默认支持版本v0.5 MattesMigrate 默认支持版本v3.0.0  示例demo程序 示例https://github.com/goodrain/go-demo\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/html/",
	"title": "静态HTML",
	"tags": [],
	"description": "静态Html语言类型Rainbond支持规范介绍",
	"content": " 静态HTML识别策略 平台默认会根据源码根目录是否有index.html文件来识别为静态语言项目.\n编译原理  预编译处理完成后,会根据语言类型选择static的buildpack去编译项目.在编译过程中会安装定义的Web服务Nginx或者Apache; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  静态语言项目源码规范  源码程序必须托管在gitlab等相关git或者svn服务上 源码根目录需要存在index.html文件  Procfile规范 如果未定义Procfile，会生成如下默认Procfile\nweb: sh boot.sh  Web服务支持  默认使用最新稳定版本Nginx\n 自定义Nginx配置 需要在源码根目录定义nginx配置文件：web.conf,默认配置文件为\nserver { listen 80; location / { root /app/www; index index.html index.htm; } }  示例代码  静态Html示例代码  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/nodejs/",
	"title": "Node.JS",
	"tags": [],
	"description": "NodeJS语言类型Rainbond支持规范介绍",
	"content": " Rainbond 5.1版本已支持源码部署NodeJS前端类项目，你可以直接在Rainbond发布Vue, React, Angular等项目 查看文档： 部署NodeJS前端项目到Rainbond  NodeJS语言识别规范 平台默认会根据源码根目录是否有package.json来识别为NodeJS项目.\n平台编译运行机制  预编译处理会探测是否定义了启动命令配置文件Procfile,如果未定义会读取package.json文件中的script.start值来生成启动配置文件; 预编译处理完成后,会根据语言类型选择nodejs的buildpack去编译项目.在编译过程中会安装定义的Node版本以及Nodejs相关依赖; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  NodeJS项目源码规范 在此步骤中，你需要提供一个可用的NodeJS源码程序用来部署在Rainbond平台上,此应用程序至少需要满足如下条件:\n 本地可以正常运行的NodeJS项目 源码程序必须托管在gitlab等相关git或者svn服务上 源码程序根路径下必须存在package.json,用来管理NodeJS项目的依赖,也是Rainbond识别为NodeJS语言的必要条件  Procfile规范 如果项目未定义Procfile文件,平台会根据package.json文件中的script.start值来生成默认Procfile。\nweb: npm start  上述是默认Procfile,如果需要扩展更多启动参数,可以自定义Procfile。\n1. `web:`和`npm`之间有一个空格 2. 文件结尾不能包含特殊字符  编译运行环境设置 Node版本支持 当前Rainbond支持Node如下版本为：\n4.9.1 5.12.0 6.14.4 7.10.1 8.12.0 9.11.2 10.13.0 11.1.0  平台默认版本使用8.12.0。可以在 package.json 里使用 engines 指定版本：\n{ \u0026quot;name\u0026quot;: \u0026quot;myapp\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;a really cool app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;engines\u0026quot;: { \u0026quot;node\u0026quot;: \u0026quot;4.8.7\u0026quot; } }  0.8.5 之后的版本包括 0.11.13 也是支持的，以下是使用 0.11.x 版本的例子：\n{ \u0026quot;engines\u0026quot;: { \u0026quot;node\u0026quot;: \u0026quot;0.11.x\u0026quot; } }  npm 版本不是必须的，可以省略，因为 npm 是跟 node 绑定的。  依赖包安装 Node项目支持使用npm package manager 和 yarn package manager 安装依赖包，如果存在yarn.lock 文件，使用yarn(默认支持版本1.9.4)安装依赖和运行脚本，否则使用npm。\n yarn定义方式\n{ \u0026quot;engines\u0026quot;: { \u0026quot;yarn\u0026quot;: \u0026quot;1.9.4\u0026quot; } }   自定义构建脚本 如果您的应用在构建时需要执行额外的操作，可以在 package.json 的 scripts 节点下添加 postinstall 脚本，该脚本会在 buildpack 执行完 npm install —production 后自动执行，可参考package.json 示例：\n{ \u0026quot;name\u0026quot;: \u0026quot;node-hello\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;nodejs demo\u0026quot;, \u0026quot;dependencies\u0026quot; : { \u0026quot;bower\u0026quot;: \u0026quot;~1.3.9\u0026quot;, \u0026quot;grunt-cli\u0026quot;: \u0026quot;~0.1.13\u0026quot;, }, \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;node index.js\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;mocha\u0026quot;, \u0026quot;postinstall\u0026quot;: \u0026quot;bower install \u0026amp;\u0026amp; grunt build\u0026quot; }, \u0026quot;engines\u0026quot;: { \u0026quot;node\u0026quot;: \u0026quot;9.3.0\u0026quot; } }  系统默认不自带 grunt、gulp、bower 这些工具，但是会安装 `package.json` 中 `dependencies` 和`devDependencies` 节点下的依赖，所以自定义执行的命令也需要作为依赖添加到此节点下，否则可能会找不到命令，这些工具执行时需要的依赖也是如此。  示例demo程序 示例https://github.com/goodrain/nodejs-demo\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/nodejs-static/",
	"title": "NodeJS前端语言",
	"tags": [],
	"description": "NodeJS前端语言类型Rainbond支持规范介绍, 部署Vue React Angular源码部署到Rainbond",
	"content": " NOdeJS前端项目识别方式 平台默认会根据源码根目录是否有package.json和nodestatic.json文件来识别为NodeJS前端类项目.\n编译原理  预编译处理完成后,会根据语言类型选择nodejstatic的buildpack去编译项目.在编译过程中会安装定义的Node版本以及Nodejs相关依赖,安装默认web服务nginx; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  NodeJS前端项目源码规范 在此步骤中，你需要提供一个可用的NodeJS源码程序用来部署在Rainbond平台上,此应用程序至少需要满足如下条件:\n 本地可以正常运行的NodeJS项目 源码程序必须托管在gitlab等相关git或者svn服务上 源码程序根路径下必须存在package.json,用来管理NodeJS项目的依赖,是Rainbond识别为NodeJS前端类语言的必要条件 代码的根目录下必须有nodestatic.json文件，是Rainbond识别为NodeJS前端类语言的必要条件  nodestatic.json规范 用于定义NodeJS编译后文件路径。\n# cat nodestatic.json {\u0026quot;path\u0026quot;:\u0026quot;\u0026lt;编译后路径\u0026gt;\u0026quot;}  Procfile规范 如果未定义Procfile，会生成如下默认Procfile\nweb: sh boot.sh  上述是默认Procfile,如果需要扩展更多启动参数,可以自定义Procfile。\n1. `web:`和`sh`之间有一个空格 2. 文件结尾不能包含特殊字符  编译运行环境设置 Node版本支持 当前Rainbond支持Node如下版本为：\n4.9.1 5.12.0 6.14.4 7.10.1 8.12.0 9.11.2 10.13.0 11.1.0  平台默认版本使用8.12.0,具体配置参考NodeJS源码构建\nWeb服务支持 Web默认支持Nginx,目前Nginx版本为1.14.2。如果需要自定义配置Nginx，需要在源代码根目录添加web.conf或者www/web.conf(需要符合Nginx配置文件语法)。\n默认配置文件web.conf\nserver { listen 80; location / { root /app/www; index index.html index.htm; } }  示例demo程序 示例https://github.com/goodrain/rainbond-ui\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/thirdparty-service/",
	"title": "第三服务规范",
	"tags": [],
	"description": "",
	"content": " 第三方服务规范 本章内容包括第三方服务的定义和创建方式：\n 第三方服务定义  Rainbond对第三方服务支持说明\n 第三方服务支持原理  讲解Rainbond支持第三方服务的支持原理\n 第三方服务创建  讲解Rainbond支持第三方服务的创建方式和流程\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-manage/",
	"title": "应用管理",
	"tags": [],
	"description": "",
	"content": "本章内容包括：\n 基础操作  讲述Rainbond应用的基础操作\n 添加服务组件  讲解为应用便捷的添加服务组件说明文档\n 应用分享与发布  讲解Rainbond应用发布到应用市场功能说明\n 应用升级  从应用市场安装的应用升级到新版本\n 应用备份管理  Rainbond应用全量备份、迁移和恢复\n 应用拓扑图  展现应用包含的所有服务的网络关系、业务关系和业务逻辑\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-manage/operation/",
	"title": "基础操作",
	"tags": [],
	"description": "讲述Rainbond应用的基础操作",
	"content": " 支持的基础操作    操作类型 条件 说明     启动 当前应用下服务处于关闭状态 启动当前应用的内置服务   停止 当前应用全部处于运行中状态 关闭当前应用的所有服务   构建 - 为应用下的所有服务构建新版本并升级    应用级的基础操作与服务的批量操作有如下区别：\n   对比项 服务批量操作 应用基础操作     启动控制 批量无序启动 根据依赖关系顺序启动   操作目标 用户指定的服务 应用下的所有服务   支持的操作类型 关闭、重启、启动、移动、删除 构建、启动、停止    应用的其他操作  备份、恢复与迁移 详细文档 发布到应用市场 详细文档 添加服务组件 详细文档  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-manage/add-service/",
	"title": "添加服务组件",
	"tags": [],
	"description": "讲解为应用便捷的添加服务组件说明文档",
	"content": " 添加服务组件说明 应用由一个或多个服务组件组成，一般在创建第一个服务组件的过程中创建了应用。后续的应用组装过程中，直接为应用添加组件将是最便捷的途径。添加服务组件分为两类：\n 添加内置服务  添加服务的流程与服务创建流程完全一致，同样支持基于源代码、Docker镜像和云市应用三种途径。唯一的不同是不提供基于DockerCompose创建多个服务的方式。\n 添加第三方服务  添加第三方服务 便捷的添加运行于集群外的服务，同样支持添加静态服务和动态服务。\n\u0008\n流程演示\n处理依赖关系 添加的服务一般需要被其他服务依赖或依赖其他服务，只需要进入拓扑图的编辑模式 ，将服务直接单向连线即可快捷建立依赖关系。\n关于为什么需要建立依赖关系，查看文档 服务依赖关系\n开启外网访问 如果添加的服务需要被外网访问，添加成功后有两种方式，第一种是通过 拓扑图的编辑模式将外网云朵模型与服务建立连线即可。第二种是通过应用网关 访问策略管理 添加访问策略。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/",
	"title": "服务管理",
	"tags": [],
	"description": "",
	"content": "本章内容包括：\n 服务基础属性说明  Rainbond基础属性的说明文档\n 服务基础操作  Rainbond服务基础生命周期操作说明文档\n 日志管理  Rainbond服务日志的查询和管理\n 性能分析  Rainbond服务性能分析功能解读\n 服务伸缩  Rainbond服务的水平伸缩和垂直伸缩文档\n 服务依赖  Rainbond服务依赖关系和依赖连接信息管理\n 服务存储设置  Rainbond服务存储的管理文档\n 服务端口  Rainbond服务端口和注册策略管理文档\n 应用持续构建与部署  Rainbond服务进行持续构建与部署（自动CI/CD）文档\n 服务插件  Rainbond服务插件管理和配置文档\n 服务构建源设置  Rainbond服务的构建源设置和各语言编译参数配置文档\n 服务版本管理  Rainbond服务版本的管理和版本回滚文档\n 服务其他设置  Rainbond服务基础信息，环境变量，健康检测，用户权限等属性的设置文档\n 高级环境变量配置  Rainbond服务高级环境变量配置文档\n 服务容器终端  Rainbond服务运行容器终端的进入和操作方式文档\n 第三方服务管理  讲解第三方服务类型的管理操作\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-properties/",
	"title": "服务基础属性说明",
	"tags": [],
	"description": "Rainbond基础属性的说明文档",
	"content": " 本文讲解与应用相关的属性及名词，从而让你更清晰的了解应用的概念。\n应用的状态 应用一旦创建，就进入到应用的生命周期，在整个生命周期中会有一系列的状态，下文对各个状态进行解释：\n   应用状态 说明 可进行的操作     创建中  新创建的应用，正处于设置阶段 进行创建流程   部署中  新创建的应用设置完成，正在进行第一次应用版本构建 重新部署   启动中  应用正在启动，暂时不能访问，启动分为两个阶段，进程启动和业务启动，如果未配置启动时健康检查，只要进程启动完成则认 为应用启动完成   运行中  应用所有运行实例处于运行状态，正常来说处于运行中的应用可以被访问，也可能由于业务启动缓慢应用暂时不能访问 访问，重启，关闭，重新部署   运行异常  应用运行正常的实例少于总实例即标识应用运行异常，对于多实例的应用，处于异常态的应用只要还有正常的实例即可提供服务。\n实例异常大多数情况是由于应用本身异常退出或因为内存不足发生 OOM 退出。\n平台会自动尝试重启异常的实例。\n可通过查看应用日志，或通过命令行工具查看更多应用信息 关闭，重启，重新部署   升级中 应用正处于滚动更新过程中，多个节点处于当前状态的应用可以正常访问 关闭   已关闭 应用已经停止运行，持久化数据依然存在 启动，重新部署   未知 应用处于此状态可能由于网络受阻，请求后端服务获取应用状态失败，或后端服务异常\n可以尝试刷新页面，如果不能解决，请联系运维同事。     应用的版本 针对不同类型的应用，版本的标示也有所不同：\n   应用类型 版本信息 示例     源码构建 从代码仓库拉取代码构建应用的时间戳 20180803171811   Docker镜像 镜像tag信息 1.15.2-alpine   云市应用 应用版本 5.6.7    "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/basic-operation/",
	"title": "服务基础操作",
	"tags": [],
	"description": "Rainbond服务基础生命周期操作说明文档",
	"content": " 服务基本操作 先就服务可进行的操作进行基础说明：\n   基础操作 说明     构建 构建操作将触发服务从构建源获取最新的代码或镜像构建服务的新版本，默认情况下构建成功后将触发滚动升级。   更新（滚动升级） 更新操作将以最新的服务属性配置对集群中运行的服务实例进行滚动升级   启动 具有至少一个可用构建版本的服务可以启动   停止 服务停止即释放所有集群资源   访问 运行中的服务可进行访问，如是HTTP服务将跳转访问网址，非HTTP   管理容器 运行中的服务可进行管理容器操作，选择需要操作的容器实例即可进入容器Web终端控制   重启 运行中的服务可进行重启操作，正常情况下我们推荐使用更新操作来完成服务重启，若服务任何属性都未变化，无法使用更新。   修改所属应用 服务可以灵活调整所属的应用   删除 删除服务是一个危险的操作，请谨慎操作。服务删除后持久化数据默认会保留7天。    构建操作  适用场景：服务的任何状态\n 针对不同类型的服务，触发 构建 操作后，有着不同的含义，下表针对不同类型的服务加以说明：\n   服务类型 说明     从源代码构建的服务 拉取最新源代码，根据预先识别的语言类型进行服务版本构建并进行滚动升级   从Docker镜像构建的服务 重新拉取指定镜像地址的镜像，构建出服务新版本并进行滚动升级   从云市应用构建的服务 若云市应用不存在更新的版本，构建操作将提醒用户无需操作，若已存在多个更新版本，将提示用户选择需要获取的版本号。根据所选版本获取服务介质生成构建版本并进行滚动升级    - Dockerfile 源码类服务就是将 Dockerfile 及所需要的文件放到 代码仓库（Git/Svn），通过源代码创建的服务。 - 构建后，如果一切顺利，服务会自动切换为新版本并上线，构建操作默认并更新升级，也可在其他设置中去设置构建后不升级流程。 - 滚动升级过程对于多节点的服务理论上无影响，对于单节点的服务如果正常配置了业务级的[健康检测](/user-manual/app-service-manage/service-other-set/#健康检查) 也可以做到无影响升级。 - 处于关闭状态的服务，触发构建操作后，如果构建正常，平台会将服务运行起来。  云市服务升级支持的属性 在对云市服务进行升级的时候, 并不是所有的属性都支持升级; 在升级的时候, 各种属性的处理方式又会有所区别. 具体如下表所示:\n   属性 是否支持升级 元数据（升级方式） 说明     实例可选项 是 更新    内存可选项 是 更新    依赖关系 是 增加 如果依赖的服务在同一个应用内, 则增加依赖关系; 否则不进行处理   端口 是 更新, 增加 对于端口的升级, 可以更新已有的端口信息, 也可以增加新的端口; 但是不能删除已有的端口   存储 是 增加 对于存储的升级, 只能增加新的存储; 不能对已有的存储进行删除, 或修改   健康检测 是 更新 对于健康检测的升级, 修改已有的健康检测信息, 不能删除, 或增加(一个服务只能有一个健康检测信息)   镜像 是 更新 直接更改为新的镜像   环境变量 是 增加 对环境变量的升级, 只支持增加新的环境变量; 不能修改, 或删除已有的环境变量   启动参数 是 更新    依赖存储 是 如果依赖的存储所在的服务在同一个应用内, 则增加依赖关系; 否则不进行处理    有无状态类型 否     标签 否      更新操作  使用场景：运行中服务\n 当服务的依赖、存储、环境变量、特性、健康监测等运行属性发生改变以后，\u0008必须通过手工触发更新操作来将最新的属性配置应用的服务的运行环境中，在这更新过程中默认采用滚动升级的策略对服务实例进行升级。\n对于滚动升级有两类控制策略：\n 无状态服务  对无状态服务采用的是无序的先启动后停止的策略，即先启动新版本的运行实例，当其处于健康运行状态后关闭旧版本运行实例。需要注意的是，此过程会出现多版本同时工作的情况，若你的业务服务无法容忍多版本同时工作，请使用重启策略。\n 有状态服务  对于有状态服务采用的是有序的先关闭后停止策略，即根据运行实例编号，从第一个实例开始先关闭实例然后启动新版本实例。\n这种控制对于像数据库类的服务至关重要，因此请勿将数据库类服务部署为无状态服务。  启动操作  使用场景：构建成功，并处于关闭状态的服务\n 启动操作会启动上一次成功构建的服务版本，启动后可以在服务概览页面的 操作日志 看到平台调度与处理服务的详细操作日志，当调度完成后，服务就进入启动阶段，这时候可以通过 日志 页面查看服务的启动日志。\n特别是对于第一次在Rainbond启动的服务，尤其需要关注如下几点：\n 服务启动或更新超时怎么办？   目前Rainbond对于异步任务确定了固定的超时时间，因此请注意，超时并不是失败，需要根据实际情况优化服务的配置，如果有超时，请按如下路径进行排查：\n 查询服务日志 确定服务的启动情况，若你的服务日志未输出到stdout或stderr,请进入服务容器查询你的日志。比如一些Java类的服务，若分配的内存不足将导致启动非常缓慢, 亦或者从日志中发现服务运行环境是否正常，比如依赖了数据库，是否能够正常访问数据库等。 如果源码构建的服务在启动后很长时间才进入正常的业务启动过程，请优化代码忽略掉多余的源代码文件减少运行代码解压时间 参考 slugignore文件使用方式 确定服务监听的地址不是127.0.0.1 或 localhost 若服务监听地址正确且已正常监听，请查询 服务健康检测 配置是否正确，一般若服务有多个端口时容易出现默认配置错误的问题。 以上服务可能的故障如都已排除还是启动超时且一直处于启动中状态，请通过运维工具 grctl cluster 和 grctl service get \u0026lt;service_name\u0026gt; -t \u0026lt;tenant_name\u0026gt; 查询集群和服务运行实际状态。    服务运行异常怎么办？   服务运行异常是指服务进程异常的退出了，一般有几下几种原因：\n 服务代码故障，无法正常运行 服务使用了不支持的镜像，比如基础操作系统镜像，无法在前台守护运行。 服务内存分配不足导致OOM 服务健康检查配置错误，导致服务无法通过健康检查。  若是上诉情况，请处理你的服务配置，服务运行过程中如果异常退出Rainbond会自动守护并重新启动你的服务\n  服务无法访问怎么办？   服务无法访问时请查看如下几类原因：\n 服务未正常运行，根据运行状态和服务日志确认 服务端口配置不正确，服务端口配置务必与服务真实监听的端口一致 服务可访问端口未打开对外服务开关 服务未配置正确可访问的域名   关闭操作  使用场景：运行中或运行异常的服务\n 触发关闭操作后，服务将首先从应用网关或ServiceMesh网络下线，然后关闭所有运行实例，释放集群资源。\n重启操作  使用场景：运行中或运行异常的服务\n 触发重启操作后，平台会将现有的服务运行实例全部关闭，待关闭完成后进行启动。若出现关闭超时时 重启操作将退出，服务启动的控制权交予用户。\n- 重启服务并不会更新服务代码或镜像，需要和`构建`操作区分。 - 重启操作会中断服务  访问操作  使用场景：运行中的服务 \u0026amp;\u0026amp; （打开了对外服务 | 对内服务的端口）\n 针对不同协议的服务，点击访问按钮后所触发的命令也不一样：\n   服务协议 点击访问按钮后的操作     HTTP 浏览器新开窗口，打开服务的默认域名，如果绑定多个域名，会显示域名列表供用户选择   TCP 弹出访问信息窗口     HTTP 协议服务   TCP 协议服务  管理容器操作 当需要进入服务的运行环境，查看进程信息、端口监听信息、文件内容或直接Debug源代码的情况下，需要进入服务的容器环境，Rainbond提供了两个入口：\n 服务操作列表中的管理容器操作 服务伸缩管理中的实例列表，点击实例名称即可进入  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-log/",
	"title": "日志管理",
	"tags": [],
	"description": "Rainbond服务日志的查询和管理",
	"content": " 服务日志 Rainbond平台对服务日志采用实时推送的形式展示，用户也可以通过查询历史日志文件查询历史日志。\n服务操作日志 在服务总览页面中呈现服务的操作历史情况以及每次操作的日志记录，特别是构建操作的日志需要注意，当出现构建失败时请查看日志输出的提醒内容以指导用户对代码的不规范性进行改进。\n服务的操作日志也是对服务进行操作的记录，便于多个用户之间的协作和操作审查。\n服务运行日志 服务运行后输出到标准输出(stdout)和标准错误输出(stderr)的日志将被Rainbond捕获并进行汇聚存储，多个实例的日志将统一汇聚到服务级别进行实时展示和存储。\n在日志显示框中用户可以选择容器ID后只查询某个实例的运行日志。我们尽量追求将日志实时推送到控制台，但由于中间处理的原因会有一定的延时。\n我们推荐用户将服务运行日志区分为访问日志和程序Debug日志，访问日志一般具备被统计分析的任务，将其输出到持久化文件，然后对接其他日志分析服务进行日志分析。 程序Debug日志最主要的功能是呈现给开发者快速发现问题。\n在TODO规划中，我们将在日志收集端增加日志分流功能，直接可以对接像ELK等日志分析系统，将日志直接传输到分析系统中进行分析。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-monitor/",
	"title": "性能分析",
	"tags": [],
	"description": "Rainbond服务性能分析功能解读",
	"content": " 性能分析 服务实时性能分析功能依赖于服务开通性能分析类插件完成。 Rainbond目前默认提供了支持HTTP协议和Mysql协议的性能分析插件供用户使用。\n服务性能分析 我们将所有类型的服务的性能情况用三个指标来衡量：\n 响应时间  响应时间也称为延迟，服务一般工作于网络通信的应用层，比如http、mysql、redis、grpc等。服务每次处理一次客户端请求的用时即响应时间。如果我们从网络报文的维度来衡量的话即请求报文第一个包到达到响应报文的第一个包发出中间的时间。\n 吞吐率  吞吐率也称为通讯量，即服务在单位时间内处理请求的次数。\n 错误率  错误有显性错误（比如HTTP 500错误）和隐性错误（比如HTTP返回200然而业务是错误的），这里我们主要关注显形错误，每一种通信协议都有标准的错误类型，比如mysql有查询语句错误。错误率正常情况下与服务的饱和度有密切关系。\n综上所述，实现性能分析时我们有两种思路，一种是在ServiceMesh网络中，代理端会根据不同的协议汇报三类指标，第二种是目前使用的方式，性能分析插件通过旁路的方式监听服务的网络通信，从而直接分析服务上述指标。\n监控效果 性能分析数据持久化的存储于Rainbond monitor组件中，供给客户端查询。在服务监控页面中，我们除了展示监控历史数据以为，还实时的展示http和mysql的请求情况，比如mysql请求的sql语句执行情况。这对于用户进行精细化挑优提供了一个直接的指引。\n更多的协议支持 TODO列表中我们计划支持grpc协议、redis协议、mongodb协议的性能分析。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-scaling/",
	"title": "服务伸缩",
	"tags": [],
	"description": "Rainbond服务的水平伸缩和垂直伸缩文档",
	"content": " 服务伸缩 Rainbond平台服务有两种伸缩方式：\n 垂直伸缩：增加或减少服务的内存（目前服务 CPU 与内存是联动的，按照一定的比例调整） 水平伸缩：增加或减少服务的实例数，适用于无状态服务和有状态水平集群服务  - 垂直伸缩时平台会自动调整资源后重启服务，单节点服务会中断，多节点服务不受影响。 - 水平伸缩时平台通过滚动新增或者下线节点的方式进行操作，因此操作不会影响现有服务。  垂直伸缩 CPU 与内存比例关系    申请值比例（CPU/内存） 限制值比例（CPU/内存)     0.24\u0026frasl;1 1.28\u0026frasl;1    Kubernetes 针对 CPU 和内存分为申请值与限制值，详情参见: [管理容器的计算资源](https://kubernetes.io/cn/docs/concepts/configuration/manage-compute-resources-container/) 平台目前调整的 CPU 与内存占比是经过生产环境验证过符合大多数服务类型。如果对某些CPU密集型服务自定义分配CPU，可以配置环境变量：ES_CPULIMIT : CPU限制值 ES_CPUREQUEST：CPU请求值  水平伸缩 服务进行水平伸缩的条件  无状态服务  我们一般称无需自己保存运行状态的服务为无状态服务，比如Web类服务。通常情况下只要将缓存系统使用第三方的服务比如Redis，Web类服务即可认为是无状态服务可进行水平伸缩。\n那么有人要问，我的Web服务需要存取文件怎么办，Rainbond将处理服务直接的持久化存储同步。即每个服务实例使用的持久化存储为同一个文件系统，这就是计算与数据分离的实践。\n 有状态服务  有状态服务的水平伸缩条件将比较复杂，要支持有状态伸缩，首先得应用支持集群化水平扩展。\n比如我们部署了一个Mysql服务，我们直接将其水平扩到两个实例，会出现什么现象呢？ 两个实例都可以正常工作，但是它们之间无任何关系，也就是说是两个Mysql服务。显然这样使用是不行的。\n那什么有状态服务可以水平伸缩呢，主要是以下两类：\n 可进行水平扩展集群的集群化服务，比如 Etcd, Zookeeper, 小强数据库，TiDB等 主从集群类服务，我们一般可以将从服务进行水平伸缩。比如Mysql、Redis、MongoDB等。  有状态服务集群应用的制作方式我们将在主题文档中讲解  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-rely/",
	"title": "服务依赖",
	"tags": [],
	"description": "Rainbond服务依赖关系和依赖连接信息管理",
	"content": " 服务连接信息管理 连接信息的作用 当前服务被其他服务依赖时，如果需要注入相关变量给对方以方便对方连接自己。连接信息的实质是环境变量，只是其生效范围是自身和依赖自己的所有服务。比如一个MYSQL服务拥有连接信息 MYSQL_HOST、MYSQL_PORT、MYSQL_USER、MYSQL_PASSWORD、MYSQL_DATABASE。这些信息是其他服务连接 mysql的关键信息，当服务依赖mysql后会自动得到上诉的环境变量从而动态的获取到相关信息。\n添加连接信息 连接信息完全可以在 服务管理-依赖管理 模块自定义添加和删除，当服务端口开启对内服务后，会自动生成 XXX_HOST XXX_PORT的变量信息，这类连接信息如果需要在 端口管理 模块点击端口别名进行修改。\n服务依赖管理 服务为什么要依赖其他服务 当一个独立的业务系统不能完成所有功能时，就需要借助其他的服务来实现。如web服务一般都需要数据库存储数据，前端页面展现程序需要调用后端API服务获取数据等等。因此服务依赖的实质是建立与其他服务通信的链路。在Rainbond中，我们默认采用ServiceMesh的服务网络治理方式处理服务之间的通信，当服务需要请求其他服务时，必须显示的建立依赖关系，从而Rainbond将通过内置的服务注册和服务发现机制发现对方的服务地址，在当前服务的网络空间内建立起本地监听来负载均衡到目标服务的所有实例上。\ngraph LR; A[服务A] --|127.0.0.1:8080 | C{envoy} C --|192.168.0.1:8080 | D[服务B实例1] C --|192.168.0.2:8080 | E[服务B实例2]  当服务未开启服务网络治理插件的情况下，Rainbond默认采用envoy 4层通信模型进行网络治理，开通治理插件即可在7层进行网络治理，设置更多路由或限流策略。\nRainbond中不管时内置服务还是第三方服务，通信维护方式都是一致的。  服务如何连接依赖服务 当服务开启对内服务后，其他服务才能通过【添加依赖服务】的方式进行关联，服务与依赖的服务建立起关联后，下一步就是连接依赖服务。\n在【依赖】页面中的 【依赖应用信息】可以看到已经依赖的服务：\n获取连接信息 选择其中一个依赖服务，点击【连接信息】会弹出连接信息页面: 连接信息分为两类:\n 变量名 \u0026gt; 当服务的端口打开对内服务后，会生成一个默认的端口别名这个别名就是该服务的连接信息的前缀。如一个内部的API服务，端口别名是 USERAPI 则，其他服务与该API建立关联后，就可以通过 USERAPI_HOST 找到API服务的连接IP，通过USERAPI_PORT 找到API服务的端口号，如果还需要添加其他的变量名，可以通过 【依赖】\u0026ndash;【服务连接信息】添加更多的依赖相关的变量。\n 变量值 \u0026gt; 服务可以通过确定的变量值来连接被依赖（打开对内服务）的服务，我们不推荐使用这种方式连接，这种方式属于硬编码，所有配置都写死到代码中，对于业务安全与程序灵活性都有影响。我们推荐使用环境变量名的方式连接服务\n  服务连接依赖服务 当服务添加了依赖，并且查看了连接信息后，下一步就是修改服务的配置，连接依赖的服务，以Springcloud程序为例介绍通过环境变量的形式连接依赖的服务：\napplication.yml 文件\n... spring: data: mysql: host: ${MYSQL_HOST} username: ${MYSQL_USER} password: ${MySQL_PASS} database: ${MYSQL_DB} port: ${MYSQL_PORT} ...  其他各类语言都有获取环境变量的方法，如果不想用环境变量，也可以使用直接变量值，但按照十二要素原则，我们不推荐使用硬编码的方式连接服务。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-volume/",
	"title": "服务存储设置",
	"tags": [],
	"description": "Rainbond服务存储的管理文档",
	"content": " 服务为什么需要存储 服务是 Rianbond 的抽象概念，底层是通过容器封装运行，容器磁盘文件是短暂的，也就是说，在容器中的程序在运行过程中的日志、生成或处理的文件，一旦容器关闭或重启，之前生成或存储的文件就丢失了。因此需要给服务容器挂载一个持久化的存储空间, 用于保存程序运行产生的各类数据。\n存储的类型 Rainbond 默认支持以下几种存储类型:\n 共享存储(宿主机路径/grdata) 本地存储(宿主机路径/grlocaldata) 配置文件 内存文件存储  共享存储 共享存储是一个分布式\u0008文件系统, 默认使用的是 NFS, 你也可以自行对接其它的分布式\u0008文件系统(比如: GlusterFS, NAS 等). 共享存储具有非常高的可靠性和扩展性; 与此同时, 它还具有非常高的灵活性, 可以共享给\u0008其它的服务组件，基于租户、服务两级进行存储空间分配和隔离。 共享存储针对无状态服务和有状态服务呈现的工作模式不同：\n 无状态服务  共享存储没有实例差别，多个实例数据一致。 可以被其他服务依赖以实现服务间数据共享。  有状态服务  每个实例具有独立的存储空间 不能被其他服务共享   本地存储 本地存储使用的是\u0008当前服务对应的运行实例所在宿主机的一块本地磁盘（通常可以是SSD磁盘），其不具备跨宿主机可用的属性。本地存储只支持有状态服务类型。本地存储通常服务于对存储性能要求非常高的服务，比如数据库类服务。它们可以从应用层面来处理数据在多个实例间的同步，比如Mysql使用主从同步，TiDB基于raft协议的等价集群等。这些服务通常不需要存储层面进行数据同步。\n配置了本地存储的服务调度将跟随存储所在宿主机，是一种受限的调度机制。对于集群类的数据库服务，从应用层处理存储数据的多节点同步，使用本地存储将是一种较优的选择。\n配置文件 配置文件是一种特殊的存储类型，此类型允许用户直接定义文件内容，通常是指配置文件。 Rainbond支持配置文件有两大特性：\n 动态渲染 动态渲染配置文件解析环境变量的语法:\n${环境变量名} ${环境变量名:默认值}   下面是 MySQL 配置文件的一个片段:\n[mysqld] port = ${PORT:3306} socket = /tmp/mysql.sock  如果服务中存在环境变量 PORT, 那么 Rainbond 会\u0008将PORT 的值解析到配置文件中; 如果服务中不存在环境变量 PORT, 那么 Rainbond 会\u0008将 3306 解析到配置文件中。\n如果指定的环境变量不存在, 且没有设置默认值, 那么 Rainbond 不会进行解析   配置文件共享  可以通过存储共享的机制来共享配置文件，如果你有多个服务使用同一个配置文件的场景，可以直接共享，无需多次编辑设置。\n配置文件存储支持编辑功能，即添加后可以根据需要修改配置文件内容，修改完成后需更新服务才能生效。  内存文件存储 内存文件存储的本质是一块 tmpfs (RAM-backed filesystem), 它是临时的, 会随服务的创建\u0008而创建, 随服务的\u0008\u0008停止而销毁. 虽然 tmpfs 非常快, 但请注意, 你编写的任何文件都将计入服务的内存限制.\n如何为服务添加存储 为服务添加存储有两种方式：\n 新增服务存储  找到 【存储】页面\n点击 【添加持久化】按钮\n存储添加完成\n 挂载其他服务的存储  在【存储】页面找到 【挂载目录】 点击【挂载目录】按钮后，勾选需要挂载其他服务的名称，并填写挂载到本服务的目录 完成挂载其他服务存储\n- 新增或挂载其他服务的存储后，需要更新或重启服务，挂载其他服务的存储不支持挂载到有状态的服务。 - 新增或挂载其他服务存储时，本服务的路径不能使用 Linux 系统保留目录，如：/dev、/usr、/bin、/sys、/proc 等  存储挂载路径查看方式 可以通过grctl命令来查看应用存储挂载路径查看方式 grctl service get \u0026lt;应用别名\u0026gt; -t \u0026lt;租户id\u0026gt;。\n示例如下: 源码构建python程序，挂载日志目录,应用控制台URL http://172.20.0.101:7070/#/team/lsqbjv5e/region/rainbond/app/grbc2de8/overview\ngrctl service get grbc2de8 -t lsqbjv5e # 存储部分 PodVolumePath:\t/grdata/tenant/b03170a64738460e894f7288fe54c3d6/service/1f1efa8fcaf32156989142e93ebc2de8/logs:/logs:/logs /grdata/build/tenant/b03170a64738460e894f7288fe54c3d6/slug/1f1efa8fcaf32156989142e93ebc2de8/20190213191750.tgz:/tmp/slug/slug.tgz:/tmp/slug/slug.tgz  PodVolumePath 结构说明：\u0026lt;本地存储/分布式存储\u0026gt;\u0026lt;存储路径\u0026gt;:\u0026lt;应用存储路径\u0026gt;:\u0026lt;插件存储路径(仅启用插件后显示)\u0026gt;\n其中slug.tgz为源码构建生成物,源码构建应用必须挂载。\n其他持久化存储的支持 上诉提到的存储类型主要以文件系统类为主，对于块设备的支持也将是我们的终点方向，特别是在公有云环境下，高性能磁盘的存储挂载也是支持高性能服务的重点。目前在企业版本中我们支持对存储类型支持的定制开发，比如私有存储ceph、阿里云的共享块设备和高性能磁盘设备等。\n已有本地docker运行服务持久化数据迁移到Rainbond 示例gogs:\n step 1 本地通过docker run 方式将gogs运行启动，并且持久化了相关目录。\ndocker run -d --net=host -v /var/gogs:/data gogs/gogs  step 2 Rainbond平台通过docker run方式同样运行如上命令即可,应用部署完成后可以通过grctl命令获取存储路径\n   step 3 把需要迁移的gogs数据(data1)备份，然后把平台上的gogs停了，然后用备份的data1数据替换了平台上运行的gogs的数据，启动平台上的gogs  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-port-domain/",
	"title": "服务端口",
	"tags": [],
	"description": "Rainbond服务端口和注册策略管理文档",
	"content": " 服务端口管理 服务端口管理 端口相关的管理包含，端口号，端口协议，端口访问控制、对内服务端口变量设置等操作，下图是不同团队、不同端口的服务开启了不同访问控制后的示意图：\n端口号设置 服务端口与容器内部程序监听的端口是完全对应的关系，也就是说，当程序启动后监听的端口是80，那服务的端口就应该设置为80。\n可以通过【添加端口】功能为服务添加其他的端口，需要确保添加的端口与程序监听的端口一致，并选择对应的端口协议。\n端口协议 端口可以指定不同的协议类型，目前Rainbond支持 HTTP、TCP、UDP和 MySQL 协议，请确保选择的协议与你程序监听的协议一致。\n协议的选择会影响服务的后续操作：\n 性能分析功能 \u0026gt; 不同协议的服务启动了性能分析插件后，其性能分析的方式会有所不同，如HTTP协议会分析HTTP相关的数据，MySQL协议会分析MySQL语句相关的数据。\n 打开对外服务后的访问 \u0026gt; 当端口打开对外服务后，HTTP协议会分配默认的域名，非HTTP协议会分配IP+端口的访问方式\n  端口访问控制 端口的访问控制分为两类：\n 对内服务 \u0026gt; 这里的内是指团队内，开启服务对团队内部的访问许可，这时当前服务端口将被注册到团队的内部服务可用池、该团队内部的服务可以通过【添加依赖服务】的方式访问到该服务。\n 对外服务 \u0026gt; 打开对外服务后，平台会将该服务端口注册到团队对外服务可用池，这时应用网关可以以用户配置的访问策略访问到该服务，此时平台外部以及平台内部其他团队的服务都可以通过应用网关分配的域名或IP访问到该服务。\n  - 修改端口信息后需要更新服务。 - 端口打开对内服务后，其他服务要想连接到该服务，需要先【添加依赖服务】建立关联，然后通过连接地址或环境变量连接。 - 端口访问控制可以根据需要开启和关闭，可单独开启，也可以全部开启，如果服务是个worker程序，只需要连接别的服务，本身没有端口监听就没有必要开启端口访问。  服务访问策略管理 Rainbond为每一个HTTP服务自动生成一个默认的域名，一般情况下这个域名都比较长，不方便记忆。你可以在服务端口管理面板中快捷绑定自定义域名。\n关于服务访问策略的几种管理和高级设置，请参考 应用网关-访问策略管理\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/auto-deploy/",
	"title": "应用持续构建与部署",
	"tags": [],
	"description": "Rainbond服务进行持续构建与部署（自动CI/CD）文档",
	"content": " 服务自动构建 通过自动构建的功能，可以实现代码提交后应用的自动构建，平台提供了基于代码仓库Webhooks、镜像仓库Webhooks和API等方式触发自动应用部署。方便的对接第三方自动化流程。只需要通过简单的设置，就可以帮您完成重新部署的工作。\n代码仓库自动化构建说明 开启源码自动构建，需要应用具备如下条件：\n 应用是由源码创建(官方demo除外)，目前支持的代码仓库为GitHub、GitLab、Gitee 与 Gogs 确定应用已经 开启 了此功能 需要在代码仓库的项目中配置正确的 webhooks 目前仅支持项目的push事件 提交信息中包含触发关键字 \u0008默认为@deploy，用户可设置 应用状态必须是运行中或运行异常状态  开启自动构建 在服务管理-构建源管理 中请打开Git-Webhook 自动构建功能，并复制我们平台提供的URL前往你使用的Git server 配置Webhook。\n\n配置代码仓库  配置GitHub  如果您的项目存放在Github中，请参考如下截图：\n\n 配置GitLab  如果您的项目存放在GITLAB中，请参考如下截图:\n\n- 开启自动构建后，每次提交代码的Commit信息中必须包含触发自动构建关键字、例如： `@deploy` 才能触发自动构建, 触发自动构建关键字可自定义设置，设置的仅为关键字，提交信息中\u0008在关键字前需加上`@`符号  \n镜像仓库自动化构建说明 镜像仓库自动构建可以实现推送镜像后应用的自动构建，方便的对接第三方自动化流程。当镜像更新事件到达时判断以下条件，都满足时触发自动构建。\n 应用是由镜像创建，镜像仓库为Docker Hub， 5.1.2版本及以后支持阿里云镜像仓库。 默认更新的镜像名称和tag是否与当前服务构建源镜像名称一致（判断时不包含镜像仓库域名）, 5.1.3版本及以后支持配置Tag触发正则策略，动态匹配和改变服务的镜像Tag。 服务已经 开启 了镜像仓库Webhook功能。 应用状态不是未部署和已关闭  开启镜像仓库Webhook自动构建 需要在应用中启用自动构建功能，并且需要将应用的webhooks url配置到目标镜像仓库的webhooks中。\n\nTag触发策略 默认情况下Webhook更新事件的镜像名称和Tag必须与服务当前构建源的镜像名称和Tag配置一致才能触发构建和部署。配置了Tag触发策略以后，根据配置的正则表达式，如果接收到的push事件的镜像tag能够正确匹配正则表达式，则认为此次更新事件有效，根据更新的Tag信息来升级当前服务的构建源信息并进行自动构建。\n比如设置 Tag策略为： v5.* 当Tag为 v5.1 v5.2 v5.9等都将被允许。\n配置镜像仓库  配置Docker Hub  请参考如下截图: \n\nAPI触发自动构建 通过开启API自动构建返回的url，POST方法调用API，携带秘钥即可触发API自动构建，秘钥可以自定义设置\n\nAPI使用用例：\ncurl -d '{\u0026quot;secret_key\u0026quot;:\u0026quot;\u0026lt;秘钥\u0026gt;\u0026quot;}' -H \u0026quot;Content-type: application/json\u0026quot; -X POST \u0026lt;API地址\u0026gt;  基于API触发自动构建是最灵活的方式之一，主要用于与第三方CI系统集成。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-plugins/",
	"title": "服务插件",
	"tags": [],
	"description": "Rainbond服务插件管理和配置文档",
	"content": " 服务插件 服务开通插件是对服务治理功能的扩展，插件的定义请查阅文档 插件管理-插件定义\n当前团队下安装的插件才可以被服务开通，因此插件的使用流程是：\n 团队插件管理安装或添加插件 构建构建并设置配置项 进入服务管理-插件模块 开通已构建完成的插件  目前主要提供了网络治理类和性能分析类的插件。Rainbond默认提供的两个插件配置文档如下：\n1. 性能分析插件\n2. 网络治理插件\n通常情况下服务不能安装重复的同类型插件。\n插件属性配置 插件的配置根据插件的配置项定义动态渲染而来，比如某个配置项依赖于服务端口，那么在配置面板中服务的每个端口都可以定义配置项的值。\n详细说明查阅： 插件配置项说明\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-source/",
	"title": "服务构建源设置",
	"tags": [],
	"description": "Rainbond服务的构建源设置和各语言编译参数配置文档",
	"content": " 服务构建源 Rainbond内置服务创建有三种模式：源码、镜像和应用市场，它们分别具有不同的属性提供配置。\n 源码 \u0026gt; 源码的构建源配置参数将是最为丰富的，包括基础的代码仓库信息包括（仓库地址，分支，Tag, 授权信息等) \u0026gt; \u0026gt; 还有各语言的编译环境参数\n 镜像 \u0026gt; 镜像的可配置参数主要是镜像地址，仓库信息和镜像启动命令等\n 应用市场 \u0026gt; 从应用市场安装的服务不提供更多的参数配置，主要展示来源于哪个云市应用。\n  构建源检测 服务创建时对构建源进行语言检测，在后续的持续开发中，如果源码更改了语言类型，比如从Java-Maven类型更改为Dockerfile类型，需用执行重新检测源码操作，让Rainbond重新设定服务的编译方式才能生效。\n Rainbond在源码编译过程中不会重新识别语言类型、\n 自动构建设置 自动构建即通过一种方式自动触发Rainbond服务版本构建的操作，详细文档见服务自动构建\n构建参数设置 JAVA Maven语言类型    参数名称 默认值 可选值 说明     清除构建缓存(NO_CACHE)  true 默认不启用   OpenJDK版本(BUILD_RUNTIMES) 1.8 1.6,1.7,1.8,1.9,10,11 OpenJDK版本   启用OracleJDK(BUILD_ENABLE_ORACLEJDK)  true 默认不启用OracleJDK   OracleJDK下载路径(BUILD_ENABLE_ORACLEJDK)   OracleJDK(linux amd64)下载路径   Maven版本(BUILD_RUNTIMES_MAVEN) 3.3.1 3.0.5,3.1.1,3.2.5,3.3.1,3.3.9 Maven版本   Web服务器支持(BUILD_RUNTIMES_SERVER) tomcat85 tomcat7,tomcat8,tomcat85,tomcat9,jetty7,jetty9    禁用Maven Mirror(BUILD_MAVEN_MIRROR_DISABLE)  true 默认启用Maven mirror,若禁用Mirror则关于Mirror配置不生效   MAVEN MIRROR OF配置(BUILD_MAVEN_MIRROR_OF) *     MAVEN MIRROR_URL(BUILD_MAVEN_MIRROR_URL) maven.goodrain.me     Maven构建参数(BUILD_MAVEN_CUSTOM_OPTS) -DskipTests  Maven构建参数   Maven构建全局参数(BUILD_MAVEN_CUSTOM_GOALS) clean dependency:list install  Maven构建参数   MAVEN构建Java参数配置(BUILD_MAVEN_JAVA_OPTS) -Xmx1024m     启动命令(BUILD_PROCFILE)   War包:web: java $JAVA_OPTS -jar ./webapp-runner.jar --port $PORT target/*.war;Jar包:web: java -Dserver.port=$PORT $JAVA_OPTS -jar target/*.jar    JAVA Jar语言类型    参数名称 默认值 可选值 说明     OpenJDK版本(BUILD_RUNTIMES) 1.8 1.6,1.7,1.8,1.9,10,11 OpenJDK版本   启用OracleJDK(BUILD_ENABLE_ORACLEJDK)  true 默认不启用OracleJDK   OracleJDK下载路径(BUILD_ENABLE_ORACLEJDK)   OracleJDK(linux amd64)下载路径   启动命令(BUILD_PROCFILE)   web: java -Dserver.port=$PORT $JAVA_OPTS -jar target/*.jar    JAVA War语言类型    参数名称 默认值 可选值 说明     OpenJDK版本(BUILD_RUNTIMES) 1.8 1.6,1.7,1.8,1.9,10,11 OpenJDK版本   启用OracleJDK(BUILD_ENABLE_ORACLEJDK)  true 默认不启用OracleJDK   OracleJDK下载路径(BUILD_ENABLE_ORACLEJDK)   OracleJDK(linux amd64)下载路径   Web服务器支持(BUILD_RUNTIMES_SERVER) tomcat85 tomcat7,tomcat8,tomcat85,tomcat9,jetty7,jetty9    启动命令(BUILD_PROCFILE)   web: java -Dserver.port=$PORT $JAVA_OPTS -jar target/*.jar    JAVA Gradle语言类型    参数名称 默认值 可选值 说明     OpenJDK版本(BUILD_RUNTIMES) 1.8 1.6,1.7,1.8,1.9,10,11 OpenJDK版本   启用OracleJDK(BUILD_ENABLE_ORACLEJDK)  true 默认不启用OracleJDK   OracleJDK下载路径(BUILD_ENABLE_ORACLEJDK)   OracleJDK(linux amd64)下载路径    Python语言类型支持    参数名称 默认值 可选值 说明     Python版本(BUILD_RUNTIMES) python-3.6.6 python-3.4.3,python-3.5.3,python-3.6.0,python-3.6.1,python-3.6.2,python-3.6.3,python-3.6.4,python-3.6.5,python-3.6.6,python-2.7.9,python-2.7.10,python-2.7.13,python-2.7.14,python-2.7.15    Pypi源(BUILD_PIP_INDEX_URL) https://pypi.tuna.tsinghua.edu.cn/simple  PIP源   清除构建缓存(NO_CACHE)  true 默认不启用    PHP语言类型    参数名称 默认值 可选值 说明     web服务器支持(BUILD_RUNTIMES_SERVER) apache nginx    PHP版本(BUILD_RUNTIMES) 5.6.35 5.5.38,5.6.35,7.0.29,7.1.16    清除构建缓存(NO_CACHE)  true 默认不启用    静态语言类型    参数名称 默认值 可选值 说明     web服务器支持(BUILD_RUNTIMES_SERVER) nginx apache     NodeJS语言类型    参数名称 默认值 可选值 说明     Node版本(BUILD_RUNTIMES) 8.12.0 4.9.1,5.12.0,6.14.4,7.10.1,8.12.0,9.11.2,10.13.0,11.1.0 Node版本   清除构建缓存(NO_CACHE)  true 默认不启用    Golang语言类型    参数名称 默认值 可选值 说明     Golang版本(BUILD_RUNTIMES) go1.11.2 go1.9.7 go1.8.7 go1.11.2 go1.11 go1.11.1 go1.10.5 go1.10.4 Go版本    NodeJS前端语言类型    参数名称 默认值 可选值 说明     Node版本(BUILD_RUNTIMES) 8.12.0 4.9.1,5.12.0,6.14.4,7.10.1, 8.12.0,9.11.2,10.13.0,11.1.0 Node版本   清除构建缓存(NO_CACHE)  true 默认不启用   web服务器支持(BUILD_RUNTIMES_SERVER) nginx apache     .NetCore语言类型    参数名称 默认值 可选值 说明     编译环境版本(BUILD_DOTNET_SDK_VERSION) 2.2-sdk-alpine 3.0-sdk,2.2-sdk-alpine,2.1-sdk 编译环境版本   运行环境版本(BUILD_DOTNET_RUNTIME_VERSION) 2.2-aspnetcore-runtime 3.0-aspnetcore-runtime,2.2-aspnetcore-runtime,2.1-aspnetcore-runtime 运行环境版本    Dockerfile语言类型 支持ARG参数设置,key-value模式\nARG CODE_VERSION=latest FROM base:${CODE_VERSION} CMD /code/run-app  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-rollback/",
	"title": "服务版本管理",
	"tags": [],
	"description": "Rainbond服务版本的管理和版本回滚文档",
	"content": " 服务版本管理 服务每次成功部署后，都会生成一个服务版本，每个版本对应一次代码提交（基于源码创建），或者一个镜像版本（Docker 镜像创建）\n通过 构建版本管理 功能，可以将服务回滚到指定版本，Rainbond 默认保留服务构建成功的版本。\n版本管理中可以查询当前运行的版本，构建的历史版本和版本构建成功率。每一个版本都可以追溯代码提交记录或源镜像记录。\n版本回滚  服务可以随时回滚到历史构建成功的版本，Rainbond回滚操作与升级类似，采用滚动的方式进行。\n- 多节点服务回滚操作采用滚动升级方式，因此时不会影响服务，但会有较短的时间同时存在 2 种版本的情况。 - Rainbond 5.X版本中对于服务回滚只会回滚代码和镜像运行环境，对服务配置（端口、环境变量、内存设置等）不会回滚到历史状态。 - 若你需要将应用整体回滚到历史的状态，包括持久化数据，请使用[应用备份与恢复机制](/user-manual/app-manage/app-backup/)  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-other-set/",
	"title": "服务其他设置",
	"tags": [],
	"description": "Rainbond服务基础信息，环境变量，健康检测，用户权限等属性的设置文档",
	"content": " 服务其他设置 服务的其他功能，包括更多的服务信息、环境变量、健康检查、服务权限等更多属性都在 服务的 【设置】页面中，下文会对每一块功能做详细介绍。\n服务基础信息 服务基础信息显示了服务当前的版本信息、来源及状态，不同类型的服务显示的内容也会有所不同，并且在基础可以改变应用的部署类型，给服务添加标签，\u0008构建后是否自动升级等；只有在服务是有状态的情况下，才可以设置服务名称属性：\n   属性名称 说明 默认值     应用部署类型 服务的部署类型，包括无状态服务和有状态服务 无状态服务   应用特性 应用的运行或调度特性标签，主要用于标识服务的一些特殊特性，比如Windows服务、GPU服务等，可选值由管理后台设定    应用构建后自动升级 设置服务是否在构建完成后自动进行滚动进行，若关闭，则不进行。 是    自定义环境变量 当你通过服务【设置】中的自定义环境变量，添加变量后服务更新或重启后生效。\n通常情况下，我们将配置信息写到配置文件中供程序读取使用，在Rainbond平台中，我们极力推荐使用环境变量的方式来代替传统的配置文件的方式。\n这样做的好处如下：\n 将配置信息与服务绑定，与代码解耦，摆脱不同环境下切换配置文件的麻烦 敏感信息与代码分离，避免程序漏洞造成数据丢失 省去配置管理的工作  下面是一个生产环境的服务使用环境变量进行配置的截图：\n \n以Python为例介绍在配置读取环境变量的方法：\n# -*- coding: utf8 -*- import os DEBUG = os.environ.get('DEBUG') or False TEMPLATE_DEBUG = os.environ.get('TEMPLATE_DEBUG') or False DEFAULT_HANDLERS = [os.environ.get('DEFAULT_HANDLERS') or 'zmq_handler'] DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'goodrain', 'USER': os.environ.get('MYSQL_USER'), 'PASSWORD': os.environ.get('MYSQL_PASSWORD'), 'HOST': os.environ.get('MYSQL_HOST'), 'PORT': os.environ.get('MYSQL_PORT'), } } ...  基于环境变量除了可以定义上诉所述的用于应用运行的变量以外，还能作为服务编译、服务调度运行的参数指定方式，更多请查看 环境变量的高级用法\n关于动态值环境变量：\n 环境变量的值可以基于已存在环境变量的值解析，如果环境变量的值中出现 ${XXX}，平台将尝试查找XXX环境变量的值来替换此字符串，若无法找到具有值的XXX变量，将不做更改。\n为防止出现无法被解析的情况，可以定义为${XXX:yy}的形式，:以后的将作为未成功解析的默认值。\n例如有已存在环境变量 A=1，环境变量B需要使用A的值，直接定义B=${A}。\n 健康检查 为了了解服务启动后的服务是否可用，已经服务运行中的服务运行情况，我们增加了服务检查的功能。\n未配置健康检查的服务，进程启动即说明服务已启动，显然这不是严格的方式。配置基于HTTP或TCP的方式对服务进行业务级健康检查是精确控制服务状态的推荐方式。\n当服务处于不健康时，有两种处理方式\n 设置服务为不健康   当服务实例被设置成不健康，其将从应用网关和ServiceMesh网络下线。等待其工作正常后重新自动上线。\n  重启服务实例   有些服务可能由于代码阻塞等原因形成死锁进程，无法提供服务但进程依然运行。处理这类服务的不健康状态只能通过重启实例的方式。\n 服务启动时检查配置示例\n \n 示例配置：当容器启动2秒后，开始对 5000 端口进行 tcp 协议的第一次检查，如果等待20秒检查没有结果，平台会重启服务，如果20秒内成功返回，平台认为服务启动成功。\n 成员服务权限 关于角色权限定义的文档请参考：权限管理\n这里主要讲的是服务权限的管理，当某个用户加入到团队时，团队管理员决定该用户的角色，如果要限制某个用户只能管理某些服务，建议使用 Viewer(观察者) 角色，然后根据需要在服务的 【成员服务权限】中设置服务的管理权限。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-env/",
	"title": "高级环境变量配置",
	"tags": [],
	"description": "Rainbond服务高级环境变量配置文档",
	"content": " Rainbond平台启动服务时默认注入以下环境变量信息以供应用使用：\n   变量名 变量值 说明     PORT 应用设置的第一个端口号 应用建立端口监听时尽量获取 PORT 环境变量值进行监听   PROTOCOL http\\tcp\\mysql 等 对应上诉端口的协议类型   DEFAULT_DOMAIN 默认域名 第一个 http 协议的端口的平台默认域名   DOMAIN 自定义域名 最小的http端口对应的域名   TENANT_ID 租户 ID 租户 ID   SERVICE_ID 应用 ID 应用 ID   MEMORY_SIZE micro， small， medium， large， 2xlarge 等 表示当前应用实例的内存大小设置，一般用于应用内存相关设置的初始化，例如 JAVA_OPTS   SERVICE_POD_NUM 应用实例数量 应用实例的数量   DEPEND_SERVICE serviceAlias:serviceID, 依赖的应用   HOST_IP ip地址 服务运行时所在宿主机IP地址   POD_IP ip地址 服务运行时的IP地址   DISCOVER_URL http://xxxxxxx/v1/resources/xxx 配置发现接口地址,插件运行环境有效   DISCOVER_URL_NOHOST /v1/resources/xxx 不带IP地址的配置发现URL, 地址使用HOST_IP：6100    自定义域名注入的补充说明:  1. 如果有多个端口, 则会在环境变量名后面加上`_\u0008端口号`, 即`DOMAIN_\u0008端口号`. 比如: DOMAIN_80, DOMAIN_8080.  2. 如果端口有多个自定义的域名, 则会在环境变量名后面加上`_\u0008序号`, 即`DOMAIN_序号`或`DOMAIN_端口号_序号`. 比如: DOMAIN, DOMAIN_1, DOMAIN_2; 或 DOMAIN_80, DOMAIN_1, DOMAIN_2;  使用以下高级环境变量可以解锁更多高级功能：\n部署（构建）应用时使用的变量 变量名以BUILD_开头的环境变量在源码构建类应用构建阶段生效，比如下述变量：\n   变量名 变量值 说明     BUILD_REPARSE true 构建时重新识别代码语言类型   NO_CACHE true 构建时不使用缓存包   BUILD_MAVEN_CUSTOM_OPTS -DskipTests=true -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true 用于 maven 构建，默认值如前   BUILD_MAVEN_CUSTOM_GOALS clean install 用于 maven 构建，默认值如前   NO_CACHE true 构建时不使用缓存包    更多服务构建环境设置，请参考 服务构建源配置\n应用运行高级变量 以ES_开头的环境变量将作为扩展功能变量，例如下面用例：\n   变量名 变量值 说明     ES_SELECTNODE 选择宿主机的ID 用于定点调度，指定调度到某台宿主机上，节点的ID通过grctl node list 可得   ES_HOSTNETWORK true 是否使用主机端口映射   ES_HOSTANME 主机名 设置实例的主机名，适用于单实例服务   ES_CPULIMIT 1核=1000 自定义服务的CPU限制值 5.0.3及以后版本支持   ES_CPUREQUEST 1核=1000 自定义服务的CPU请求值 5.0.3及以后版本支持    "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/service-container/",
	"title": "服务容器终端",
	"tags": [],
	"description": "Rainbond服务运行容器终端的进入和操作方式文档",
	"content": " 进入容器命令行 运行起来的服务后端都是由容器提供的，平台提供了通过浏览器的方式登录到服务容器命令行的方式。当服务正常启动后，可以通过【管理容器】按钮，选择某个节点，进入到容器命令行，容器命令行可以更加方便去操作后台，例如：查看程序日志，数据库查询等：\n当无法正常打开控制台时，请检查服务状态是否正常。Web控制台只用作查看和调试程序，不建议通过控制台部署业务相关的服务。在容器中创建的文件若未存放于持久化目录，重启服务后文件丢失  浏览器兼容情况 推荐使用Google Chrome浏览器\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-service-manage/thirdparty-manage/",
	"title": "第三方服务管理",
	"tags": [],
	"description": "讲解第三方服务类型的管理操作",
	"content": " 总览 总览页面主要有展示第三方服务创建的元数据, 和对实例的管理.\n实例的类型有两类: 静态实例和动态实例. 对于静态的实例, 可以在 UI 对它们执行查询, 新增, 上线, 下线和删除等操作; 而对于动态实例, 只可以在 UI 上对它们执行查询操作, 它们的新增, 上线, 下线和删除等操作只能体现在服务注册中心数据的变化和健康检查上.\n查询 将当前服务所有的实例展示出来, 包括实例的数量, IP 地址, 端口, 健康状态, 是否上线等信息.\n下线 将实例从当前服务生效的实例列表中移出, 不再提供服务, 并保留当前服务的元数据中.\n上线 将实例从元数据中, 转移到生效的实例列表中, 为当前服务提供服务.\n新增 将新的实例添加到当前服务中. 在默认情况下, Rainbond 会\u0008将其设置为上线.\n删除 将指定实例下线, 并从元数据中中将其永久地移除.\n端口 端口的功能基本上\u0008和内部的服务保持一致, 唯一的不同点是, 第三方服务只能添加一个端口. 详情参考: 服务端口\n连接信息 详情参考: 连接信息\n更多设置 在更多设置中, 第三方服务保留了健康检测和成员服务权限. 在这两者中, 成员服务权限跟内部服务保持一致, 有变化的是健康检测. 第三方服务不健康处理方式有下线 和 \u001d忽略(内部服务为下线和重启).\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-store/",
	"title": "应用市场",
	"tags": [],
	"description": "",
	"content": "本章内容包括：\n 应用市场定义  Rainbond PaaS级应用市场的定义文档\n 应用市场应用同步  Rainbond应用市场间应用同步说明文档\n 基于应用市场的应用交付  Rainbond基于应用市场的应用交付说明文档\n Rainbond应用市场应用制作规范  具备SaaS化交付能力的Rainbond应用市场应用制作规范\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-store/app-market-define/",
	"title": "应用市场定义",
	"tags": [],
	"description": "Rainbond PaaS级应用市场的定义文档",
	"content": " 本文阐述应用市场的概念，并教你如何从Rainbond公共应用市场同步应用与插件。\n什么是应用市场 应用市场是Rainbond定义的一种对于Rainbond应用的存储、共享、交付、管理途径。 Rainbond应用市场与传统意义上的镜像仓库不同之处在于，它基于镜像仓库、包仓库和对象存储等存储系统支持，定义了支持大型、分布式数字化业务系统的标准云原生应用模型，并针对应用模型提供创建、发布、存储、交付、安装、升级等一系列业务支持，对内可作为以便捷灵活的方式共享企业创造的业务系统、中间件的业务性管理平台，对外可作为根据行业特性构建行业话交付标准、交付流程和交付路径的基础，应用市场的最大优点在于它涵盖的不仅是服务组件和应用（业务系统），甚至于解决方案都可以支持一键分享、一键安装使用，极大的便利用户，只需安装使用，覆盖几乎所有的用户，而不仅仅是技术性人员。\n基于Rainbond提供的通过源码、镜像等多种途径创建1-N个服务组件构成业务系统，一键即可构建应用模型并发布到应用市场中，根据不同场景需求和可见级别服务于不同的业务场景。\n应用市场应用同步 应用市场中的业务系统可以通过离线导出的方式，交付到一个离线的Rainbond平台，也可以通过公有云市场的方式在线交付社区用户或目标企业用户。 使用者通过应用市场即可一键安装部署完整业务系统，并且能够持续进行升级。 应用在线同步方式请参考文档 应用市场应用同步\n应用版本 应用市场中的应用支持多个版本共存，应用的操作粒度支持到版本级别。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-store/app-market-synchronous/",
	"title": "应用市场应用同步",
	"tags": [],
	"description": "Rainbond应用市场间应用同步说明文档",
	"content": " 应用市场同步 私有应用市场内置于Rainbond平台中，公有应用市场目前由好雨科技运营提供。公有云市场服务于与其对接互联的私有应用市场，提供跨平台，跨云的应用资源同步和升级。\n企业也可以建立行业公有应用市场，详情参阅 好雨企业服务\n与公有云市场互联\n市场间应用同步\n应用更新 已同步的应用若远端市场存在更新的版本，本地市场即可从远端获取最新的版本应用。当本地市场的应用有更新的版本，安装的服务可进行构建升级操作。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-store/share-app-market/",
	"title": "基于应用市场的应用交付",
	"tags": [],
	"description": "Rainbond基于应用市场的应用交付说明文档",
	"content": " 应用制作与分享 参考文档 应用管理，分享管理\n应用安装 应用下载同步是在互联网环境下的一种跨平台应用交付方式，通过此方式可以快速获取优秀的、成熟的通用解决方案，例如Mysql、TiDB等数据库方案，Gitlab、Jenkins等IT工具。也可以通过此方式交付商业业务系统给你的用户。当前Rainbond默认提供了与好雨云市的互联用例。\n在Rainbond控制台中点击左侧导航栏进入内部市场，根据你的需求选择应用或插件，点击云端同步即可看到在好雨公有云市发布的应用。应用名称后有(官方发布)字样是我们好雨官方发布或推荐的应用。点击应用名称可查看应用的详细介绍。\n选择要下载的应用或插件点击后方的下载将好雨公有云市应用或插件下载到你的内部市场中。下载完成后，方可在方可在 从应用市场安装直接一键安装本应用。如果是插件可在左侧导航栏我的插件中安装管理你的插件。\n 点击内部市场应用后方的云端更新，可将好雨云市中该应用的最新版本下载更新到你的内部市场。\n 应用交付 使用好雨公有云市在线交付 对于有在线环境的用户，可以直接使用好雨公有云市进行业务交付，将业务系统发布到好雨公有云市，用户可在公有云市直接下载一件安装整套业务系统。 应用发布请参考 应用管理，分享管理\n应用安装参考 服务创建\n使用导入导出离线交付 考虑到离线环境的应用交付，我们RainBond设计实现了应用到离线导入和导出功能。复杂的业务系统可以借助网络或离线应用包快速的在不同的环境中交付，安装速度和易用性远远超出传统的交付。除了标准Rainbond应用模型以外，同时还支持导出docker-compose模型脱离Rainbond平台便捷交付。\n应用导出 为了让用户能够更好的管理自己的应用，快捷简单交付业务，我们为平台设计了应用导入导出功能，该功能允许用户通过简单的几次点击，就可以将内部市场的应用打包为一个压缩文件，并可以下载到本地。在导出的时候，支持两种格式，一种为rainbond-app格式，另一种为docker-compose格式。\n 云市同步的应用不支持导出compose文件，只支持导出rainbond-app格式。\n  格式说明   rainbond-app：为了在多个云帮之间迁移应用而设计，即在A平台导出后，可以导入到B平台，但导出后的文件不能直接运行，导出的文件是一个zip格式的压缩包，其中包含了该应用的描述信息、每个组件的镜像或源码包等。\n docker-compose：为了快速交付而设计，当我们把云帮上的应用交付给用户时，就需要让应用具备脱离平台可运行的能力，这样才能避免为了使用一个应用而不得不先部署平台的问题，docker-compose导出格式可以在安装有docker和docker-compose的环境中运行，假设我们现在导出了一个docker-compose文件且名为web.tar，那么执行以下命令运行它：\ntar -xf web.tar ./web/run.sh   ​ 使用这种可运行的格式有以下需要注意的事项：\n 依赖环境：应用的运行需要依赖docker和docker-compose，如果您的系统中没有安装它们，run.sh脚本将会自动为您安装，所以请保证您的系统能够连接互连网，否则请手动安装这两个工具。\n 端口是否可用，假如我们导出了一个WEB应用，如果它在启动时需要监听80端口，则物理机上的80端口必须是空闲状态，否则会因为端口冲突而导致应用启动失败。\n   点击导出后，导出状态会显示为导出中   完成导出后，点击下载即可将文件下载到本地，导出的文件存放在数据中心下的/grdata/app/rainbond-app或/grdata/app/docker-compose下  应用批量导出 云帮导出的应用包文件会很大，如果网络不好的情况下，我们建议您直接在对应的数据中心的服务器上进行操作。\n每个应用在打包完成后，都会存储在某个数据中心的/grdata/app目录中，利用这一点，我们可以批量导出平台中的应用。\n 登录云帮，并进入“内部市场”页面。\n 找到想要导出的应用，并依次点击它们的导出按钮，等待平台打包完成即可。\n 等待平台打包完成后，登录到数据中心对应的服务器，假设我们要把所有导出的应用包复制到/mnt/sdc1/目录中，执行以下命令：\n find /grdata/app -maxdepth 2 -name '*.zip' | xargs -I FF cp FF /mnt/sdc1/   应用导入 应用导入任务发起后，由数据中心的rbd-chaos组件将用户上传的RainbondAPP文件解压，保存定义的元数据及镜像或slug包，用于安装构建应用时使用。 对于导出的应用，您也可以通过离线导入应用功能将应用导入到内部市场。在Rainbod左侧导航栏进入内部市场，点击离线导入应用，上传你的RainbondAPP文件开始导入。\n应用导入有以下两种方式：\n 如果你的网络情况不乐观的情况下，我们建议您直接在对应的数据中心的服务器上进行操作。你可以将RainbondAPP文件复制到数据中心管理节点上我们提供的目录下 如果网络情况较好，可以直接通过网络上传文件至数据中心指定目录下  开启自动识别，Rainbond自动识别已上传RainbondAPP文件，选中要导入的APP(支持批量导入)，点击确认导入向数据中心发送导入请求并开始导入应用。\n具体操作如下：\n应用导入成功后，可在内部市场看到你导入的应用。\n应用更新 对于从公有云市安装回来的应用，如果分享应用的用户对其分享到公有云市的应用有小版本更新（其应用下组件版本有更新），我们会在控制台对您的安装回来的应用进行更新提醒，如果您更新了内部应用市场应用后，我们会在您安装到本地控制台的应用进行应用升级提醒。 流程图如下：\n具体流程如下：\n1.安装公有云市应用，您可以从公有云市安装，亦可从内部应用市场安装，在创建应用中选择从应用市场安装，并搜索您想要安装的应用，安装即可。\n2.当其他用户对其分享到公有云市的应用进行小版本升级（即将其应用下的组件进行版本升级），您会在点击云端同步的时候显示出来，提示您当前应用是否可更新，如果可更新，您可以通过云端更新或更新新版本,即可对当前内部应用市场应用进行更新操作。\n3.当您对内部应用市场应用进行更新升级后，在您本地控制台安装的应用还未进行升级，在您查看服务详情时，我们会对您的服务进行查询是否可更新，如果可更新，在详情页会显示构建按钮，以便操作。\n3.1、判断依据(实现原理) 当用户将其租户下的一组应用进行打包分享的时候，我们会对其组内每个组件进行标识操作，对应用的小版本进行累加操作，并在公有云市进行存储，从公有云市同步到内部应用市场的时候，将该应用的数据及其下面的所有组件信息在内部应用市场中进行存储，通过其中小版本和内部应用市场存储的该应用的小版本进行判断该内部应用市场中的应用是否可更新，其中小版本在进行分享操作时，每次分享都会对其值进行累加，在同步到内部应用市场的时候在服务构建源中存储小版本以进行更新判断，并通过返回的应用数据中的字段进行唯一组件的判断，防止在存储依赖关系时关系紊乱； 从市场安装回来的应用判断更新依据是通过该组件版本与服务构建源中的组件版本进行比对，以此来判断该组件是否可更新。\n内部应用市场的应用更新是将公有云市应用重新同步到内部市场中（即将云市应用的数据在内部市场更新） 本地控制台的应用更新是将内部市场的应用数据在本地更新，并向数据中心发送请求，拉取最新的镜像进行部署。\n3.2、版本定义 应用大版本：一组应用打包， 在分享的过程中，用户会手动输入一个版本号，即为该分享到公有云市应用的大版本，大版本的变化根据用户的改变而定，当用户再次分享该应用，改变了大版本时将不会覆盖历史版本。\n应用小版本：该分享到公有云市的应用，会生成一个小版本保存到公有云市中，每次用户对该应用进行重新分享时，小版本会进行数值累加进行覆盖。\n组件版本：一组应用下的每个组件，当其每次重新部署时，会生成一个部署版本，即为该组件的版本\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-store/app-specification/",
	"title": "Rainbond应用市场应用制作规范",
	"tags": [],
	"description": "具备SaaS化交付能力的Rainbond应用市场应用制作规范",
	"content": "  本文档持续完善中\u0026hellip;\n 规范目的 此规范的制定为了指导用户如何制作Rainbond应用市场SaaS化交付应用。\n规范要求  支持一键安装  一键安装是指可以通过应用市场一键实现自动化安装完整的业务系统，要具备此能力需要做到：\n 完整的业务系统支持自动的持久化数据初始化和升级的能力。 基于环境变量对服务进行最优化配置。\n 容错能力强\n  容错能力强是指在云环境下，业务系统中的所有组件可以具备一定的混沌容错性，特别是以下几点：\n 服务启动时对其他服务的依赖通信做一定的重试。 服务不能出现死锁状态，比如由于与其他服务通信出现一次错误导致服务卡死。\n 多用户交付\n  应用可以多次安装部署。\n关键因素 数据初始化 数据初始化一般主要是数据库数据初始化和静态数据初始化，推荐的处理方式如下：\n 数据库数据初始化  在微服务场景中，如果每个服务都有自己的数据库服务，那么可以直接将数据库比如Mysql作为服务进行代码化维护，将其对应的服务SQL初始化代码和升级代码进行持续升级。\n第二种是服务自身维护SQL，每次启动后根据版本特性来执行SQL。这类方式一般进行*只增不减*的升级方式。\n 静态数据初始化  这类主要是网站类服务需要持久化某些目录，但是目录下已包含一些初始化数据。操作方式是先将初始化数据至于其他目录中，服务启动后判断持久化目录是否包含数据，若未包含，则将初始化数据同步进去以实现初始化。\n服务配置 应用进行SaaS化标准交付时，自定义的配置部分建议完全环境变量化，以环境变量的方式定义不同的参数类型。特别是服务之间的连接信息，务必完全根据Rainbond的规范环境变量化，以确保每次安装数据变化后工作正常。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/gateway/",
	"title": "应用网关管理",
	"tags": [],
	"description": "",
	"content": " 应用网关管理 本章内容包括：\n 应用网关说明  Rainbond默认提供的应用网关功能说明文档\n 访问控制  Rainbond应用网关访问策略管理，这是网关最关键的配置。\n 证书管理  Rainbond网关管理之Https证书管理文档\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/plugin-manage/",
	"title": "插件管理",
	"tags": [],
	"description": "",
	"content": " 插件管理  应用插件的定义和分类  Rainbond应用插件的定义和分类说明文档\n 插件设计与开发  Rainbond应用插件的开发文档\n ServiceMesh网络治理插件说明  Rainbond默认安装的ServiceMesh网络治理插件的原理和使用说明\n 应用性能分析插件说明  Rainbond默认安装的服务性能插件的原理和使用说明\n MySQL数据库备份与恢复插件  讲解如何使用数据库插件\n "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/plugin-manage/plugin-manage/",
	"title": "应用插件的定义和分类",
	"tags": [],
	"description": "Rainbond应用插件的定义和分类说明文档",
	"content": " 插件的定义 应用插件是标准化的为应用提供功能扩展，与应用共同运行的程序，例如：性能分析插件可以实时看到该服务的性能如何，吞吐率、响应时间以及在线人数等；网路治理插件则可以实现智能路由、A/B\u0008测试以及灰度发布等。\n插件的运行环境与所绑定的服务一致，包括环境变量、持久化存储、网络空间等。\n插件的分类    分类名称 作用 控制     性能分析类 服务安装性能分析类插件即可显示性能分析页面    入口网络类 ServiceMesh插件类型之一，负载处理服务下游流量 动态分配监听端口   出口网络类 ServiceMesh插件类型之一，负载处理服务上游流量 支持服务发现   初始化类型 服务在插件先启动并正常退出后再启动，用户服务数据初始化或其他初始化操作。    一般类型 比如数据备份、日志收集类     性能分析类 性能分析类插件通过旁路的方式分析服务的性能指标，或通过服务自身暴露性能指标由插件捕获。插件分析的性能指标参考 服务性能分析\nRainbond在每个计算节点提供了statsd服务接收性能分析插件的性能分析结果，并进行存储和展示。数据提供给其他功能比如自动伸缩参考。\n入口网络类 入口网络插件主要用于ServiceMesh网络或防火墙安全控制，比如，当我们部署了一个web应用后，我们不希望有不合法的请求（比如SQL注入）到达web中，这时我们可以为web应用安装一个安全插件，用来控制所有访问web的请求，就像是一个入口控制器，所以我们把这类插件叫做入口网络插件。\n 工作原理  当为某个应用安装了入口网络插件后，该插件被置于应用的前面，它必须监听一个由Rainbond分配的新端口用来拦截应用的所有请求，如下图中的8080端口，这时我们可以在插件内部对收到的请求进行必要的处理，然后把处理后的请求转发给应用监听的端口，如下图中的80端口。入口网络插件与应用的关系如下图所示：\n插件需要从Rainbond应用运行时中动态发现配置，配置中包含了服务的实际端口和插件应该监听的端口。\n出口网络类 出口网络类插件是最常用插件之一，Rainbond会默认为具有依赖其他服务的服务自动注入此类插件。同时Rainbond也提供了基于envoy实现的默认网络治理插件。出口网络类插件主要提供当前服务访问上游服务时的治理需求。\n 工作原理  Rainbond应用运行时提供了XDS规范的服务和配置发现服务，支持支持envoy类型或其他支持此规范的插件类型。也可以通过获取原生插件标准配置信息自行生成插件自己的配置。\n初始化类 初始化类插件工作原理是基于 init-container，即初始化容器，它一般完成数据初始化工作，其工作性质必须是在有限的时间内正常退出。只有初始化插件正常退出后，业务容器才会启动。Rainbond基于此类插件完成多个服务的批量启动时的顺序控制, 参考 rainbond服务组件 rbd-init-probe\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/plugin-manage/plugin-design-develop/",
	"title": "插件设计与开发",
	"tags": [],
	"description": "Rainbond应用插件的开发文档",
	"content": " 插件开发 参考\n1. 性能分析插件\n2. 网络治理类插件\n3. mysql数据备份插件\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/plugin-manage/mesh-plugin/",
	"title": "ServiceMesh网络治理插件说明",
	"tags": [],
	"description": "Rainbond默认安装的ServiceMesh网络治理插件的原理和使用说明",
	"content": " ServiceMesh网络治理插件 "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/plugin-manage/tcm-plugin/",
	"title": "应用性能分析插件说明",
	"tags": [],
	"description": "Rainbond默认安装的服务性能插件的原理和使用说明",
	"content": "  当前文档持续完整中\n 性能分析插件工作原理 性能分析插件是通过运行于与目标分析服务同一个网络空间内，监控网卡的流量来统计分析服务的工作性能，这是一种旁路机制，对服务本身的工作流程和性能无特别影响，插件从网络的TCP层采集网络包，通过实现不同协议的解码器来分析不同的协议请求和响应报文。\n 如何能够获取服务所在容器的网卡流量  性能分析服务作为插件由Rainbond服务安装，根据Rainbond对插件的支持定义，插件与主业务服务运行于同一个网络空间，因此它们分别所在的容器网卡设备可以认为是同一个设备。\n 如何进行协议分析  获取到的流量包以报文的形式存在，\n###插件配置项\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/plugin-manage/create-mysql-plugin/",
	"title": "MySQL数据库备份与恢复插件",
	"tags": [],
	"description": "讲解如何使用数据库插件",
	"content": " 数据库的备份与恢复插件基于 Percona XtraBackup 实现，支持 MySQL 数据库物理热备与完全恢复。\n目前此插件处于alpha版本。\n一、插件基本信息  插件 数据库备份插件 数据库恢复插件   插件类型  一般类型插件 初始化类型插件   备份/恢复类型  全量备份 全量恢复   插件镜像地址(rainbond/addones)  xtrabackup_backup xtrabackup_restore   配置组管理主要参数   FULLENABLE  SCHEDULE   RESTOREDATE  RESTOREON    二、数据库备份插件参数定义  目前插件仅支持注入类型:环境变量 参数:\n  DINGTOKEN: 钉钉bot token,用于备份等通知. FULLENABLE: 启动全量备份,默认true. SCHEDULE: 备份定时策略,支持0 30 * * * *; @hourly; @every 1h30m等 UPLOADTYPE: 上传备份到远端,目前支持 minio \u0026amp; ftp  MINIOURL/ACCESSKEY/SECRETKEY/BUCKET(minio配置参数) FTPADDR/FTPPORT/FTPUESR/FTPPASS/FTPDIR(ftp配置参数)   三、数据库恢复插件参数定义  目前插件仅支持注入类型:环境变量\n 参数:\n RESTOREDATE: 数据全量备份日期(目前只支持) RESTOREON: 启用全量恢复,默认true.  四、演示 demo 4.1 创建数据库备份插件 这里为了演示方便,将全量备份周期为240s.\n高清大图\n4.2 创建数据库恢复插件 高清大图\n4.3 安装插件 高清大图\n4.4 数据库恢复 高清大图\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/",
	"title": "运维手册",
	"tags": [],
	"description": "",
	"content": " 运维手册 本章节面向运维同僚们，讲解管理和运维Rainbond集群的知识和经验\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/",
	"title": "进阶场景",
	"tags": [],
	"description": "",
	"content": " 进阶场景 本章节面向已经阅读完使用手册的同僚们，Rainbond平台的进阶使用文档，包含DevOps,微服务架构，应用制作等多个场景。\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/service_mesh/",
	"title": "ServiceMesh微服务架构",
	"tags": [],
	"description": "全面讲解Rainbond内置的ServiceMesh微服务架构支持原理",
	"content": "本章将从下述方面讲解Rainbond内置ServiceMesh微服务架构原理和使用方式:\n 本章内容正在完善中\n  ServiceMesh微服务架构简介  初步了解Rainbond ServiceMesh架构\n 服务化定义  Rainbond对服务抽象的定义\n 服务注册和服务发现  基于服务注册和服务发现建立服务之间的透明通信\n 服务通信治理(完善中)  讲解Rainbond对服务（HTTP,gRPC,TCP）的治理原理\n 服务配置管理(完善中)  Rainbond对服务化配置的支持\n ServiceMesh架构与其他服务化架构的集成(完善中)  讲解Rainbond与与其他服务化架构的集成的原理和方案\n 服务安全(完善中)  讲解Rainbond对服务安全提供的机制\n 服务运维管理(完善中)  讲解Rainbond对服务的自动化运维机制，关于日志管理、分布式跟踪和业务监控\n "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/app-create/",
	"title": "应用部署实践",
	"tags": [],
	"description": "",
	"content": "本章文档讲解一些代表性应用的Rainbond部署方式，全面了解Rainbond应用管理的便利性。\n本章内容包括：\n 快速部署Gitlab源码管理服务  基于Rainbond快速部署生产可用的源代码管理服务\n 部署Mysql主从集群应用  基于Rainbond部署Mysql主从集群应用\n "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/service_mesh/service-mesh/",
	"title": "ServiceMesh微服务架构简介",
	"tags": [],
	"description": "初步了解Rainbond ServiceMesh架构",
	"content": " ServiceMesh 一般的字面解释是“服务网格”，作为时下最流行的分布式系统架构微服务的动态链接器，处于服务到服务的通信的专用基础设施层，该层独立于应用程序为服务之间的通信提供轻量级的可靠传递。如果简单的描述的话，可以将它比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控，同样使用 ServiceMesh 也就无须关系服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud架构，现在只要交给 ServiceMesh 就可以了。ServiceMesh的出现主要是由于应用虚拟化技术的发展，例如Kubernetes, Rainbond等项目，大大降低了应用的部署和运维复杂度。   \n微服务架构对比 \n为何使用ServiceMesh ServiceMesh 并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这是在 Cloud Native 的云原生环境下将过去复杂的人工运维工作有机的自动化管理。\n在传统的 MVC 三层 Web 应用程序架构下，服务之间的通讯并不复杂，在应用程序内部自己管理即可，但是在现今的复杂的大型网站情况下，单体应用被分解为众多的微服务，服务之间的依赖和通讯十分复杂，出现了 twitter 开发的 Finagle、Netflix 开发的 Hystrix 和 Google 的 Stubby 这样的 “胖客户端” 库，这些就是早期的 ServiceMesh，但是它们都近适用于特定的环境和特定的开发语言，并不能作为平台级的 ServiceMesh 支持。\n在 Cloud Native 架构下，容器的使用给予了异构应用程序的更多可行性，kubernetes 增强的应用的横向扩容能力，用户可以快速的编排出复杂环境、复杂依赖关系的应用程序，同时开发者又无须过分关心应用程序的监控、扩展性、服务发现、负载均衡和分布式追踪这些繁琐的事情而专注于程序开发，赋予开发者更多的创造性。如果你是符合以下场景，推荐选择ServiceMesh架构：\n 遗留庞大系统逐步过渡到微服务架构 业务系统由多种开发语言开发  ServiceMesh相对其他微服务架构优势  最大层度透明   ServiceMesh通过全局控制层控制服务与服务之间的调用关系，服务的治理策略。对于服务本身来说，只需要站在单机的维度考虑上游服务的依赖通信，采用简单的通信协议例如HTTP，gRPC等。Mesh层透明的发现上游目标，进行重试/超时、监控、追踪。为单机服务赋予分布式系统能力。\n  学习成本低   过去我们要设计搭建一个完整的微服务架构，比如SpringCloud,Dubbo等，免不了需要改变我们传统的编程思想，学习复杂的架构框架，例如SpringCloud,其包含各类组件10余个，基本与服务业务本身没有直接关系。对于大多数业务开发者来说是一个高高的门槛。但是使用ServiceMesh架构，由于其最大化的透明，开发者几乎不需要额外学习与业务无关的框架技术。大大降低了学习成本。\n  架构灵活   对于不同的团队组成，可能拥有具有掌握不同开发语言的成员，或者具有成熟的已实现业务系统。如果转变到微服务架构支持更大量级用户，如果使用SpringCloud架构，免不了对系统进行重构甚至重写。面对现实与未来，我们需要逐步落地微服务架构，使用合适的开发语言开发合适的服务，甚至融合多种轻量级架构模式，比如Dubbo,SpringBoot和LNMP架构。\n ServiceMesh架构性能 有人提出，在服务与服务之间增加两层代理对性能会产生较大影响，对于性能问题，我们应该放眼全局，从以下几个方面分析：\n 对于增加代理响应性能问题在所有的微服务架构中都存在。 ServiceMesh的网络代理层一般采用轻量级的高效率的代理实现，其本身性能通常较为优越。 ServiceMesh为了提供更好的治理功能支持，通信模型一般处在应用层，比如处理（http,grpc,mongo,mysql）等协议。如果对性能要求比较高，也可以直接使用4层网络模型。 ServiceMesh一般面向中大型分布式系统，分布式系统直接本身就会有通信消耗，Mesh层相反可以使用更高效的通信协议比如http/2 来优化通过http/1.1协议通信的服务通信过程。  ServiceMesh只对网络进行治理么？ ServiceMesh架构框架是工作在网络通信层面提供一系列服务治理功能，包括：\n 服务发现和负载均衡 高级路由 通信监控和分析 通信安全  对于Rainbond的架构设计来说还通过插件扩展的方式增加以下方面功能：\n 日志处理 数据备份和恢复 服务运维和监控 服务运行环境保障  Rainbond与ServiceMesh Rainbond原生提供全量的ServiceMesh治理功能方案，同时提供了插件化得扩展策略，用户除了使用默认方案以外也可以自定义插件实现。Rainbond与Istio的实现有共同点，也有天然的不同。\n相同点是都实现了基于XDS规范实现全局控制层，支持envoy和istio-proxy。\n不同点是Istio需要依赖Kubernetes等平台工作，微服务架构的支持需要从底层存储与通信到上层的应用层配置全盘考虑，大型的微服务架构是离开不了自动化管理应用的PaaS平台的。Rainbond从硬件层，通信层，平台层实现不同的控制逻辑，既兼容已有的微服务架构，同时提供了完整的ServiceMesh微服务架构实践。包容的架构形式让已有的应用服务化变得可落地。\nRainbond提供给用户的体验是最大化的透明，即用户将服务运行于Rainbond即已经构成了微服务架构，而无需先学习微服务架构知识，再考虑自己的服务如何改造，最后再落地。\n  \n如下图可知，Rainbond的网络治理插件通过Sidecar的方式在应用的同一个网络命名空间，同一个存储空间，同一个环境变量空间内动态启动第三方插件服务，例如envoy服务，通过与Rainbond应用运行时通信完成从应用空间到平台空间的数据交换，实现平台对应用通信的控制。   \n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/service_mesh/service-define/",
	"title": "服务化定义",
	"tags": [],
	"description": "Rainbond对服务抽象的定义",
	"content": " 服务的定义 Rainbond服务组件即服务，所有运行于Rainbond的服务，组件Rainbond默认按照服务化的管理方式进行运维和治理。\n怎么理解这句话呢？我们从以下几个方面来解读：\n 我们通常在了解微服务架构的开始阶段总是考虑的是如何进行服务化拆分或规划，这个过程显得很复杂，从而导致微服务落地难。我们试想为什么不能是直接将已有的业务先定义为一个服务先融入到微服务架构中去，这样我们就可以开始新服务的开发或老服务的逐步拆分，走循序渐进 数据库中间件也是服务，微服务架构中我们一般推荐每个业务服务具有自己的数据库。当然也可以共用数据库。云原生下数据库也是服务，它可以独立维护和升级，某些云数据库也需要通信治理和负载均衡。 异构的微服务架构在Rainbond都是服务，比如已经使用SpringCloud开发的微服务架构，部署到Rainbond以后，Rainbond统一管理SpringCloud的所有组件之间的通信。对于单独的SpringCloud架构，它是不维护比如业务与配置中心、业务与数据库的通信的。  "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/service_mesh/service-re-dis/",
	"title": "服务注册和服务发现",
	"tags": [],
	"description": "基于服务注册和服务发现建立服务之间的透明通信",
	"content": " 服务注册 服务为什么需要注册 在云原生环境下，服务的通信地址可能是不确定的，根据生命周期的变化而变化，同时其还有可能有多个运行实例。那么其他服务需要与去通信的前提是需要发现服务的通信地址，因此服务需要通过服务注册来将自己的通信地址和运行状态注册到服务注册中心，比如SpringCloud架构有eureka注册中心。\n服务注册粒度和范围 Rainbond服务注册的粒度是端口级别，也就是说如果服务组件有多个端口它可以分别控制注册。同时为了区分服务是对外网提供服务（通过应用网关）还是对内网提供服务（通过ServiceMesh）,Rainbond为服务的每个端口设置了两种注册范围。\n服务注册方式 由于Rainbond不同于SpringCloud架构还提供了服务运行环境，因此Rainbond的服务注册是自动的，即服务实例启动就会注册到注册中心。但是需要用户指定注册范围，开启了对内服务或者对外服务。\n服务发现 服务发现与服务注册是对应的概念，即服务A希望访问服务B时，需要先获取对方的服务地址。Rainbond提供了两种服务发现策略。\n声明式服务发现 所谓声明式服务发现即服务A需要访问服务B时，需要显式的在Rainbond设置依赖关系，即A依赖B。当建立依赖关系以后，服务A的同一个网络空间内的Mesh服务会通过XDS协议从Rainbond服务注册中心获取服务B的所有运行健康的服务实例，从而建立本地的监听来对服务B进行负载均衡。 对于服务A来说，访问B的方式是固定的本地地址，比如访问服务B的8080端口，访问地址即是127.0.0.1:8080。此地址可以在代码中固定配置或通过相应的环境变量获取。 由此可以得出，Rainbond的服务发现是对业务层透明的，即用户的业务不需要处理服务发现的逻辑，Mesh层会自动完成。根据Mesh层的自定义路由配置和负载均衡算法配置，目前此方式主要支持无状态服务、单实例有状态服务和可以无差别多实例运行的有状态集群服务。\n基于DNS的服务发现 除了上文提到的服务类型，还有一类服务通信比较特殊，比如以下场景：\n 集群化服务，支持水平扩容，实例之间需要通信。比如zookeeper、etcd等 主从集群服务，从实例需要与主实例通信。比如Mysql主从集群，Redis主从复制集群  对于上诉服务主要涉及到同一个服务的多个实例间通信。此类需求必须将服务类型设置为有状态服务\n通过固定的DNS解析的方式进行服务发现：\n对于已经部署的有状态服务，我们可以进入容器查看主机名，如下图：\n从中你可以看到，服务实例的主机名是按照如下规则生成的：\n服务别名-服务实例编号.服务别名.租户ID.svc.cluster.local  对于不同的服务涉及的变量主要如下：\n 服务别名，可以通过获取环境变量SERVICE_NAME 获取 服务实例编号，根据实例数量从0开始依次编号。它们的启动顺序和更新数据都会按照编号顺序进行，因此一般编号0会作为特殊实例，比如主从集群的主实例。 租户ID，可以通过获取环境变量TENANT_ID 获取  通过上述分析你应该已经理解了，当你需要发现当前服务的所有已运行实例地址时，可以以DNS的nslookup方式获取服务别名.租户ID.svc.cluster.local域名的NS记录。此方式有很多现成的实现工具.比如参考： cockroachdb服务源码\n如果需要与主节点通信，直接请求主节点的域名即可。比如 服务别名-0.服务别名.租户ID.svc.cluster.local\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/service_mesh/service-connection/",
	"title": "服务通信治理(完善中)",
	"tags": [],
	"description": "讲解Rainbond对服务（HTTP,gRPC,TCP）的治理原理",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/service_mesh/service-config/",
	"title": "服务配置管理(完善中)",
	"tags": [],
	"description": "Rainbond对服务化配置的支持",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/service_mesh/service-integration/",
	"title": "ServiceMesh架构与其他服务化架构的集成(完善中)",
	"tags": [],
	"description": "讲解Rainbond与与其他服务化架构的集成的原理和方案",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/service_mesh/service-security/",
	"title": "服务安全(完善中)",
	"tags": [],
	"description": "讲解Rainbond对服务安全提供的机制",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/service_mesh/service-operate/",
	"title": "服务运维管理(完善中)",
	"tags": [],
	"description": "讲解Rainbond对服务的自动化运维机制，关于日志管理、分布式跟踪和业务监控",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/",
	"title": "DevOps实践",
	"tags": [],
	"description": "",
	"content": "本章内容包括：\n Jenkins与Rainbond对接部署应用  Rainbond对接Jenkins基于Git仓库与镜像构建的服务进行自动CI、CD实践\n 基于源码的自动CI流程创建  Rainbond基于Git仓库源码构建的服务进行自动CI实践\n 离线环境下的Java源码构建  Rainbond离线环境下的Java源码构建的基础环境搭建\n Maven 多模块源码构建  Rainbond Java源码多模块构建\n Maven项目源码构建实践之私有仓库对接  讲解Rainbond源码构建系统对接企业私有Maven仓库的实践\n 对接私有源码仓库（Git、Svn）  讲解Rainbond如何获取私有源代码仓库进行源码构建\n 应用A/B测试实践  基于Rainbond的应用A/B测试操作方案详解\n 应用灰度发布实践方案  Rainbond应用灰度发布操作方案详解\n 无影响滚动升级无状态应用  无影响滚动升级无状态应用\n 服务配置文件实践  Rainbond为服务添加配置文件的方法实践\n 通过应用市场做应用交付与升级  基于Rainbond做应用交付与升级\n "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/spring_cloud/",
	"title": "SpringCloud应用部署运维",
	"tags": [],
	"description": "全面讲解Rainbond支持SpringCloud服务架构的应用部署和运维",
	"content": "本章内容讲解SpringCloud微服务架构应用在Rainbond部署的原理和实践:\n 本章文档内容正在完善中\n  Spring Cloud 微服务部署在 Rainbond 的优势  讲解传统springcloud微服务为何要部署在Rainbond\n Spring Cloud 微服务与 Service Mesh 的融合  讲解Spring Cloud微服务与Rainbond原生Service Mesh微服务如何融合\n Spring Cloud 微服务部署在 Rainbond 的案例  一个部署在Rainbond的真实Spring Cloud案例\n "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/jenkins-rainbond/",
	"title": "Jenkins与Rainbond对接部署应用",
	"tags": [],
	"description": "Rainbond对接Jenkins基于Git仓库与镜像构建的服务进行自动CI、CD实践",
	"content": " 概述 如果您现在已经有了自己的CI工作流程，并且想在云帮中持续部署您的应用，那么本文将引导您将自己的应用部署到云帮并设置持续部署。考虑到Jenkins是目前主流的持续集成工具，并且它在源码测试和Pipline方面已经做得非常成熟，所以我们提供了针对Jenkins的集成方案。一般情况下，我们的源码在经Jenkins的构建和集成后，产出的应用可能是源码格式或镜像。 Rainbond支持应用持续部署，下面我们来分别说明一下jenkins与rainbond对接如何把源码和镜像格式应用部署到云帮。\n构建自己的持续部署流程 在云帮的应用市场中有丰富的应用可以安装使用，您可以使用这些应用构建自己的工作流。我们使用GitLab或GitHub开源代码仓库，Jenkins集成工具与Rainbond对接实现CI、CD。\n源码 我们以Spring Boot demo为例，https://github.com/ITboy6/spring-boot-mysql-demo 对接的点是jenkins进行代码检测（可使用Sonar插件来实现），构建完之后把打包好的jar包和所需文件放在target目录下，rainbond构建时只需要拉target一个目录，进行源码自动部署。\n1. Jenkins配置  Jenkins安装所需插件：系统管理 \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; 安装需要用到的相关插件\n Jenkins配置测试工程: 新建任务\n  这一步是把所需文件及打包好的jar包都放到target目录下，并push到代码仓库。使用API触发rainbond自动构建。\n2.Rainbond配置  需要有一个创建好的源码应用\n 如何使用API触发自动构建\n  通过开启API自动构建返回的url，POST方法调用API，携带秘钥即可触发API自动构建，秘钥可以自定义设置。\nAPI使用：\ncurl -d '{\u0026quot;secret_key\u0026quot;:\u0026quot;\u0026lt;秘钥\u0026gt;\u0026quot;}' -H \u0026quot;Content-type: application/json\u0026quot; -X POST \u0026lt;API地址\u0026gt;  在Jenkins构建流程中添加即可\n镜像  Jenkins构建完成后，会产出镜像并且会push到DockerHub\n 在云帮中创建一个镜像格式应用\n 在云帮中生成触发镜像仓库的Webhook，将该webhook添加到DockerHub中，使DockerHuab每次更新镜像完成后调用该API\n  "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/spring_cloud/spring-cloud-advantage/",
	"title": "Spring Cloud 微服务部署在 Rainbond 的优势",
	"tags": [],
	"description": "讲解传统springcloud微服务为何要部署在Rainbond",
	"content": " 概述 目前很多公司已经拥有了基于 Spring Cloud 微服务框架开发的业务系统。作为老牌成熟的微服务架构，Spring Cloud 微服务框架为企业业务开发提供了诸多好处。 我们不用去探讨这些好处是什么， Spring Cloud 巨大的市场应用基数已经指明了它的价值。但是它是否是完美无瑕，再无可补足之处呢？世界上没有完美的产品， Spring Cloud 也是如此，以下这些缺点亟待完善：\n 单个组件没有办法很好的管理 难以找到性能监控的方案 难以灵活的伸缩以适应业务并发 部署起来比较麻烦，包括微服务组件本身以及相关的数据库、中间件  针对以上4点，Rainbond平台可以进行天然的补足。\n支持单个组件的全生命周期管理 Rainbond 会把 Spring Cloud 的每个微服务组件单独看待，并可以针对每个组件进行深度的管理，比如：\n 开启、关闭、重启、构建、删除、滚动更新、版本回滚 性能监控 日志管理 垂直/水平伸缩 基于依赖关系的服务发现与注册 持久化存储以及服务组件间的共享存储 端口设置以及域名配置 插件扩展 构建源设置，包括 MAVEN 各种详细参数的设置、配置自动触发构建机制 自定义环境变量配置、健康检测机制、权限管理   了解服务管理的详情，请参见文档： 服务管理\n 性能监控 Rainbond 支持插件扩展方式的性能监控方案，支持对基于 Http、Mysql 协议的应用进行 平均响应时间、吞吐率、在线人数 的监控。并检测最近5分钟内耗时做多的 url 排行，对于调试系统性能有指导作用：\n 了解性能监控的详情，请参见文档： 性能监控\n 垂直/水平伸缩 Rainbond 支持一键进行伸缩，这种伸缩包含两个层面：\n 垂直伸缩：伸缩单个服务组件所使用的内存大小 水平伸缩：为服务组件启动多个后端实例，并自动配置负载均衡  Spring Cloud 微服务设计已经将程序与数据分离，所以将服务组件视作无状态服务直接进行水平伸缩进行快速扩容，达成的效果如下：\n 单个服务组件伸缩只需要一键   多实例服务组件在拓扑图中相应表现   注册中心正常注册  基于应用市场的快速部署 得益于 Rainbond 独有的应用市场机制，在首次部署完成后，我们可以讲整套 Spring Cloud 微服务（包括所有微服务组件以及数据库等中间件）打包发布到应用市场中去。发布完成后，再次安装只需要从应用市场一键安装，极大的简化了部署流程。\n在首次部署 Spring Cloud 的过程中，对所使用的诸如 Mysql Redis Rabbit 等中间件，Rainbond 公有云市提供了制作好的市场应用，可供拉取后一键安装。免除了传统部署中搭建各种中间件的麻烦。\n 了解应用市场详情，请参见文档：应用市场\n "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/autobuild/",
	"title": "基于源码的自动CI流程创建",
	"tags": [],
	"description": "Rainbond基于Git仓库源码构建的服务进行自动CI实践",
	"content": " 概述 对于从Github、Gitlab、Gogs、Gitee仓库源码构建的应用， Rainbond 提供基于WEBHOOKS的自动部署功能。\n实践场景 Rainbond官方文档系统部署在我们的公有云环境中。现在以此场景为例，演示如何实现源码的自动部署。\n- 项目源码地址： rainbond-docs\n操作配置方式  基于源码创建服务，参考文档 从源码创建服务 进入服务管理-构建源管理-打开Git-Webhook功能，可以获取到hook地址。 参考文档 服务自动构建设置 前往Github或其他Git server配置Webhooks.  值得注意的是：\nContent type 选项务必选择 application/json\n触发方式 webhook配置完成后，再次提交代码，当Commmit信息包含“@deploy”时将自动触发应用自动部署\n 触发测试  - 提交信息\n- 成果\n这篇文档在提交代码后无需任何其他操作即可上线，即是触发自动部署的成果。\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/spring_cloud/spring-cloud-merge/",
	"title": "Spring Cloud 微服务与 Service Mesh 的融合",
	"tags": [],
	"description": "讲解Spring Cloud微服务与Rainbond原生Service Mesh微服务如何融合",
	"content": " 概述 这篇文档，着重解决一个问题：Spring Cloud 融合于 Rainbond 原生 Service Mesh 的正确姿势是什么样子的。\nRainbond 原生支持 Service Mesh 微服务架构。也就是说，无论原来是什么，只要部署在 Rainbond 上，那么就天然的成为了 Service Mesh 微服务。这也是 Service Mesh 微服务架构的一大特点：对原应用无侵入。\nSpring Cloud 部署在 Rainbond 上后，整套业务即是完整的 Spring Cloud 微服务，又是一套 Service Mesh 微服务。那么如何使业务系统即保留了原有 Spring Cloud 微服务架构的特点，又能享受到 Service Mesh 带来的种种好处呢？这就涉及到了Spring Cloud 微服务与 Service Mesh 的融合。\n融合的核心思想，就是 Spring Cloud 框架维护的功能，保持不变； Spring Cloud 框架无法维护的功能，交给 Service Mesh 和 Rainbond。\nSpring Cloud 不维护什么 我不会去深入讨论 Spring Cloud 微服务框架都维护了什么，这样的帖子网上有很多。\n在这里，我想说明的是，当读者选择将自己原有的 Spring Cloud 微服务部署在 Rainbond 时，有哪些工作应该由 Rainbond 来完成。\n向 eureka 的注册 eureka 注册中心，是 Spring Cloud 微服务框架中，标准的注册中心解决方案。微服务框架中的 Service provider(服务提供者) 将自己的服务地址注册于 eureka 中，供 Service consumer（服务消费者） 远程调用。这种服务注册与发现的机制，是微服务架构中为了将原来的一站式服务拆解为若干个独立的服务并相互解耦，却又能相互交互所设计的。基于这种机制，所有的 Spring Cloud 微服务组件，可以动态的获悉自己需要的 Service Provider 的服务地址；也可以摇身一变，将自己注册为 Service Provider 对其他组件提供服务。\n然而，就是这么一种灵活的服务注册/发现机制，却不会维护其它服务组件向 eureka 自身注册这一动作。向 eureka 注册的地址，往往是在配置文件里配置的，例如码云6K+星Spring Cloud项目 PIG后台管理框架 中，设定的 eureka 注册方式如下：\nhttps://gitee.com/log4j/pig/blob/master/pig-auth/src/main/resources/bootstrap.yml\n# 注册中心配置 eureka: instance: prefer-ip-address: true client: service-url: defaultZone: http://pig:pig@pig-eureka:8761/eureka/  Rainbond 中会将无法解析的域名，如 `pig-eureka` 解析为 `127.0.0.1`  在 Rainbond 中，可以借助于依赖关系，将微服务组件和 eureka 连接起来，帮助 Spring Cloud 完成注册这一动作：\n eureka 本身开启端口对内服务，向 Rainbond 平台完成自身 Service Mesh 层的服务注册\n 其它微服务组件通过依赖关系连接 eureka ，即可在不做任何变更的情况下，完成向 eureka 的服务注册以及服务订阅\n  对接各类中间件 一套完整的 Spring Cloud 微服务体系中，必然会采用多种数据中间件。以 PIG 为例，搭配使用 MySQL 作为数据存储、 REDIS 作为缓存。而在 Spring Cloud 中，这类中间件的对接方式也是通过配置文件配置的。并不会在微服务框架中有其它的注册机制。那么同理可以由 Rainbond 的依赖关系来将微服务与服务中间件连接起来。\n服务组件启动顺序 Spring Cloud 微服务组件的启动顺序是比较重要的，一个组件在所依赖的服务没有启动前自行启动，是可能引起错误的。Spring Cloud 微服务框架本身不会维护服务组件的启动顺序，这一问题可以由 Rainbond 来解决。\n在 Rainbond 5.1 版本后，我们支持了基于依赖关系的启动顺序控制。启动先后逻辑为被依赖的服务先启动，只有当前服务所依赖的服务全部正常启动后，才会开始启动流程。\n必须指出的是，在这个启动控制链条中，pig-gateway 指向 pig-auth 的依赖关系，其意义只作为启动顺序控制策略，不作为正常的依赖关系使用。  Spring Cloud 适配 Rainbond 为了将 Spring Cloud 更好的融入到 Rainbond 的体系中来，建议使用下面的配置来进行适配：\n注册IP 在保留了 eureka 这种 Spring Cloud 原生的服务注册发现机制的前提下，我们需要所有的微服务组件组册自己的真实IP作为服务地址。微服务组件间的组网策略，Rainbond 会自行解决，关键配置类比如下：\nhttps://gitee.com/log4j/pig/blob/master/pig-auth/src/main/resources/bootstrap.yml\n# 注册中心配置 eureka: instance: prefer-ip-address: true  心跳检测与快速下线 Rainbond 支持每个微服务组件的全生命周期管理。在我们对某个组件进行配置并点击更新后，我们希望在 eureka 中，在新实例上线后，已经被关闭销毁的旧实例可以快速下线，确保注册中心中的服务注册地址没有不可用项。关键配置如下：\n# eureka server配置 eureka: server: enable-self-preservation: false #关闭自我保护 eviction-interval-timer-in-ms: 4000 #清理间隔（单位毫秒，默认是60*1000）  # eureka client配置 eureka: instance: lease-expiration-duration-in-seconds: 30 #服务过期时间配置,超过这个时间没有接收到心跳EurekaServer就会将这个实例剔除 lease-renewal-interval-in-seconds: 10 #服务刷新时间配置，每隔这个时间会主动心跳一次  上述配置适用于于测试场景以及调试场景。如果服务已经趋于稳定，并决定应用于生产环境，则建议自行设置合适的配置方案。  "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/spring_cloud/spring-cloud-case/",
	"title": "Spring Cloud 微服务部署在 Rainbond 的案例",
	"tags": [],
	"description": "一个部署在Rainbond的真实Spring Cloud案例",
	"content": " 示例项目详情 本文档以Pig 快速开发框架为例，演示如何在Rainbond上部署一套完整的Spring Cloud项目。\nPig Microservice Architecture V2.1.0：\n 基于 Spring Cloud Finchley 、Spring Security OAuth2 的RBAC权限管理系统 基于数据驱动视图的理念封装 Element-ui，即使没有 vue 的使用经验也能快速上手 提供对常见容器化支持 Docker、Kubernetes、Rancher2 支持 提供 lambda 、stream api 、webflux 的生产实践  模块说明：\npig ├── pig-ui -- 前端工程[80] ├── pig-auth -- 授权服务提供[3000] └── pig-common -- 系统公共模块 ├── pig-common-core -- 公共工具类核心包 ├── pig-common-log -- 日志服务 └── pig-common-security -- 安全工具类 ├── pig-config -- 配置中心[8888] ├── pig-eureka -- 服务注册与发现[8761] ├── pig-gateway -- Spring Cloud Gateway网关[9999] └── pig-upms -- 通用用户权限管理模块 └── pigx-upms-api -- 通用用户权限管理系统公共api模块 └── pigx-upms-biz -- 通用用户权限管理系统业务处理模块[4000] └── pigx-visual -- 图形化模块 ├── pigx-monitor -- Spring Boot Admin监控 [5001] └── pigx-codegen -- 图形化代码生成[5003] └── pigx-zipkin -- 微服务链路跟踪[5002]  上述的模块，可以分为类库与服务两类，读者可以对比自己的Spring Cloud项目：\n 构建后产生jar包，用来实现各种功能的类的集合，即是类库，如Pig中的pig-common模块 构建后产生jar包或者war包，通过 java -jar 或者tomcat等方式启动，开放某个端口提供服务的，即是服务，如Pig中的pig-eureka模块  只需要将服务模块在Rainbond中构建出来即可。  经过梳理，该项目需要构建的服务组件包括：\n   启动顺序 服务组件名称 运行端口 组件功能     1 pig-eureka 8761 spring cloud 服务发现注册与发现   2 pig-config 8888 spring cloud 配置中心   3 pig-gateway 9999 spring cloud 微服务网关   4 pig-auth 3000 授权服务提供   5 pig-upms-biz 4000 通用用户权限管理系统业务处理模块   6 pig-monitor 5001 Spring Boot Admin监控   7 pig-codegen 5003 图形化代码生成   8 pig-zipkin 5002 微服务链路跟踪   9 pig-ui 80 前端项目（vue项目）    部署环境说明：\n部署pig，需要以下环境支持：\n   中间件或环境要求 版本要求 备注     JDK 1.8 强制要求版本   MySQL 5.7+ 强制要求版本   Redis 3.2 + 强制要求版本   node 8.0 + 用于运行前端项目   npm 6.0 + 用于构建前端项目    项目链接：\n 项目地址 部署文档  模块构建 新建应用，并命名为 spring-cloud\n获取项目克隆/下载地址： https://gitee.com/log4j/pig.git\nJava多模块部署Pig项目 参考JAVA多模块源码构建\n分步部署Pig项目 以pig-eureka为例，演示从源码开始构建流程：\n 为 spring-cloud 添加服务组件 —— 从源码开始 —— 自定义仓库：  点击 新建服务，Rainbond会自动拉取代码，并根据代码根目录下的 pom.xml 自动将代码语言识别为 Java-maven。取消 并构建启动 选项：\n 点击 创建，进入服务组件未部署的页面。编辑 端口 选项卡，开放 pig-eureka 自身端口 8761：  pig-eureka 需要被其它微服务组件访问以进行注册，所以打开对内服务，以便之后创建依赖关系。该组件也提供web页面，显示微服务组件的注册情况与健康情况，所以打开对外服务，以便外部访问。\n 编辑 构建源 选项卡，指定 pig-eureka 构建参数：  由于 Pig 本身是一个多模块的项目，所以需要指定当前服务组件构建的模块。指定的方式是在 构建运行环境设置 中的 Maven构建全局参数：clean dependency:list install -pl pig-eureka -am\n上述的参数指定了普通的子模块构建方式，对于另一种子模块中的子模块，比如 `pig-codegen` 模块，参数指定的方式为： `clean dependency:list install -pl pig-visual/pig-codegen -am`  在v5.1+版本的Rainbond中，可以指定当前服务组件的启动命令。指定的方式是在 构建运行环境设置 中的 启动命令：web: java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app/pig-eureka/target/*.jar ，命令格式与 Procfile 一致。\n 编辑 依赖 选项卡，指定当前服务组件依赖其它服务组件：  各个服务组件之间的依赖关系，可以在创建时指定。所有的 spring cloud 微服务组件都需要依赖 pig-eureka，以 pig-gateway为例，应添加依赖关系如下：\n 所有的设置完成后，即可点击 构建 ，构建完成后，服务组件将自动运行起来。\n 将所有服务组件依次部署完成。\n  部署 Mysql Pig 微服务项目需要部署 Mysql 5.7+ 作为数据源。并在代码仓库中提供了数据库初始化脚本： https://gitee.com/log4j/pig/blob/master/db/pig.sql\n为了能够在数据库启动时即加载初始化脚本，制作了一份 Dockerfile:\nhttps://github.com/dazuimao1990/percona-mysql/blob/pig/5.7/Dockerfile\nFROM percona:5.7.23-stretch LABEL creater=\u0026quot;barnett\u0026quot; ENV MYSQL_VERSION=5.7.23 ENV TZ=Asia/Shanghai ADD docker-entrypoint.sh /run/docker-entrypoint.sh ADD ./run/docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh ADD ./run/mysqld.cnf /etc/mysql/percona-server.conf.d/mysqld.cnf RUN fetchDeps=' \\ ca-certificates \\ wget \\ '; \\ sed -i 's/deb.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list; \\ apt-get update; \\ apt-get install -y --no-install-recommends $fetchDeps; \\ rm -rf /var/lib/apt/lists/*; \\ wget -O /usr/local/bin/env2file -q https://github.com/barnettZQG/env2file/releases/download/v0.1/env2file-linux; \\ chmod +x /run/docker-entrypoint.sh \u0026amp;\u0026amp; chmod +x /usr/local/bin/env2file; \\ apt-get purge -y --auto-remove $fetchDeps EXPOSE 3306 VOLUME [\u0026quot;/var/lib/mysql\u0026quot;, \u0026quot;/var/log/mysql\u0026quot;] # 将代码仓库中 sql 目录下的脚本放到对应的初始化目录下 COPY sql/*.sql /docker-entrypoint-initdb.d/ # change ENTRYPOINT exec some custom command ENTRYPOINT [ \u0026quot;/run/docker-entrypoint.sh\u0026quot; ] CMD [ \u0026quot;mysqld\u0026quot; ]   为 spring-cloud 添加服务组件 —— 从源码开始 —— 自定义仓库：  将服务组件命名为 pig-db，并指定代码分支 pig。\n在代码仓库地址url的最后添加 `?dir=5.7` 可以让Rainbond将构建目录指定为代码仓库根目录下的 `5.7` 文件夹。  为了让数据库正常工作,并且可以被其它依赖的本数据库的应用获取连接信息，需要设置若干环境变量：\n   环境变量名称 环境变量值 设置位置     MYSQL_USER root 连接信息   MYSQL_HOST 127.0.0.1 连接信息   MYSQL_PORT 3306 连接信息   MYSQL_ROOT_PASSWORD mysqlpassword 连接信息   MYSQL_DATABASE pig 连接信息    通过修改 pig-config 中的配置文件，来定义多个微服务组件连接数据库的配置：\npig/pig-config/src/main/resources/config/pigx-auth-dev.yml pig/pig-config/src/main/resources/config/pigx-upms-dev.yml pig/pig-config/src/main/resources/config/pigx-codegen-dev.yml pig/pig-config/src/main/resources/config/pigx-zipkin-dev.yml.yml  修改示例如下：\n# 数据源 spring: datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.jdbc.Driver username: ${MYSQL_USER} password: ${MYSQL_ROOT_PASSWORD} url: jdbc:mysql://${MYSQL_HOST}:${MYSQL_PORT}/${MYSQL_DATABASE}?characterEncoding=utf8\u0026amp;zeroDateTimeBehavior=convertToNull\u0026amp;useSSL=false\u0026amp;useJDBCCompliantTimezoneShift=true\u0026amp;useLegacyDatetimeCode=false\u0026amp;serverTimezone=Asia/Shanghai  部署 Redis 通过Rainbond应用市场，可以直接安装 Redis 4.0.13。\n该版本Redis默认提供连接信息：\n通过修改 pig-config 中的 pig/pig-config/src/main/resources/config/application-dev.yml 来定义所有服务组件连接Redis的配置：\n修改示例如下：\n# Spring 相关 spring: redis: password: ${REDIS_PASS} host: ${REDIS_HOST}  部署 pig-ui pig-ui 是一个由nodejs语言编写的 vue项目，作为整个系统的前端静态页面。Rainbond目前已经支持源码构建 nodejs前端 项目，参考文档：NodeJS前端语言\n为了便于改造项目，所以将项目 fork 了一份进行修改，代码地址：https://gitee.com/dazuimao1990/pig-ui\n参照Rainbond代码支持规范，在代码根目录下添加了识别文件： nodestatic.json\n{\u0026quot;path\u0026quot;:\u0026quot;dist\u0026quot;}  并在代码仓库中添加了nginx配置文件: www/web.conf 用于处理代理转发：\nserver { listen 80; root /app/www; location ~* ^/(code|auth|admin|gen) { proxy_pass http://127.0.0.1:9999; proxy_connect_timeout 15s; proxy_send_timeout 15s; proxy_read_timeout 15s; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } }  利用这份代码进行源码构建，即可完成 pig-ui 服务组件的部署。\n依赖与端口梳理    服务组件名称 依赖 端口对内服务 端口对外服务     pig-ui pig-gateway off on   pig-gateway pig-eureka Redis on off   pig-monitor pig-eureka Redis off off   pig-config pig-eureka off off   pig-upms-biz pig-eureka pig-db Redis off off   pig-zipkin pig-eureka pig-db Redis off on   pig-auth pig-eureka Redis off off   pig-codegen pig-eureka pig-db Redis off off    最终成果 完成部署后，拓扑图如下：\n登陆效果：\n登陆账户密码： admin 123456  "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/offline-java-build/",
	"title": "离线环境下的Java源码构建",
	"tags": [],
	"description": "Rainbond离线环境下的Java源码构建的基础环境搭建",
	"content": " 概述 在交付了很多企业级用户后，我们发现很多用户的环境都是离线的。我们一直在探索离线环境下实现源码构建的方案，以期让这些企业用户可以也可以体验到Rainbond源码构建功能带来的便捷。\n那么，在离线环境下，实现源码构建会有哪些难点呢？其实这个问题的答案就是整套源码构建流程中有那些点对于互联网有依赖：\n- 代码仓库：源码构建过程的起点是一个可用的代码仓库，离线环境下我们不可以使用 Github、Gitee 等基于互联网的代码仓库。Gitlab、Gogs 等私有代码仓库成为了最佳选择。有些用户已经拥有了自己的私有代码仓库，这种情况下，保证Rainbond管理节点所在的服务器可以正常访问到该代码仓库即可；而对于还没有搭建自己的私有代码仓库的用户而言，如何快速搭建一个Gitlab或者Gogs就是离线源码构建需要攻克的第一关。\n- 构建私服：构建私服是指在源码构建过程中，获取依赖包的仓库，常见的有 Nexus、Artifactory 等。有些用户已经拥有了自己的私有构建私服用以管理自己的依赖包，这种情况下，我们提供方案让 Rainbond 可以直接对接私服；而对于还没有搭建自己的构建私服的用户而言，Rainbond自带的 rbd-repo 组件可以作为本地仓库使用。\n- 应用运行时：应用运行时是指服务运行所依赖的环境，比如对于Java应用而言，运行时就是环境中安装的 Jdk。对于用户而言，离线环境如何配置好应用运行时是离线源码构建最大的挑战。\n在明确了上述难点后，接下来的文章，会以Java应用构建为例，指引用户一步步攻克这些难关，最终达成离线源码构建的目标。\n离线部署代码仓库 在离线环境下，推荐使用平台的应用离线导入功能，快速导入 Gitlab 应用并安装使用。\n需要事先获取离线资源：Gitlab应用包 Gogs应用包\n- 访问Rainbond应用管理平台，并导入离线应用包\n Gogs离线导入方式和Gitlab一致。\n 至此，我们已经拥有了一个私有化的代码仓库。可以通过它来托管代码，并可以通过它实现自动构建。\n离线对接/部署构建私服 Java源码基于Maven构建过程中，会根据 pom.xml 文件解析依赖关系，并前往指定的构建私服拉取依赖包。而在Rainbond中，安装了默认的源码构建包仓库 rbd-repo ，这个组件既可以作为已有私服的代理，也可以用来搭建本地私服，来应对不同用户的需求。\n- 已有私服的对接\n- 搭建本地仓库，并导入jar包\n离线配置应用运行时 本节提供一个在应用中离线安装运行时（Jdk）的方案，这个方案会运行起一个私服仓库服务，这个私服仓库可以负责安装java运行所需要的Jdk环境。 需要事先获取离线资源：Java运行时私服仓库服务镜像\n 有网环境下载离线资源镜像  docker pull rainbond/buildpack:java-v5.1.1 docker save rainbond/buildpack:java-v5.1.1 \u0026gt; rainbond-buildpack-java-v5.1.1.tgz   导入镜像  首先，将镜像导入首个管理节点。\ndocker load -i rainbond-buildpack-java-v5.1.1.tgz docker tag rainbond/buildpack:java-v5.1.1 goodrain.me/buildpack:java-v5.1.1 docker push goodrain.me/buildpack:java-v5.1.1   运行私服仓库服务  编辑配置文件，将该服务运行起来。\nvi /opt/rainbond/conf/base.yaml  在最下面一行添加如下段落\n- name: rbd-java-buildpack endpoints: - name: BUILDPACK_ENDPOINTS protocol: port: 2017 health: name: rbd-java-buildpack model: http address: 127.0.0.1:2017/lang/ max_errors_num: 3 time_interval: 30 after: - docker type: simple pre_start: docker rm rbd-java-buildpack start: \u0026gt;- docker run --name rbd-java-buildpack --network host -i goodrain.me/buildpack:java-v5.1.1 stop: docker stop rbd-java-buildpack restart_policy: always  启动服务\nnode service update  验证服务是否运行\ngrctl cluster   对接rbd-repo并修改远程仓库  所有节点rbd-repo都需要调整  修改远程仓库 pkg_lang 对应URL为 http://\u0026lt;首个管理节点IP\u0026gt;:2017/lang/\n至此，离线环境下的Java源码构建环境就配置完成了。\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/java-multi-module-build/",
	"title": "Maven 多模块源码构建",
	"tags": [],
	"description": "Rainbond Java源码多模块构建",
	"content": " Maven 多模块项目构建识别策略 Maven 多模块项目是根据 pom.xml 文件(下面简称 pom)来划分的, Rainbond 对它的识别也是建立在 pom 的基础上的. 主要是识别出具体模块(module)的构建命令和启动命令. 构建命令的作用是指定需要构建的模块, 是类似于 \u0026ldquo;mvn install -pl \u0026lsquo;module name\u0026rsquo; -am\u0026rdquo; 的 mvn 命令. 启动命令的作用是在构建完成后, 指定需要执行的 Jar 包, 是类似于 \u0026ldquo;web: java $JAVA_OPTS -jar *.jar\u0026rdquo; 的命令.\n识别策略:\n 根据根 pom 中的 modules 中的 module 标签, 找到相应模块下的 pom. 如果 pom 中的 packing 标签的值是 jar(war), 则解析出当前 pom 对应的模块名和 jar(war)包名. packing 标签的值为空, 会认为是 jar. 模块名由名级父 pom 中的 module 标签的值组成, 用 \u0026ldquo;/\u0026rdquo; 分割, 类似于: rbd-worker/rbd-thirdparty. jar(war) 包名默认是 ${artifaceId}-*.jar(war). 如果设置了 finalName 标签, 则会使用 finalName 标签的值; 如果finalName 标签使用了变量${project.name}或${project.aritfactId}, 则会使用变量对应的值; 如果使用了其他的变量, 则直接用 * 代替, 即: *.jar(war). 如果 pom 中的 packing 标签的值是 pom, 且 modules 标签中的 module 多于 1, 则重复 1 ~ 5.  因为很多地方都使用了通配符 * , 在构建出来的 jar(war) 不只一个时, 识别出来的 jar(war) 包可能不能确定唯一的包; 又或者识别出来的 jar(war) 包有误, 这时候就需要用户手动进行修改.  多模块项目源码规范 因为 Rainbond 对 Maven 多模块项目的识别是建立在 pom 的基础上的, 所以大家在书写的 pom.xml 文件, 符合 pom 的规范就好. pom 的规范请参考: POM Reference\n案例 这里以SPRING CLOUD 微服务部署在 RAINBOND 的案例一文中的Pig项目中Java源码部署部分为例，一次性多模块部署Pig项目(其他依赖如Mysql默认安装好)。\n模块构建 新建应用，并命名为spring-cloud\n获取项目克隆/下载地址： https://gitee.com/log4j/pig.git\n 1. 从源码创建，选择自定义源码，填写项目地址   2. 如果是多模块项目会识别出来,选择进入多模块构建配置项   3. 根据Spring Cloud 微服务部署在RAINBOND的案例一文可知如下组件需要部署运行, 勾选后构建   4. 构建完成效果图(仅Java部分)   5. 查看某一应用构建源信息   这样Pig项目多模块构建就完成了，后续其他步骤参考SPRING CLOUD 微服务部署在 RAINBOND 的案例\n "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/connection-maven-repository/",
	"title": "Maven项目源码构建实践之私有仓库对接",
	"tags": [],
	"description": "讲解Rainbond源码构建系统对接企业私有Maven仓库的实践",
	"content": " Maven仓库镜像 Maven仓库 Maven仓库主要分两种:\n Remote仓库：相当于公共仓库，大部分都是可以通过URL的形式进行访问 Local仓库: 存放于本地磁盘的文件夹(其路径类似.m2/repository)  其中Remote仓库主要有3种：\n 中央仓库: http://repo1.maven.org/maven2/ 私服: 自建的Maven仓库 其他公共仓库: 其他公网可以访问的Maven仓库  仓库种主要是存放Maven构建时需要的各种构件(jar包或者Maven插件)，当向仓库请求构件时，会先检查本地仓库是否已经存在，不存在会向远程仓库请求并缓存到本地。\nMaven镜像仓库 mirror相当于一个拦截器，它会拦截Maven对remote仓库的相关请求，把请求里的remote仓库地址，重定向到mirror里配置的地址。\n示例1：mirrorOf的值为central，表示该配置为中央仓库的镜像，任何对于中央仓库的请求都会转发给镜像仓库http://192.168.1.200:8081\n \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;maven.goodrain\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;goodrain maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://192.168.1.200:8081/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt;  示例2: mirrorOf的值为*,则表示该配置是所有仓库的镜像，任何对远程仓库的请求都会转发到这个镜像\n\u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;maven.all.goodrain\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;goodrain all maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://192.168.1.200:8081\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt;  其他高级操作 \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; # 表示所有远程仓库 \u0026lt;mirrorOf\u0026gt;external:*\u0026lt;/mirrorOf\u0026gt; # 除本地仓库外到远程仓库 \u0026lt;mirrorOf\u0026gt;repo1,repo2\u0026lt;/mirrorOf\u0026gt; # 匹配repo1和repo2 \u0026lt;mirrorOf\u0026gt;*,!repo1\u0026lt;/miiroOf\u0026gt; # 匹配除repo1外所有远程仓库  通过Rainbond构建Maven项目，如果不禁用Mirror功能，默认情况下，在源码构建时会通过添加全局Maven配置文件来定义mirror,即任何对远程仓库的请求都会重定向至maven.goodrain.me,如果没有将自己的私服对接到rbd-repo则可能导致无法正常下载私服中的构件从而导致源码构建失败。默认配置如下\n \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;goodrain-repo\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;goodrain repo\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.goodrain.me\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt;  由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像仓库，因而将无法下载构件。  Rainbond构建源Maven镜像仓库参数说明 1. 禁用Maven Mirror: 默认不禁用镜像功能，即在源码构建时会添加Maven全局配置文件，重定向仓库请求至镜像仓库 2. MAVEN MIRROROF配置: 默认仅镜像central(中央仓库)，如果为空会默认镜像全部仓库 3. MAVEN MIRROR_URL: 默认镜像仓库地址为maven.goodrain.me 其中仅当未禁用Maven Mirror时MAVEN MIRROROF和MIRROR_URL才生效   更多构建源参数说明参考\n `maven.goodrain.me`默认是由Rainbond内置的rbd-repo提供服务的。  Rainbond组件rbd-repo简述 Rainbond通过rbd-repo组件实现了Maven仓库管理功能，该组件基于 Artifactory 开源版本实现,其源码托管于goodrain/rbd-repo,如果需要自定义自己的rbd-repo可以参考rbd-repo指南\nrbd-repo默认内置镜像了如下远程仓库:\n aliyun-central central jcenter spring spring-plugin  如果需要镜像如上仓库，可以通过构建源配置MirrorOF值为central,jcenter\n默认rbd-repo访问地址为：http://管理节点IP:8081, 管理员用户名密码：admin/password\n如果是多管理节点时，对接私有仓库时需要同时配置所有管理节点\n另外rbd-repo中的仓库主要有三种类型，后面会详细介绍Local仓库和Remote仓库使用：\n Local: 本地私有仓库，用于内部使用，上传的组件不会与外部进行同步(作为公司内部私服使用); Remote: 远程仓库, 用于代理及缓存公共仓库, 不能向此类型的仓库上传私有组件(对接公司已有私服使用); Virtual: 虚拟仓库, 不是真实在存储上的仓库，它用于组织本地仓库和远程仓库(maven.goodrain.me)。  Rainbond对接私有Maven仓库 公司内部有自己的Maven私服仓库，可以通过rbd-repo组件来实现与Rainbond的对接。\n需要注意: 如果你的私服是Nexus3或者是阿里云Maven仓库则无法使用rbd-repo进行镜像代理缓存。 解决方案: 法1. 禁用Rainbond的Mirror配置,项目[构建源](/user-manual/app-service-manage/service-source/)里设置并同时启用开启清除构建缓存配置项, pom.xml里定义相关仓库信息 法2. 使用Nexus2或者使用Rainbond内置的rbd-repo服务  示例对接内部私有Maven仓库 下面以一个示例来说明一下对接方法：\n1. 创建Remote类型的仓库  访问 http://管理节点IP:8081 并用管理员账号(admin/password)登录。\n Admin Repositories 选择添加Remote仓库\n选择新建Remote（远程）仓库\nRemote（远程）仓库类型选择Maven\n配置Remote（远程）仓库,其中需要注意Maven的URL可以通过浏览器访问能够正常列出相关构件\nRepository Key：仓库的名称，不能与其他仓库重名，示例的仓库名为： demo-repo\nURL ：远程仓库的地址 如果您外部的Maven仓库是Artifactory搭建，地址类似于 http://\u0026lt;maven域名\u0026gt;/artifactory/list/\u0026lt;仓库名\u0026gt;/ ，如果您的外部仓库是Nexus搭建，地址类似于 http://maven域名/nexus/content/repositories/\u0026lt;仓库名\u0026gt;/\nURL地址填写完成后，可以点击 Test 按钮测试连接的有效性，如果连接有效可以点击 “Save \u0026amp; Finish” 按钮完成创建。\n2. 将新建仓库添加到libs-release虚拟仓库中（重要） 内部仓库默认会创建一个名为 libs-release的虚拟仓库，虚拟仓库（virtual）并不是真实的仓库，它是用于组织本地仓库和远程仓库的逻辑单元。由于云帮镜像了所有仓库地址，因此需要将远程仓库加到虚拟仓库中。\nAdmin——\u0026gt;Repositories——\u0026gt;Virtual 选择 libs-release\n3. 验证添加是否成功 访问http://\u0026lt;管理节点\u0026gt;:8081/artifactory/list/libs-release/或者管理节点访问maven.goodrain.me看能否列出你新添加私服的构件。\n使用Rainbond内置的Maven仓库 如果您没有Maven仓库管理系统，可以直接使用Rainbond内置的Maven仓库管理系统。下面介绍操作步骤：\n 创建 Local 类型的Maven仓库。示例创建一个Local 类型的Maven仓库，名称为 repo-local 向本地仓库repo-local上传自己的jar包 查看依赖声明信息 将repo-local添加到libs-release 虚拟仓库中  访问http://\u0026lt;管理节点\u0026gt;:8081/artifactory/list/libs-release/或者管理节点访问maven.goodrain.me看能否列出你新添加的构件。\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/micro/",
	"title": "微服务架构方面",
	"tags": [],
	"description": "",
	"content": " 微服务架构专题 本章内容包括：\n ServiceMesh微服务架构  全面讲解Rainbond内置的ServiceMesh微服务架构支持原理\n SpringCloud应用部署运维  全面讲解Rainbond支持SpringCloud服务架构的应用部署和运维\n "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/practices/",
	"title": "应用管理实践",
	"tags": [],
	"description": "这里积累Rainbond丰富的实践",
	"content": "本章内容包括：\n 第三方服务实践-统一管理集群内服务访问集群外数据库  集群内服务访问无法或尚未迁移到 Rainbond 的集群外数据库或其他服务。\n 第三方服务实践-通过Rainbond应用网关访问企业内网应用  使用Rainbond第三方服务管理, 让应用网关访问企业内网的其他服务\n "
},
{
	"uri": "http://skyzhangyf.github.io/faqs/",
	"title": "FAQs",
	"tags": [],
	"description": "",
	"content": " 一般问题 1.好雨是做什么的、什么时候成立的？  好雨是一家致力于企业数字化转型建设的云计算服务商，通过Rainbond PaaS产品和服务，实现加速数字业务快速交付、赋能企业IT资源，让云落地进入企业，帮助企业获得面向未来的竞争力和创新能力。2015年成立至今，好雨产品服务以用户业务和最佳技术为驱动，已获得上万用户的体验和使用，其中包括百余家政府、能源、金融、教育行业大中型用户。2017年12月，好雨开放Rainbond源代码，Rainbond进而成为了国内首个开源的无服务器PaaS，深受广大技术爱好者和开源社群青睐。 企业官网\n 2.rainbond是什么？  好雨云帮（Rainbond） ：“以应用为中心”的新一代无服务器PaaS平台，作为企业应用操作系统，将数字化业务抽象为“应用”，以云帮（rain-）为纽带（-bond），通过“应用生命周期”的管理，连接应用、数据、基础设施等IT资源，实现业务快速交付，并为企业带来价值增长。\n 企业应用包括：各类信息系统、OA、CRM、ERP、数据库、大数据、物联网、互联网平台、微服务架构等运行在企业内部的各种系统。\n  3.什么是无服务器paas  无服务器PaaS（Serverless PaaS）本身并非没有服务器，而是将搭建、设置、管理等在内的服务器相关工作封装起来，交由第三方供应商全权接管，让用户感受不到服务器的存在。rainbond作为无服务器paas，在对接底层资源后，用户在rainbond上进行应用级别的开发运维工作，不需要担心服务器的细节问题，只需在Serverless PaaS环境中执行应用逻辑。当开发者不再受到底层环境问题的掣肘，从而专注开发伟大的应用，那么他必将持续不断地产生价值。 产品官网\n 4.跟iaas区别  rainbond是paas平台，支持私有化部署在任意集群环境里，包括物理机、虚拟机、云服务器等。 同时，好雨科技为了方便技术爱好者快速体验rainbond产品，提供rainbond+阿里云iaas（杭州+上海）的公有云服务，让您感受到与直接对接iaas不一样的开发运维体验。\n 5.跟rancher的区别、优势对比  rancher是容器级别抽象的管理平台，可以理解为容器管理的ui界面。需要用户对容器技术有很强的掌控能力，在容器级别进行开发运维操作。 rainbond是应用级别抽象的管理平台，以应用为中心，不需要用户学习容器技术，即可享受容器技术带来的价值！如果您需要进行容器级别的操作，同时rainbond还提供web shell 的形式，满足您的使用需求。\n 6.底层是否是容器技术、跟docker、k8s有什么关系  rainbond底层使用容器技术（docker+k8s），V3.7.2及以往版本，采用魔改后的k8s和docker，帮助用户少踩坑，避免重复造轮子。 V5.0及后续版本讲支持社区版K8s和Docker，帮助用户更好的过渡使用rainbond作为应用全生命周期的DevOps平台。\n 7.rainbond是否开源  rainbond于2017年12月12日开源，关注我们： 产品官网 Github Gitee\n 8.功能是否全部开源  rainbond 是以应用为核心的无服务器paas平台，应用作为平台使用的核心抽象，我们把应用管理后台全部功能开源。\n 9.使用开源有什么限制  使用开源rainbond需要遵守GPLv3 License。 详情\n 10.我能用rainbond干什么  Rainbond提供了一种聚焦于应用管理的新一代云计算模式，企业和开发者可以将Rainbond作为公有云或私有云环境下的：\n 持续交付——产品高效上线、快速迭代 高效运维——轻松管理大量服务器 应用市场——提供丰富的一点即用的云端应用 灵活伸缩——支持大用户秒级扩充资源 微服务架构——最成熟的微服务架构解决方案原生支持Service Mesh 云框架——支持各种复杂的技术架构 多数据中心——支持多数据中心管理 多租户——支持租户间的网络与服务隔离 渐进式的混合云——公有云与私有云平滑过渡  \n11.Rainbond对使用者有什么要求？  了解容器化知识和最佳实践将有助于用户使用。\n 12.使用Rainbond对我的开发习惯有哪些影响、我要做出哪些改变？  我们希望开发者能够具备持续部署所开发服务的能力。\n 13.是否支持二次开发？  开源rainbond支持二次开发，但需要遵守GPLv3 License。 开发者文档\n 14.开源和企业有什么不同？  从理念上，开源版更强调用户能够自助使用，好雨仅提供社区支持。 企业版由好雨负责技术落地，强调开箱即用，并通过知识转移等增值服务，让用户具备掌握平台和相关技术的能力。 从功能上，开源版功能支持企业级开发生产环境使用。 企业版额外提供更利于操作使用的管理界面，如资源管理后台、saas应用市场等解决方案，帮助企业更快落地相关技术。 详情\n 15.企业服务报价？  好雨科技提供产品买断or订阅+服务买断or订阅，以及定制开发和技术咨询等增值服务。 最终项目报价在基础报价上根据增值项目作适当调整。项目整体预估价格按照开发者人数、交付客户数量、交付集群规模来综合判断。具体请咨询18701654470（微信\u0026amp;手机）\n 安装问题 1.rainbond是否可以运行在物理服务器和虚拟机上  Rainbond可以很好的部署和运行在 Intel 架构服务器环境及主流虚拟化环境，并支持绝大多数的主流硬件网络\n 2.私有部署如何配置内网dns  Rainbond 安装程序会完成集群DNS的修改。 若你是完全离线的环境，使用Rainbond提供的HTTP域名管理功能，需要离线环境下的DNS支持。\n 3.访问rainbond应该开放什么端口  对外只需要开放80,6060,7070,以及使用tcp协议对外开发的端口默认20000-30000\n 4.rainbond安装支持那些操作系统  支持CentOS 7;Ubuntu 16.04;Debian 9\n 维护问题 1.如何查看rainbond 服务的状态？  UI下通过服务总览页面查询或拓扑图查询，命令行下通过grctl service相关命令查询\n 2.如何上下线节点？  开源版本使用grctl node相关命令对节点进行操作\n 3.如何判断节点状态？  根据grctl node list 展示的结果判断节点状态\n 4.后端创建出多余实例该怎么办？  可以通过kubectl 相关命令手动干预Kubernetes资源。正常情况下不会出现多余实例的情况\n 5.如何查看rainbond各组件日志？  Rainbond各组件在Linux下通过systemd管理，可以通过journalctl命令查询日志。Windows下通过Windows服务管理，日志一般写入到c:\\rainbond\\log目录下。\n 6.如何去掉管理节点的计算属性？  移除配置文件 /opt/rainbond/conf/k8s-worker.yaml, 停kubelet服务systemctl stop kubelet,更新/opt/rainbond/scripts/start-node.sh文件里noderule为manage,重启nodesystemctl restart node\n 7.更新泛解析域名  可以通过grctl domain命令进行操作\n 开发问题 1.Rainbond支持哪些开发语言？  支持Java PHP Python NodeJS Golang 静态HTML .NetCore Dockerfile 等开发语言。\n 2.是否支持.net 语言、是否支持windows应用、是否支持windows服务器部署？  5.0及以后版本支持Windows开发平台的应用管理和计算节点管理。\n 3.是否支持helm？  helm将作为一种语言类型计划于5.1及以后版本支持\n 4.如何配置maven私服？  Rainbond支持对接maven私服，对接方式见 对接Maven私服\n 5.遗留系统是否能运行在rainbond上？  经过众多社区用户验证，大多数遗留系统进行小量的调整即可运行于Rainbond平台。\n 6.如何对接已有ci/cd？  Rainbond推荐推荐Jenkins前置CI系统\n 7.是否支持oracle jdk ？  Rainbond默认提供的源码构建环境使用OpenJDK,你可以根据你的需要更换为OracleJDK。Rainbond不承担版权责任。\n 8.是否支持svn？  支持\n 9.代码拉取失败怎么办？  查看服务构建日志查询错误原因。一般错误包括：未授权、网络不通等等\n 10.Rainbond是否提供镜像仓库管理？  Rainbond数据中心内置镜像存储仓库，我们认为镜像存储为内部资源，用户正常情况下无需关注镜像仓库资源，因此Rainbond不提供镜像仓库管理，对应的是提供应用的构建版本管理和应用市场管理。\n 使用问题 1.重启和更新的区别？  重启是先关闭服务，再启动，一定会影响服务。更新是进行滚动升级，最大程度上不影响服务。\n 2.是否支持资源限额？  租户级资源限额目前属于企业版功能，应用级资源限额通过设置服务内存量限制。\n 3.如何备份平台上的mysql 数据库？  通过安装Mysql数据备份插件\n 4.如何自定义mysql配置？  5.1以前版本主要基于环境变量定义服务配置，5.1及以后版本将支持动态配置文件模版。\n 5.健康检查配置错误导致应用无法启动  启动时健康检查未通过，服务处于异常状态，状态机将认为服务还未启动成功。\n 6.如何查看应用持久化存储挂载的宿主机路径？  通过grctl service get 命令查询\n 7.如何查看应用部署在某个宿主机上？  通过grctl service get 命令查询\n 8.如何在平台外访问平台上的数据库？  应用网关配置TCP访问策略，指定需要访问的数据库服务\n 9.应用是否支持跨数据中心迁移？  支持，备份应用后可以跨数据中心、跨租户迁移。\n 10.如何用环境变量动态配置自己的配置文件？  根据不同的配置文件支持不同，有些配置文件解析器可以直接读取环境变量。如果不能支持的，5.1版本之前可以采用env2config命令重新渲染配置文件。\n 架构问题 1.是否支持dubbo、是否支持spring cloud？  支持，关于SpringCloud查看文档Spring Cloud 微服务架构\n 2.微服务架构 service mesh 是什么？怎么用？  ServiceMesh 简史 一般的字面解释是“服务网格”，作为时下最流行的分布式系统架构微服务的动态链接器，处于服务到服务的通信的专用基础设施层，该层独立于应用程序为服务之间的通信提供轻量级的可靠传递。如果简单的描述的话，可以将它比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控，同样使用 ServiceMesh 也就无须关系服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud、OSS，现在只要交给 ServiceMesh 就可以了。ServiceMesh的出现主要是由于应用虚拟化技术的发展，例如Kubernetes,Rainbond等项目，大大降低了应用的部署和运维复杂度。\nRainbond内置ServiceMesh架构文档：SERVICEMESH微服务架构\n 插件问题 1.插件是什么？怎么用？  应用插件是标准化的为应用提供功能扩展，与应用共同运行的程序，例如：性能分析插件可以实时看到该服务的性能如何，吞吐率、响应时间以及在线人数等；网路治理插件则可以实现智能路由、A/B\u0008测试以及灰度发布等\n文档： 插件管理\n 2.使用服务性能监控插件有什么限制？  目前版本默认提供的性能分析插件仅支持Http、Mysql协议分析，其他端口协议无法正常使用。\n 3.我该如何设计和开发服务插件？  查看文档 : 插件设计与开发\n 更多问题浏览Rainbond社区\n\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/app_startup/",
	"title": "应用处于启动状态",
	"tags": [],
	"description": "",
	"content": " 确定集群是否正常 grctl cluster  查看应用状态 # 5.1.3版本支持伸缩处获取相关命令 grctl service get \u0026lt;应用别名\u0026gt; -t \u0026lt;团队别名\u0026gt;  看PodStatus状态:\n# 如下是应用已经正常启动了，大部分情况是Ready状态是False PodStatus: Initialized : True Ready : True PodScheduled : True  Pod Read状态False排查  Containers是否已经启动，如果已经启动状态还是False，请检查应用健康检查; Containers未启动或者在重启，请查看登录到相关节点查看容器日志  查看k8s Events信息 kubectl describe pods/\u0026lt;PodName\u0026gt; -n \u0026lt;Namespace\u0026gt;  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/op-guide/code_build_failure_download_gzip/",
	"title": "源码构建提示gzip stdin not in gzip format",
	"tags": [],
	"description": "",
	"content": " 源码构建过程中有提示gzip stdin not in gzip format,大多数都是lang.goodrain.me无法正常访问\n 验证lang.goodrain.me是否健康\n# 状态码200 curl -I lang.goodrain.me  确定rbd-repo是否正常\n# 1. 访问管理节点8081端口 # 2. 状态码2xx,3xx curl -I \u0026lt;管理节点ip\u0026gt;:8081 # 不正常可以重启 systemctl restart rbd-repo  应用添加BUILD_DEBUG_INFO true显示源码构建Runtime下载路径\n# 管理节点手动下载是否有 wget \u0026lt;runtime download url\u0026gt;  确定访问是否有限制\n# 状态码 403 curl -I http://buildpack.rainbond.com   案例参考 源码构建\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/go_more/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java_more/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/php_more/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/ruby_more/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/etc/slugignore/",
	"title": ".slugignore文件",
	"tags": [],
	"description": "讲解.slugignore文件的用法和作用",
	"content": " .slugignore文件作用介绍 .slugignore 与大家知道的.gitignore文件一样，具有在打包阶段忽略某些文件的作用。我们在使用Rainbond进行源码构建打包时或许会有这样一个需求，我不想将源代码打包到最终的软件包中，但是Rainbond需要根据你的定义确定哪些文件是你不想要的。因此就有了.slugignore 文件。\n.slugignore文件定义方式  文件位置与命名  文件名称必须为.gitignore，且必须放置于源代码主目录中。\n 文件内容规范  与.gitignore规范一致，需要忽略的文件将其路径定义到文件中，每行一个，支持通配符。\n示例：\nsrc/main/java/com/* src/test  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/upgrade/5.0.4-5.1.0/",
	"title": "5.0.4升级至5.1.0文档",
	"tags": [],
	"description": "Rainbond 5.1.0升级文档",
	"content": " 5.0.4升级至5.1.0 Rainbond 5.1.0版本仅支持从5.0.4版本升级,其他5.0.x版本需要升级到5.0.4版本，5.0.4版本升级参考[5.0.4升级文档](https://t.goodrain.com/t/rainbond-5-0-4/744);升级后可能数据库结构会发生改变,故不能够回滚升级。 无法确定Rainbond版本，可通过grctl version来确定版本。如果version不是`5.0-3cbc7c6-2019-03-05-12`则为非5.0.4版本  下载 5.1.0 更新包  离线包镜像大小约1.9G，需要保证当前集群磁盘可用空间至少不低于6G\n # 基础Runtime包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/base.images.2019-03-15-5.1.0.tgz -O /grdata/services/offline/base.images.upgrade.5.1.0.tgz # Rainbond组件包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond.images.2019-03-15-5.1.0.tgz -O /grdata/services/offline/rainbond.images.upgrade.5.1.0.tgz # 5.1.0安装包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond-ansible.upgrade.5.1.0.tgz -O /grdata/services/offline/rainbond-ansible.upgrade.5.1.0.tgz  解压安装脚本,执行升级脚本 rm -rf /tmp/rainbond-ansible rm -rf /grdata/services/offline/upgrade tar xf /grdata/services/offline/rainbond-ansible.upgrade.5.1.0.tgz -C /tmp/ cd /tmp/rainbond-ansible/scripts/upgrade/ bash ./upgrade.sh  升级完成验证 grctl cluster  插件升级说明  卸载所有应用的默认插件，并在插件管理中删除默认插件 刷新页面后重新安装默认插件。 需要使用插件的应用重新安装插件并更新应用。  升级如有问题，请至社区反馈 Rainbond 5.1.0升级文档\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/upgrade/5.1.0-5.1.1/",
	"title": "5.1.0升级至5.1.1文档",
	"tags": [],
	"description": "本文档记录了Rainbond v5.1.1 中功能的优化和BUG修复记录及升级文档",
	"content": " 本文档记录了Rainbond v5.1.1 中功能的优化和BUG修复记录。\n功能优化及BUG修复 优化  优化PHP语言支持，增加了大量PHP的扩展支持，详情见文档 PHP语言支持 总览页面展示效果优化 增加允许源码构建服务使用1024以下的端口 优化了第三方服务的特性显示，在拓扑图中使用蓝色，在列表中添加了明显的标识 安装方面扩容节点时优化docker启动流程控制 调整初始化数据中心数据库的初始化脚本路径，便于出错后重新初始化数据库。 优化存储类型为NFS的存储检测方式，兼容提前挂载分布式存储的节点检测。  BUG修复  【重要】修复了服务具有多个端口时导致服务内部依赖和网关访问错误的BUG 【重要】修复了服务垂直升级操作失败的BUG 【重要】修复了应用网关访问策略编辑前端填充数据错误的BUG 修复了平台内部某些功能说明文档的地址错误 修复了源代码检测取回的端口信息为设置成功的BUG 修复了服务点击访问后连接信息显示不全的BUG 修复了第三方服务无法进行批量删除的BUG 修复了构建源重新检测时从Dockerfile类型到其他源码类型转变服务启动命令错误的BUG 修复构建源配置Java等语言设置构建缓存不生效的BUG 升级PHP语言Runtimes版本 #28 修复PHP语言构建失败问题 #25,#26  版本升级 升级要求和注意事项 此版本修复了V5.1.0的几个影响面大的BUG，推荐V5.1.0版本用户升级 V5.1.1版本只支持从V5.1.0版本升级，如果你还未升级到V5.1.0版本，参考[V5.1.0版本升级文档](https://www.rainbond.com/docs/user-operations/upgrade/5.0.4-5.1.0/)版本确认方式：`grctl version`,版本应该为：`Rainbond grctl 5.1.0-4aead9a-2019-03-20-06` 升级过程会重启管理服务，因此只有单管理节点的集群会短暂影响控制台操作，请选择合理的升级时间段  下载 5.1.1 更新包  离线包镜像大小约650MB，需要保证当前集群磁盘可用空间至少不低于2G\n # Rainbond 组件升级包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond.images.2019-03-21-5.1.1.tgz -O /grdata/services/offline/rainbond.images.upgrade.5.1.1.tgz # Rainbond Runtime组件升级包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/runtime.upgrade.2019-03-21-5.1.1.tgz -O /grdata/services/offline/runtime.upgrade.2019-03-21-5.1.1.tgz # 5.1.1 升级脚本包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond-ansible.upgrade.5.1.1.tgz -O /grdata/services/offline/rainbond-ansible.upgrade.5.1.1.tgz  解压安装脚本,执行升级脚本 rm -rf /tmp/rainbond-ansible rm -rf /grdata/services/offline/upgrade tar xf /grdata/services/offline/rainbond-ansible.upgrade.5.1.1.tgz -C /tmp/ cd /tmp/rainbond-ansible/scripts/upgrade/ bash ./upgrade.sh  升级完成验证  执行 grctl cluster确定所有服务和节点运行正常 grctl version 确认版本已升级到5.1.1  升级如有问题，请至社区反馈 Rainbond 5.1.1升级文档\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/upgrade/5.1.1-5.1.2/",
	"title": "5.1.1升级至5.1.2文档",
	"tags": [],
	"description": "本文档记录了Rainbond v5.1.2 中功能的优化和BUG修复记录及升级文档",
	"content": " 本文档记录了Rainbond v5.1.2 中功能的优化和BUG修复记录\n优化  支持阿里云镜像仓库Webhook触发器自动构建服务 优化添加网关策略的交互呈现，更易于用户使用 优化Java War语言类型的构建，支持自动设置JAVA_OPTS参数 优化UI在长时间不刷新页面的情况下出现无法操作的体验 优化Runner环境和启动策略，支持在源码路径下提前挂载配置文件和持久化目录 优化了构建源信息更改的交互逻辑，解决ssh和http协议访问地址的相互切换时无法设置用户名密码的问题 优化了应用Dashboard页面添加组件的流程，增加放弃创建选项 优化服务的访问逻辑，默认访问路径根据用户配置的访问策略路径确定 grctl命令行工具增加显示第三方服务的实例信息 优化了第三方服务的健康检查控制  BUG修复  [重要] 解决了kube-controller-manager重启导致第三方服务实例下线的BUG [重要] 修复了服务健康检查无法更改服务不健康时的操作方式的BUG [重要] 修复了从应用市场安装服务时服务健康检查禁用不生效的BUG [重要] 修复了从应用市场导出DockerCompose规范的离线应用时镜像名称、环境变量不正确的BUG 修复了Java War语言类型不定义webserver时无法构建的BUG 修复了第三方服务在编辑模式的拓扑图中显示错误的BUG 修复了应用网关可以添加重复的访问策略导致应用网关工作异常的BUG  版本安装 当前版本为5.1系列最新版本，从发布之日起安装的5.1版本系列平台即时最新的5.1.2版本，安装参考： Rainbond集群安装\n版本升级 升级要求和注意事项  V5.1.2版本只支持从V5.1.x版本升级，如果你还未升级到V5.1.x版本，参考V5.1.x版本升级文档版本确认方式：  grctl version, 例如版本显示如下：Rainbond grctl 5.1.0-4aead9a-2019-03-20-06\n 升级过程会重启管理服务，因此只有单管理节点的集群会短暂影响控制台操作，请选择合理的升级时间段 。  下载 5.1.2 更新包  离线包镜像大小约650MB，需要保证当前集群磁盘可用空间至少不低于2G\n # Rainbond 组件升级包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond.images.2019-04-01-5.1.2.tgz -O /grdata/services/offline/rainbond.images.upgrade.5.1.2.tgz # Rainbond Runtime组件升级包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/runtime.upgrade.2019-04-01-5.1.2.tgz -O /grdata/services/offline/runtime.upgrade.5.1.2.tgz # 5.1.1 升级脚本包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond-ansible.upgrade.5.1.2.tgz -O /grdata/services/offline/rainbond-ansible.upgrade.5.1.2.tgz  解压安装脚本,执行升级脚本 rm -rf /tmp/rainbond-ansible rm -rf /grdata/services/offline/upgrade tar xf /grdata/services/offline/rainbond-ansible.upgrade.5.1.2.tgz -C /tmp/ cd /tmp/rainbond-ansible/scripts/upgrade/ bash ./upgrade.sh  升级完成验证  执行 grctl cluster确定所有服务和节点运行正常 grctl version 确认版本已升级到5.1.2，运行组件镜像版本为 v5.1.2-release  升级如有问题，请至社区反馈。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/upgrade/5.1.2-5.1.3/",
	"title": "5.1.2升级至5.1.3文档",
	"tags": [],
	"description": "本文档记录了Rainbond v5.1.3 中功能的优化和BUG修复记录及升级文档",
	"content": " 本文档记录了Rainbond v5.1.3 中功能的优化和BUG修复记录\n优化和新功能  支持Java Maven多模块批量创建服务[beta] 新增新⼿引导任务流程 完善集群服务监控,内置支持节点物理设备和操作系统监控、节点系统服务监控、容器监控和服务业务性能监控 改进基于应用市场的服务升级策略，新增对环境变量、存储(包括依赖存储)、端⼝、服务依赖等属 性的升级[beta] 改进Docker Compose 批量创建服务的功能，修改服务镜像检测机制⼤大提高DockerCompose检测成功性。同时⽀持设置私有镜像仓库的账号信息。提供了Docker Compose到Kubernetes转化 的稳定功能支持。 Git-Webhook增加对腾讯Coding代码仓库的⽀持 镜像仓库Webhook⾃动构建支持Tag版本根据策略进⾏⾃动验证和改变 改进镜像创建服务识别策略，智能识别镜像信息确定服务部署类型和内存分配，提供服务创建准确性 应用网关支持便捷设置Websocket⽀支持和ProxyBuffer等参数 改进端⼝属性维护机制，增加当端口删除时⾃动设置其他与端口绑定的服务属性，⽐如健康检查.防⽌由于错误的端⼝设置导致服务⼀直运行异常 系统服务注册功能改进，基于健康检查实现注册Endpoint的⾃动上线和下线，解决错误的添加管理节点导致镜像仓库等服务负载均衡错误问题。[beta] 优化安装流程，将push镜像流程更改到最后防止push镜像失败导致安装不成功 新增使⽤第三方数据库的机制，⽤户提供数据库给Rainbond数据中心和控制台使用Rainbond将不再默认安装数据库，适用于生产环境部署时对数据库单独进⾏部署和运维。[beta] 调整部分组件⽇志级别等启动参数  BUG修复  修复在HTTP访问策略中添加IP或其他⾮法域名导致服务无法启动的BUG 修复了DockerRun等⽅式创建的服务后期无法修改账号密码的问题 修复了镜像错误检测失败后无法进行后续操作的问题 修复了重复添加访问策略导致服务⽆法访问的问题 修复了UI搜索访问策略后无法进⾏翻⻚的BUG 修复了服务经过分享过后，伸缩范围固化的问题  版本安装 当前版本为5.1系列最新版本，从发布之日起安装的5.1版本系列平台即时最新的5.1.3版本，安装参考： Rainbond集群安装\n版本升级 升级要求和注意事项  V5.1.3版本只支持从V5.1.x版本升级，如果你还未升级到V5.1.x版本，参考V5.1.x版本升级文档版本确认方式：  grctl version, 例如版本显示如下：Rainbond grctl 5.1.0-4aead9a-2019-03-20-06\n 升级过程会重启管理服务，因此只有单管理节点的集群会短暂影响控制台操作，请选择合理的升级时间段 。  下载 5.1.3 更新包  离线包镜像大小约650MB，需要保证当前集群磁盘可用空间至少不低于2G\n # Rainbond 组件升级包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond.images.2019-04-15-5.1.3.tgz -O /grdata/services/offline/rainbond.images.upgrade.5.1.3.tgz # Rainbond Runtime组件升级包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/runtime.upgrade.2019-04-15-5.1.3.tgz -O /grdata/services/offline/runtime.upgrade.5.1.3.tgz # 5.1.3 升级脚本包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond-ansible.upgrade.5.1.3.tgz -O /grdata/services/offline/rainbond-ansible.upgrade.5.1.3.tgz  解压安装脚本,执行升级脚本 rm -rf /tmp/rainbond-ansible rm -rf /grdata/services/offline/upgrade tar xf /grdata/services/offline/rainbond-ansible.upgrade.5.1.3.tgz -C /tmp/ cd /tmp/rainbond-ansible/scripts/upgrade/ bash ./upgrade.sh  升级完成验证  执行 grctl cluster确定所有服务和节点运行正常 grctl version 确认版本已升级到5.1.3，运行组件镜像版本为 v5.1.3-release  升级如有问题，请至社区反馈。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/upgrade/5.1.3-5.1.4/",
	"title": "5.1.3升级至5.1.4文档",
	"tags": [],
	"description": "本文档记录了Rainbond v5.1.4 中功能的优化和BUG修复记录及升级文档",
	"content": " 本文档记录了Rainbond v5.1.4 中功能的优化和BUG修复记录\n新功能 在5.1.4之前, rainbond仅仅支持对云市应用中单个服务的升级, 如果想要升级整个云市应用, 则需要单独地对每个服务进行升级, 且无法升级新添加的服务. 这给各位用户的使用带来了极大的不便. 为了让用户有的操作更加\u0008的简单, 提高使用体验, 我们在5.1.4版本中, 对云市应用进行了改造升级.\n功能特性  灵活的升级方式: 可以自由地选择需要升级的服务, 可以全部升级也可以部份升级. 创建新加服务: 除了可以升级已有的服务外, 还可以创建旧版本没有, 但是新版本有的服务. 详细的变更信息: 在升级界面中, 可以查看当前版本与新版本服务之间属性的变更. 详细的升级记录: 对每次升级操作, rainbond都进行了详细的记录, 包括: 升级操作的时间, 版本号的变更和各服务属性的变更信息等. 自动回滚: 在应用升级的过程中, 如果程序发生了异常, 会回滚到升级前的状态, 避免只升级部分属性或服务. 手动回滚: 升级成功后, 如果新版本有缺陷导致各个服务无法正常工作, 或者你更倾向升级前的版本, 那么可以选择手动回滚, 回到之前的版本.  优化  第三方服务新添加实例地址时, 允许地址中带有端口 镜像服务支持修改镜像仓库帐号, 密码等\u0008信息 grctl命令行工具增加身份属性gateway 将自定义网关策略的域名以环境变量的方式注入到服务中(相关文档) 将环境变量，配置文件等配置信息综合为环境配置 分享应用时支持定义不分享的服务 支持服务链接信息和环境变量的相互转移 关闭或重启服务时, 增加二次确认, 防止误操作  安装方面：\n 优化安装时初始化数据中心流程 优化调整安装任务结构,调整离线镜像文件路径 支持调整网络类型 优化部分组件配置参数 优化安装过程中宿主机IP段与容器ip段冲突问题  BUG修复  【重要】修复了关闭服务时, pod无法被删除或删除需要花费比较多时间的问题 【重要】修复了多管理节点中, 某个节点rbd-hub服务异常了，但gateway没有将其下线导致goodrain.me服务异常的问题 修复了第三方服务的网关访问策略控制错误 修复了删除端口报系统异常的错误 修复了编辑HTTPs网关策略, 无法勾选 HTTP rewriet HTTPs 的问题 修复了更改构建源后无法重新检测语言的错误 修复了无法修改健康检测参数的错误 修复了云市应用版本号显示不全的问题 修复了添加镜像服务时, 没有高级选项按钮的问题 修复了构建源中镜像Tag显示不全的问题 修复了创建应用时勾选的是有状态应用，创建成功后却是无状态应用的问题 修复了无法将无状态应用修改为有状态应用的问题 修复了禁止调度计算节点后, 导致可用资源统计错误的问题 修复了第三方服务TCP访问策略状态错误且无法操作的问题 修复了网关策略参数配置中Websocket不生效的问题 修复了云市应用导出的docker-compose.yaml中的镜像有误的问题 修复了环境变量名格式验证有误的问题, 支持带\u0026rdquo;.\u0026ldquo;的环境变量名  版本安装 当前版本为5.1系列最新版本，从发布之日起安装的5.1版本系列平台即时最新的5.1.4版本，安装参考： Rainbond集群安装\n版本升级 升级要求和注意事项  V5.1.4版本只支持从V5.1.x版本升级，如果你还未升级到V5.1.x版本，参考V5.1.x版本升级文档版本确认方式：  grctl version, 例如版本显示如下：Rainbond grctl v5.1.4-release-1b49703-2019-05-19-10\n 升级过程会重启管理服务，因此只有单管理节点的集群会短暂影响控制台操作，请选择合理的升级时间段 。  下载 5.1.4 更新包  离线包镜像大小约650MB，需要保证当前集群磁盘可用空间至少不低于2G\n # Rainbond 组件升级包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond.images.2019-05-20-5.1.4.tgz -O /grdata/services/offline/rainbond.images.upgrade.5.1.4.tgz # 升级脚本包 wget http://rainbond-pkg.oss-cn-shanghai.aliyuncs.com/offline/5.1/rainbond-ansible.upgrade.5.1.4.tgz -O /grdata/services/offline/rainbond-ansible.upgrade.5.1.4.tgz  解压安装脚本,执行升级脚本 rm -rf /tmp/rainbond-ansible rm -rf /grdata/services/offline/upgrade tar xf /grdata/services/offline/rainbond-ansible.upgrade.5.1.4.tgz -C /tmp/ cd /tmp/rainbond-ansible/scripts/upgrade/ bash ./upgrade.sh  升级完成验证  执行 grctl cluster确定所有服务和节点运行正常 grctl version 确认版本已升级到5.1.4，运行组件镜像版本为 v5.1.4-release  升级如有问题，请至社区反馈。\n"
},
{
	"uri": "http://skyzhangyf.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java_more/java-gradle/",
	"title": "Java Gradle源码创建",
	"tags": [],
	"description": "Java Gradle源码创建",
	"content": " Gradle项目识别策略 平台默认会根据源码根目录是否有gradlew文件或者build.gradle来识别为Java Gradle项目.\n平台编译运行机制  预编译处理完成后,会根据语言类型选择Java-Gradle的buildpack去编译项目.在编译过程中会安装定义的JDK版本; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  平台默认Gradle编译命令\ngradlew build -x test  Gradle项目源码规范 在此步骤中，你需要提供一个可用的Java Gradle源码程序用来部署在Rainbond平台上,此应用程序至少需要满足如下条件:\n 本地可以正常运行的Gradle程序 源码程序必须托管在gitlab等相关git或者svn服务上 源码程序根路径下必须需要存在gradlew文件或者build.gradle  编译运行环境设置 在选择JDK版本或其他组件版本时，需要注意JDK或者其他组件版本不要选择比项目使用的版本过高或者过低以免导致源码编译失败  OpenJDK支持 当前Rainbond支持OpenJDK如下版本为：\n Java 1.6 - 1.6.0_27 Java 1.7 - 1.7.0_95 Java 1.8 - 1.8.0_74 Java 1.9 - 1.9-latest Java 10 - 10.0.2 Java 11 - 11.0.1  平台默认版本使用1.8。若需要使用其他版本的OpenJDK，可以通过在源码根目录下添加system.properties文件来设定java.runtime.version的值来指定所需版本的JDK。\n# system.properties 目前Rainbond能识别的版本值为11,10,1.9,1.8,1.7,1.6 java.runtime.version=1.8  OracleJDK支持 平台目前也支持OracleJDK,但此特性需要在平台里启用才会生效。\n默认不内置提供OracleJDK下载,需要在设置里启用OracleJDK后配置相关OracleJDK下载地址。\nOracleJDK下载地址格式要求: http://\u0026lt;web服务URL\u0026gt;/jdk-8u201-linux-x64.tar.gz\n平台设置的配置优先级要高于程序代码中定义的配置，如Java JDK版本的选择,在程序代码里通过`system.properties`指定了JDK版本为1.9,在平台上选择了JDK版本为11,那么默认在进行源码编译时会优先使用平台指定的版本JDK11  示例demo程序 示例https://github.com/goodrain/java-gradle-demo\n推荐阅读  Java-Maven源码构建应用 Java-War源码构建应用 Java-Jar源码构建应用 Spring Boot项目配置MySQL Tomcat配置Redis实现Session共享  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java_more/java-jar/",
	"title": "Java Jar源码构建应用",
	"tags": [],
	"description": "Java Jar源码构建应用",
	"content": " Jar项目识别策略 平台默认会根据源码根目录是否有Jar包来识别为Java Jar项目.\n平台编译运行机制  预编译处理会探测是否定义了启动命令配置文件Procfile,如果未定义会生成默认Jar包启动配置文件; 预编译处理完成后,会根据语言类型选择Java-jar的buildpack去编译项目.在编译过程中会安装定义的JDK版本; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  Jar项目源码规范 在此步骤中，你需要提供一个可用的Java Jar源码程序用来部署在Rainbond平台上,此应用程序至少需要满足如下条件:\n 本地可以正常运行的Jar包 源码程序必须托管在gitlab等相关git或者svn服务上 源码程序根路径下必须需要存在Jar包文件  Procfile规范 如果项目未定义Procfile文件,平台默认会生成默认Procfile来运行Jar包。\nweb: java -Dserver.port=$PORT $JAVA_OPTS -jar ./*.jar  上述是默认Procfile,如果需要扩展更多启动参数,可以自定义Procfile。\n1. `web:`和`java`之间有一个空格 2. 文件结尾不能包含特殊字符 3. JAVA_OPTS: 平台会根据应用的内存大小，自动设置Xmx和Xms的值 4. PORT: 根据用户在平台设置的端口决定监听，默认监听端口为 5000  编译运行环境设置 在选择JDK版本或其他组件版本时，需要注意JDK或者其他组件版本不要选择比项目使用的版本过高或者过低以免导致源码编译失败  OpenJDK支持 当前Rainbond支持OpenJDK如下版本为：\n Java 1.6 - 1.6.0_27 Java 1.7 - 1.7.0_95 Java 1.8 - 1.8.0_74 Java 1.9 - 1.9-latest Java 10 - 10.0.2 Java 11 - 11.0.1  平台默认版本使用1.8。若需要使用其他版本的OpenJDK，可以通过在源码根目录下添加system.properties文件来设定java.runtime.version的值来指定所需版本的JDK。\n# system.properties 目前Rainbond能识别的版本值为11,10,1.9,1.8,1.7,1.6 java.runtime.version=1.8  OracleJDK支持 平台目前也支持OracleJDK,但此特性需要在平台里启用才会生效。\n默认不内置提供OracleJDK下载,需要在设置里启用OracleJDK后配置相关OracleJDK下载地址。\nOracleJDK下载地址格式要求: http://\u0026lt;web服务URL\u0026gt;/jdk-8u201-linux-x64.tar.gz\n平台设置的配置优先级要高于程序代码中定义的配置，如Java JDK版本的选择,在程序代码里通过`system.properties`指定了JDK版本为1.9,在平台上选择了JDK版本为11,那么默认在进行源码编译时会优先使用平台指定的版本JDK11  示例demo程序 示例https://github.com/goodrain/java-jar-demo\n推荐阅读  Java-Maven源码构建应用 Java-War源码构建应用 Java-Gradle源码构建应用 Spring Boot项目配置MySQL Tomcat配置Redis实现Session共享  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java_more/java-maven/",
	"title": "Java Maven源码构建应用",
	"tags": [],
	"description": "Java Maven源码构建应用",
	"content": " Maven项目识别策略 平台默认会通过pom.xml来识别源码项目为Java Maven项目。\n编译原理  预编译处理会探测是否定义了启动命令配置文件Procfile,如果未定义会根据打包类型或者项目框架生成默认Procfile文件; 预编译处理完成后,会根据语言类型选择Java的buildpack去编译项目.在编译过程中会安装定义的JDK版本，Maven版本，然后构建编译Maven源码项目; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  默认Maven项目构建命令如下\nmvn -DskipTests clean dependency:list install  Maven项目源码规范 在此步骤中，你需要提供一个可用的Java Maven源码程序用来部署在Rainbond平台上,此应用程序至少需要满足如下条件:\n 本地可以使用默认Maven命令正常构建的Java Maven源码程序,多模块项目需要确定子模块可以单独编译即mvn install -pl \u0026lt;modulename\u0026gt; -am 源码程序必须托管在gitlab等相关git或者svn服务上 源码程序根路径下必须需要存在Java的依赖管理工具Maven所需的pom.xml文件  1. pom.xml规范 SpringBoot项目打包方式推荐使用 jar 包方式 非SpringBoot项目打包方式推荐使用 war 包方式\n2. Procfile规范 如果项目未定义Procfile文件,平台默认会根据识别项目类型生成默认Procfile。\n 打包方式为 war 包,平台使用 webapp-runner.jar 将打包的 war 包运行起来。示例  web: java $JAVA_OPTS -jar ./webapp-runner.jar --port $PORT target/*.war   打包方式为 jar 包,示例  web: java -Dserver.port=$PORT $JAVA_OPTS -jar target/*.jar  上述是默认Procfile,如果需要扩展更多启动参数,可以自定义Procfile。\n1. `web:`和`java`之间有一个空格 2. 文件结尾不能包含特殊字符 3. 如果是多模块项目,需注意编译后jar包或者war包路径，其路径为`/targets/*.jar`或`/targets/*.war` 4. JAVA_OPTS: 平台会根据应用的内存大小，自动设置Xmx和Xms的值 5. PORT: 根据用户在平台设置的端口决定监听，默认监听端口为 5000  当调整了Web服务器支持后，打包成War需要调整启动命令 - 选择tomcat不同版本时 `web: java $JAVA_OPTS -jar ./webapp-runner.jar --port $PORT ./*.war` - 选择jetty不同版本时 `web: java $JAVA_OPTS -jar ./jetty-runner.jar --port $PORT ./*.war` 需要配置context path,可以通过自定义Procfile指定[webapp-runner参数path](https://github.com/jsimone/webapp-runner#options) - 示例 `web: java $JAVA_OPTS -jar ./webapp-runner.jar --path --port $PORT ./*.war`  编译运行环境设置 在选择JDK版本或其他组件版本时，需要注意JDK或者其他组件版本不要选择比项目使用的版本过高或者过低以免导致源码编译失败  OpenJDK支持 当前Rainbond支持OpenJDK如下版本为：\n Java 1.6 - 1.6.0_27 Java 1.7 - 1.7.0_95 Java 1.8 - 1.8.0_74 Java 1.9 - 1.9-latest Java 10 - 10.0.2 Java 11 - 11.0.1  平台默认版本使用1.8。若需要使用其他版本的OpenJDK，可以通过在源码根目录下添加system.properties文件来设定java.runtime.version的值来指定所需版本的JDK。\n# system.properties 目前Rainbond能识别的版本值为11,10,1.9,1.8,1.7,1.6 java.runtime.version=1.8  OracleJDK支持 平台目前也支持OracleJDK,但此特性需要在平台里启用才会生效。\n默认不内置提供OracleJDK下载,需要在设置里启用OracleJDK后配置相关OracleJDK下载地址。\nOracleJDK下载地址格式要求: http://\u0026lt;web服务URL\u0026gt;/jdk-8u201-linux-x64.tar.gz\n配置Maven版本 Rainbond默认的推荐Maven版本为3.3.1,支持如下版本: 3.0.5, 3.1.1, 3.2.5, 3.3.1, 3.3.9.\n如果你的源码根目录定义了mvnw,将使用此脚本启动Maven进程。\n与Java设置指定版本一致，即通过system.properties文件来设定maven.version的值来指定所需版本的Maven.\nmaven.version=3.3.1  如果指定了Maven版本，则会忽略mvnw\n平台设置的配置优先级要高于程序代码中定义的配置，如Java JDK版本的选择,在程序代码里通过`system.properties`指定了JDK版本为1.9,在平台上选择了JDK版本为11,那么默认在进行源码编译时会优先使用平台指定的版本JDK11  Web服务支持 如果Maven项目打包成war包,则需要配置Web服务支持。\n通过web服务(tomcat或者jetty)将war包运行起来,即通过java -jar ./webapp-runner.jar ./*.war或者java -jar ./jetty-runner.jar ./*.war方式运行.\n目前可以通过构建源设置web服务版本或者源码根目录定义webserver文件\n 控制台构建源配置支持版本 tomcat7,tomcat8,tomcat85,tomcat9,jetty7,jetty9\n 源码根目录下定义webserver版本  webapp-runner-7.0.91.0.jar webapp-runner-8.0.52.0.jar,webapp-runner-8.5.38.0.jar webapp-runner-9.0.16.0.jar jetty-runner-7.5.4.v20111024.jar,jetty-runner-9.4.0.v20161208.jar\n   具体对应关系如下:\n   web服务支持 web服务版本 自定义Procfile中jar文件名     tomcat7 webapp-runner-7.0.91.0.jar webapp-runner.jar   tomcat8 webapp-runner-8.0.52.0.jar webapp-runner.jar   tomcat85 (默认) webapp-runner-8.5.38.0.jar webapp-runner.jar   tomcat9 webapp-runner-9.0.16.0.jar webapp-runner.jar   jetty7 jetty-runner-7.5.4.v20111024.jar jetty-runner.jar   jetty9 jetty-runner-9.4.0.v20161208.jar jetty-runner.jar    选择tomcat7版本需要注意确定本地可以通过`java -jar ./webapp-runner-7.0.91.0.jar ./*.war`运行 关于webapp-runner详细配置请参考[webapp-runner使用说明](/user-manual/app-creation/language-support/java_more/webapp-runner/)  高级构建选项 在构建高级设置或构建源处启用高级构建特性\nMaven Mirror配置    环境变量 默认值 说明     BUILD_MAVEN_MIRROR_DISABLE  默认是启用Maven Mirror   BUILD_MAVEN_MIRROR_OF *    BUILD_MAVEN_MIRROR_URL maven.goodrain.me 平台默认Mirror地址    Maven 构建高级配置    环境变量 默认值 说明     BUILD_MAVEN_CUSTOM_OPTS -DskipTests Maven构建参数   BUILD_MAVEN_CUSTOM_GOALS clean dependency:list install Maven构建参数   BUILD_MAVEN_SETTINGS_URL  默认为空Maven配置地址   BUILD_MAVEN_JAVA_OPTS -Xmx1024m 默认    其他说明 如果编译成war包，运行时默认会将war文件解压至/app/target/目录下,不支持通过添加配置文件的方式到war解压路径下,否则会导致应用无法正常启动\n示例demo程序 示例https://github.com/goodrain/java-maven-demo是Spring Boot项目。\n自定义的Procfile为\nweb: java $JAVA_OPTS -jar target/java-maven-demo-0.0.1.jar  本地调试(可选) 如果可以访问管理节点，可以在管理节点测试是否可以正常源码构建\ngit clone https://github.com/goodrain/java-maven-demo.git cd java-maven-demo grctl buildtest  推荐阅读  Java-Jar源码构建应用 Java-War源码构建应用 Java-Gradle源码构建应用 Spring Boot项目配置MySQL Tomcat配置Redis实现Session共享 webapp-runner使用说明  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java_more/java-war/",
	"title": "Java War源码构建应用",
	"tags": [],
	"description": "Java War源码构建应用",
	"content": " War项目识别策略 平台默认会根据源码根目录下是否有War文件来识别为Java War项目。\n平台编译运行机制  预编译处理会探测是否定义了启动命令配置文件Procfile,如果未定义会生成默认War包启动配置文件; 预编译处理完成后,会根据语言类型选择Java-war的buildpack去编译项目.在编译过程中会安装定义的JDK版本,Web服务; 编译完成后会检查是否在平台设置了Procfile参数,若配置了会重写启动命令配置文件Procfile.  War项目源码规范 在此步骤中，你需要提供一个可用的Java War源码程序用来部署在Rainbond平台上,此应用程序至少需要满足如下条件:\n 本地可以正常运行的War包 源码程序必须托管在gitlab等相关git或者svn服务上 源码程序根路径下必须需要存在War文件(即项目已经打成war文件)  Procfile规范 如果项目未定义Procfile文件,平台默认会生成默认Procfile来运行War包。\nweb: java $JAVA_OPTS -jar ./webapp-runner.jar --port $PORT ./*.war  上述是默认Procfile,如果需要扩展更多启动参数,可以自定义Procfile。\n1. `web:`和`java`之间有一个空格 2. 文件结尾不能包含特殊字符 3. JAVA_OPTS: 平台会根据应用的内存大小，自动设置Xmx和Xms的值 4. PORT: 根据用户在平台设置的端口决定监听，默认监听端口为 5000  当调整了Web服务器支持后，打包成War需要调整启动命令 - 选择tomcat不同版本时 `web: java $JAVA_OPTS -jar ./webapp-runner.jar --port $PORT ./*.war` - 选择jetty不同版本时 `web: java $JAVA_OPTS -jar ./jetty-runner.jar --port $PORT ./*.war` 需要配置context path,可以通过自定义Procfile指定[webapp-runner参数path](https://github.com/jsimone/webapp-runner#options) - 示例 `web: java $JAVA_OPTS -jar ./webapp-runner.jar --path --port $PORT ./*.war`  编译运行环境设置 在选择JDK版本或其他组件版本时，需要注意JDK或者其他组件版本不要选择比项目使用的版本过高或者过低以免导致源码编译失败  OpenJDK支持 当前Rainbond支持OpenJDK如下版本为：\n Java 1.6 - 1.6.0_27 Java 1.7 - 1.7.0_95 Java 1.8 - 1.8.0_74 Java 1.9 - 1.9-latest Java 10 - 10.0.2 Java 11 - 11.0.1  平台默认版本使用1.8。若需要使用其他版本的OpenJDK，可以通过在源码根目录下添加system.properties文件来设定java.runtime.version的值来指定所需版本的JDK。\n# system.properties 目前Rainbond能识别的版本值为11,10,1.9,1.8,1.7,1.6 java.runtime.version=1.8  OracleJDK支持 平台目前也支持OracleJDK,但此特性需要在平台里启用才会生效。\n默认不内置提供OracleJDK下载,需要在设置里启用OracleJDK后配置相关OracleJDK下载地址。\nOracleJDK下载地址格式要求: http://\u0026lt;web服务URL\u0026gt;/jdk-8u201-linux-x64.tar.gz\n平台设置的配置优先级要高于程序代码中定义的配置，如Java JDK版本的选择,在程序代码里通过`system.properties`指定了JDK版本为1.9,在平台上选择了JDK版本为11,那么默认在进行源码编译时会优先使用平台指定的版本JDK11  Web服务支持 通过web服务(tomcat或者jetty)将war包运行起来,即通过java -jar ./webapp-runner.jar ./*.war或者java -jar ./jetty-runner.jar ./*.war方式运行.\n目前可以通过构建源设置web服务版本或者源码根目录定义webserver文件\n 控制台构建源配置支持版本 tomcat7,tomcat8,tomcat85,tomcat9,jetty7,jetty9\n 源码根目录下定义webserver版本  webapp-runner-7.0.91.0.jar webapp-runner-8.0.52.0.jar,webapp-runner-8.5.38.0.jar webapp-runner-9.0.16.0.jar jetty-runner-7.5.4.v20111024.jar,jetty-runner-9.4.0.v20161208.jar\n   具体对应关系如下:\n   web服务支持 web服务版本 自定义Procfile中jar文件名     tomcat7 webapp-runner-7.0.91.0.jar webapp-runner.jar   tomcat8 webapp-runner-8.0.52.0.jar webapp-runner.jar   tomcat85 (默认) webapp-runner-8.5.38.0.jar webapp-runner.jar   tomcat9 webapp-runner-9.0.16.0.jar webapp-runner.jar   jetty7 jetty-runner-7.5.4.v20111024.jar jetty-runner.jar   jetty9 jetty-runner-9.4.0.v20161208.jar jetty-runner.jar    选择tomcat7版本需要注意确定本地可以通过`java -jar ./webapp-runner-7.0.91.0.jar ./*.war`运行 关于webapp-runner详细配置请参考[webapp-runner使用说明](/user-manual/app-creation/language-support/java_more/webapp-runner/)  高级构建选项 在构建高级设置或构建源处启用高级构建特性\n   环境变量 默认值 说明     BUILD_WEBSERVER_URL  自定义WEBAPP-RUNNER下载地址   BUILD_ONLINE  默认下载Rainbond内置Webapp-Runner    其他说明  默认会将war文件解压至/app/target/tomcat.\u0026lt;port\u0026gt;目录下,不支持通过添加配置文件的方式到war解压路径下,否则会导致应用无法正常启动  示例demo程序 示例https://github.com/goodrain/java-war-demo\n推荐阅读  Java-Maven源码构建应用 Java-Jar源码构建应用 Java-Gradle源码构建应用 Spring Boot项目配置MySQL Tomcat配置Redis实现Session共享 webapp-runner使用说明  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java_more/jetty-runner/",
	"title": "Jetty-Runner",
	"tags": [],
	"description": "how-to-use-rainbond",
	"content": "##Jetty 和 Jetty Runner 是什么\nJetty 是一个轻量级的 Java 应用程序 server。为应用程序的启动提供了一系列灵活的特性。其中一个比较灵活的特性就是可以使用嵌入式的Jetty，在 java-hello 代码中可以看到这种使用方式。另外一个好的特性就是 Jetty Runner本身就是一个jar文件。Jetty的每一次发布版本都会包含一个 Jetty Runner jar 文件。这个jar文件可以通过java命令配合war文件直接运行。例如下面的示例：\n$ java -jar jetty-runner.jar application.war  Jetty Runner 会启动一个Jetty实例将war运行起来。\n##创建应用程序\n$ mvn archetype:generate -DarchetypeArtifactId=maven-archetype-webapp ... [INFO] Generating project in Interactive mode Define value for property 'groupId': : com.example Define value for property 'artifactId': : helloworld  (你可以使用任意的 groupId 或 artifactId)。执行完上面的命令后，helloworld目录会生成一个完帐的Java web 应用。\n##配置Maven下载Jetty Runner\npom.xml文件是Maven进行工作的主要配置文件。在这个文件中我们可以配置Maven项目的groupId、artifactId和version等Maven项目必须的元素；可以配置Maven项目需要使用的远程仓库；可以定义Maven项目打包的形式；可以定义Maven项目的资源依赖关系等等。\n在这一步我们以依赖插件的形式下载Jetty Runner包，将下面内容添加到您pom.xml的合适位置:\n\u0026lt;build\u0026gt; ... \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt;\u0026lt;goal\u0026gt;copy\u0026lt;/goal\u0026gt;\u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;artifactItems\u0026gt; \u0026lt;artifactItem\u0026gt; \u0026lt;groupId\u0026gt;org.mortbay.jetty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jetty-runner\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.3.3.v20150827\u0026lt;/version\u0026gt; \u0026lt;destFileName\u0026gt;jetty-runner.jar\u0026lt;/destFileName\u0026gt; \u0026lt;/artifactItem\u0026gt; \u0026lt;/artifactItems\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  ##运行程序\n先运行如下简单的命令构建应用程序：\n$ mvn package  然后通过java命令运行起来：\n$ java -jar target/dependency/jetty-runner.jar target/*.war  就这么简单，你的应用程序已经运行并监听8080端口\n如果你需要在启动应用之前展开WAR文件，需要在启动命令的 target/*.war选项之前添加 --expand-war  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/php_more/extensions/",
	"title": "PHP Extensions说明",
	"tags": [],
	"description": "PHP具体扩展支持说明",
	"content": " PHP 5.6 在Rainbond上自动启用以下内置扩展(此列表不包括默认情况下PHP启用的扩展，例如DOM，JSON，PCRE或PDO):\n Bzip2\n cURL FPM mcrypt MySQL (PDO) (uses mysqlnd) MySQLi (uses mysqlnd) OPcache OpenSSL PostgreSQL PostgreSQL (PDO) Readline Sockets Zip Zlib  以下内置扩展已经构建为“共享”，可以通过composer.json（括号中给出的内部标识符名称）启用：\n BCMath (bcmath) Calendar (calendar) Exif (exif) FTP (ftp) GD (gd; with PNG, JPEG and FreeType support) GMP (gmp) gettext (gettext) IMAP (imap; with SASL and Kerberos support) intl (intl) LDAP (ldap; with SASL support) mbstring (mbstring) MySQL (mysql; note that this extension is deprecated since PHP 5.5, please migrate to MySQLi or PDO) PCNTL (pcntl) Shmop (shmop) SOAP (soap) SQLite3 (sqlite3) SQLite (PDO) (pdo_sqlite) XMLRPC (xmlrpc) XSL (xsl)  可以通过composer.json启用以下第三方扩展（括号中给出的内部标识符名称）：\n APCu (apcu; provides an apc extension for compatibility with legacy software) Blackfire (blackfire) Cassandra (cassandra) ev (ev) event (event) ImageMagick (imagick) memcached (memcached; built against a version of libmemcached with SASL support) Mongo (mongo) MongoDB (mongodb) New Relic (newrelic; will automatically be enabled when the New Relic Add-On is detected during a build) OAuth (oauth) Phalcon (phalcon) pq (pq) rdkafka (rdkafka) PHPRedis (redis)  7.0 在Rainbond上自动启用以下内置扩展(此列表不包括默认情况下PHP启用的扩展，例如DOM，JSON，PCRE或PDO):\n Bzip2\n cURL FPM MySQL (PDO) (uses mysqlnd) MySQLi (uses mysqlnd) OPcache OpenSSL PostgreSQL PostgreSQL (PDO) Readline Sockets Zip Zlib  以下内置扩展已经构建为“共享”，可以通过composer.json（括号中给出的内部标识符名称）启用：\n BCMath (bcmath) Calendar (calendar) Exif (exif) FTP (ftp) GD (gd; with PNG, JPEG and FreeType support) GMP (gmp) gettext (gettext) IMAP (imap; with SASL and Kerberos support) intl (intl) LDAP (ldap; with SASL support) mbstring (mbstring) mcrypt (mcrypt) PCNTL (pcntl) Shmop (shmop) SOAP (soap) SQLite3 (sqlite3) SQLite (PDO) (pdo_sqlite) XMLRPC (xmlrpc) XSL (xsl)  可以通过composer.json启用以下第三方扩展（括号中给出的内部标识符名称）：\n APCu (apcu; provides an apc extension for compatibility with legacy software) Blackfire (blackfire) Cassandra (cassandra) ev (ev) event (event) ImageMagick (imagick) memcached (memcached; built against a version of libmemcached with SASL support) MongoDB (mongodb) New Relic (newrelic; will automatically be enabled when the New Relic Add-On is detected during a build) OAuth (oauth) Phalcon (phalcon) pq (pq) rdkafka (rdkafka) PHPRedis (redis)  7.1 在Rainbond上自动启用以下内置扩展(此列表不包括默认情况下PHP启用的扩展，例如DOM，JSON，PCRE或PDO):\n Bzip2\n cURL FPM MySQL (PDO) (uses mysqlnd) MySQLi (uses mysqlnd) OPcache OpenSSL PostgreSQL PostgreSQL (PDO) Readline Sockets Zip Zlib  以下内置扩展已经构建为“共享”，可以通过composer.json（括号中给出的内部标识符名称）启用：\n BCMath (bcmath) Calendar (calendar) Exif (exif) FTP (ftp) GD (gd; with PNG, JPEG and FreeType support) GMP (gmp) gettext (gettext) IMAP (imap; with SASL and Kerberos support) intl (intl) LDAP (ldap; with SASL support) mbstring (mbstring) mcrypt (mcrypt) PCNTL (pcntl) Shmop (shmop) SOAP (soap) SQLite3 (sqlite3) SQLite (PDO) (pdo_sqlite) XMLRPC (xmlrpc) XSL (xsl)  可以通过composer.json启用以下第三方扩展（括号中给出的内部标识符名称）：\n APCu (apcu; provides an apc extension for compatibility with legacy software) Blackfire (blackfire) Cassandra (cassandra) ev (ev) event (event) ImageMagick (imagick) memcached (memcached; built against a version of libmemcached with SASL support) MongoDB (mongodb) New Relic (newrelic; will automatically be enabled when the New Relic Add-On is detected during a build) OAuth (oauth) Phalcon (phalcon) pq (pq) rdkafka (rdkafka) PHPRedis (redis)  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/etc/procfile/",
	"title": "Procfile文件",
	"tags": [],
	"description": "讲解Procfile文件的用法",
	"content": " Procfile介绍 Procfile 是Rainbond基于代码指定服务运行方式的策略。其本身是一个普通的文本文件，需要将其放到代码的跟目录中，其内容是定义源码构建的服务运行起来的启动命令。通常情况下只包含一行信息即可，请看下面的例子：\n Java语言类型，定义启动命令运行War包  web: java -jar /opt/webapp-runner.jar --port $PORT --session-store redis ./*.war   直接执行二进制文件，例如nginx\nweb: vendor/bin/heroku-php-nginx  执行启动脚本，例如执行Maven生成的Tomcat Java Server脚本\n  web: sh target/bin/webapp   启动ruby项目  bundle exec bin/rails server -p $PORT -e $RAILS_ENV  您可能注意到了 `$PORT` 这个环境变量，指定服务的监听端口。Rainbond运行服务时将自动通过用户设置的端口信息注入此环境变量。通过上诉类型的启动命令，实现服务监听端口的灵活配置。类似的机制还可以被使用到例如Tomcat启动等几乎所有语言服务类型中。  Procfile格式说明 \u0026lt;服务类型\u0026gt;: \u0026lt;命令\u0026gt;   \u0026lt;服务类型\u0026gt; : 目前仅支持 web 服务类型\n \u0026lt;命令\u0026gt; : 启动程序的命令行，执行的命令必须是前台运行。\n  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java_more/spring-boot-mysql/",
	"title": "Spring Boot框架配置MySQL",
	"tags": [],
	"description": "spring boot mysql demo",
	"content": " Spring Boot框架简化了新Spring应用的初始搭建以及开发过程，云帮支持平台部署Spring Boot类应用。\n云帮提供Spring Boot配置MySQL服务的示例，您可以在云市 一键式部署 Spring Boot-MySQL示例\n以下内容是本地创建和运行该示例的过程：\n创建示例 使用spring-boot-cli创建示例\n$ docker run -it --rm \\ -v $PWD:/app goodrainapps/spring-boot-cli:1.5.9 spring init --dependencies=web spring-boot-mysql-demo  进入示例类文件存放目录\n$ cd spring-boot-mysql-demo/src/main/java/com/example/springbootmysqldemo  添加DemoApplication.java\n@Controller @SpringBootApplication public class DemoApplication { @RequestMapping(\u0026quot;/\u0026quot;) @ResponseBody String home() { return \u0026quot;Hello World!\u0026quot;; } public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }  构建示例 为了加快maven构建，在setting.xml中添加了国内的mirror。将setting.xml拷贝到您的spring-boot-mysql-demo中。\n$ cd spring-boot-mysql-demo $ docker run -it --rm \\ -v \u0026quot;$PWD\u0026quot;:/app/build \\ -w /app/build maven:3.5.2-jdk-7-alpine mvn -B -DskipTests=true -s settings.xml clean install  运行 执行以下命令运行Hello World 示例\n$ cd spring-boot-mysql-demo $ docker run -it --rm -v $PWD:/app -w /app -p 8080:8080 goodrainapps/openjdk:8u131-jre-alpine java -jar target/*.jar  访问[http://localhost:8080](http://localhost:8080)查看运行结果。  配置数据库 云帮提供Spring-boot-mysql-demo的相关配置目录结构如下，配置文件内容仅供参考。\n详细配置参考下文：\n连接MySQL 添加以下内容，将此应用与数据库进行连接。\n在pom.xml内添mysql数据库服务 ：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  添加JDBC驱动：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  在application.properties添加数据库连接信息：\nspring.datasource.url=jdbc:mysql://${MYSQL_HOST}:${MSYQL_PORT}/demo?createDatabaseIfNotExist=true spring.datasource.username=${MYSQL_USER} spring.datasource.password=${MYSQL_PASS} spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.maxActive=10 spring.datasource.maxIdle=5 spring.datasource.minIdle=2 spring.datasource.initialSize=5 spring.datasource.removeAbandoned=true  在源码添加DatabaseConfig.java\n@Configuration public class DatabaseConfig { @Bean @Primary @ConfigurationProperties(prefix = \u0026quot;spring.datasource\u0026quot;) public DataSource dataSource() { return new org.apache.tomcat.jdbc.pool.DataSource(); } }  数据库初始化 使用 JPA 管理生成实体的映射关系的代码。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency  数据库重构与迁移 使用LiquiBase，以便将JPA生成实体的映射关系在数据库体现。第一步，在pom.xml添加：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.liquibase\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;liquibase-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  第二步，创建 Liquibase 的修改日志,默认从 db.changelog-master.yaml 读取：\ndatabaseChangeLog: - changeSet: id: 1 author: \u0026lt;your_name\u0026gt; changes: - createTable: tableName: person columns: - column: name: id type: int autoIncrement: true constraints:\tprimaryKey: true nullable: false - column: name: first_name type: varchar(255) constraints: nullable: false - column: name: last_name type: varchar(255) constraints: nullable: false  模板渲染 Thymeleaf可以帮助渲染XML、XHTML、HTML5内容的模板引擎，它也可以轻易的与Spring MVC等Web框架集成作为Web应用的模板引擎。在pom.xml中添加：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  docker化改造 为了支持 Spring Boot MySQL demo 轻松部署在云帮，将demo使用Dockerfile构建镜像，在云帮实现一键式部署\n#使用配置好环境的父镜像 FROM maven:3.5.2-jdk-7-alpine #创建demo源码工作目录 RUN mkdir /app #将本地源码拷贝到镜像中 COPY . /app/ #指定工作目录 WORKDIR /app #声明映射端口 EXPOSE 5000 #指定maven的配置文件，文件内制定新的mirror地址 RUN mvn -B -DskipTests=true clean install #启动脚本 ENTRYPOINT [\u0026quot;/app/run.sh\u0026quot;]  构建镜像 $ docker build -t goodrainapps/spring-boot-mysql-demo .  运行 #运行mysql $ docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql  #运行示例 $ docker run -it --rm --link mysql \\ -p 5000:5000 \\ -e MYSQL_HOST=mysql \\ -e MYSQL_PORT=3306 \\ -e MYSQL_USER=root \\ -e MYSQL_PASS=123456 \\ goodrainapps/spring-boot-mysql-demo  访问[http://localhost:5000](http://localhost:5000)查看Spring Boot 框架配置MySQL服务的运行界面  "
},
{
	"uri": "http://skyzhangyf.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java_more/tomcat-redis-session/",
	"title": "Tomcat配置Redis实现Session共享",
	"tags": [],
	"description": "how-to-use-rainbond",
	"content": " 为了使您的应用承受更多的并发，提高应用稳定性，您需要在适当情况下进行扩容。每个节点下的Tomcat只存储来访问自己的请求时产生的session，为了解决扩容后session持久化的问题，我们提供 Java的War包项目使用Tomcat配置Redis实现Session共享 解决方案，将您session储存在redis中来保证您应用程序稳定性。如图所示：\n\n 若 Load Balancing 将请求发送给 container 1 下的 tomcat A ，同时产生 session ，将此 session 持久化到Redis 中。当 Web Server 再次发送请求，若请求到 container 2的 tomcat A ，此时会在Redis 中找到已存在的 session，即取即用。\n 通过源码构建，您可以通过如下两种方式实现 配置redis实现session共享:\n使用Webapp-Runner或Jetty-Runner 云帮使用 [webapp-Runner]() 内嵌的 tomcat 或 [jetty-Runner]() 内嵌的 jetty 实现服务器功能。在您不创建其他服务器情况下即可轻松将应用部署在云帮。通过以下步骤可实现 配置redis实现session共享。\n 配置Procfile：将如下命令添加到您的Procfile中，并源码根目录下添加Procfile。\nweb: java -jar ./webapp-runner.jar --port $PORT --session-store redis ./*.war   指定了监听端口，通过获取环境变量 $PORT,此变量Rainbond根据平台设置的服务端口进行自动注入 指定session存储--session-store redis  从应用市场安装Redis服务，并设置当前服务依赖创建的Redis服务，参考文档 依赖服务\n 应用配置redis：将REDIS_URL新增至应用环境变量中，值为 redis://:${REDIS_PASS}@127.0.0.1:6379。\n 重启应用以适配\n  使用docker镜像 云帮提供使用定制 tomcat 容器来启动应用的方法。通过以下步骤可实现 配置redis实现session共享。\n 创建Dockerfile，写入如下内容：\n 使用源码    FROM goodrainapps/tomcat:7.0.82-jre7-alpine RUN rm /usr/local/tomcat/webapps/ROOT COPY \u0026lt;dir_name\u0026gt; /usr/local/tomcat/webapps/ROOT\t#\u0026lt;dir_name\u0026gt;为源码目录名称 EXPOSE 8080   使用war包   FROM goodrainapps/tomcat:7.0.82-jre7-alpine RUN rm /usr/local/tomcat/webapps/ROOT COPY \u0026lt;filename\u0026gt;.war /usr/local/tomcat/webapps/ROOT.war EXPOSE 8080   确认源码的\u0026lt;dir_name\u0026gt;或\u0026lt;filename\u0026gt;.war存在，并且与Dockerfile文件存在同一目录，以此目录为根目录开始创建服务 安装Redis服务并建立依赖关系，参考文档 依赖服务 应用配置redis：配置变量REDIS_URL到应用环境变量中，值为 127.0.0.1:6379；配置变量REDIS_SESSION到应用环境变量中，值为true。 重启应用以适配  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/calico/",
	"title": "calico组件说明",
	"tags": [],
	"description": "calico组件参数说明",
	"content": " 守护运行方式  node会生成calico的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat calico获取calico的systemd配置文件\ncalico服务是通过镜像运行\n calico默认配置文件/opt/rainbond/conf/network.yaml\n常用参数说明 -e IP=\u0026lt;当前节点IP\u0026gt; -e CALICO_IPV4POOL_CIDR=\u0026lt;POD CIDR\u0026gt; -e NODENAME=\u0026lt;当前节点Node的UUID\u0026gt;  健康检查 /opt/rainbond/health/network.sh 检查容器是否运行\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/docker/",
	"title": "docker组件说明",
	"tags": [],
	"description": "docker组件参数说明",
	"content": " 守护运行方式 默认使用官方的安装方式部署docker.\n常用参数说明 默认配置文件: /etc/docker/daemon.json\n{ \u0026quot;insecure-registries\u0026quot;: [\u0026quot;goodrain.me\u0026quot;], \u0026quot;bip\u0026quot;: \u0026quot;172.30.42.1/16\u0026quot;, \u0026quot;userland-proxy\u0026quot;: false, \u0026quot;storage-driver\u0026quot;: \u0026quot;overlay2\u0026quot;, \u0026quot;max-concurrent-downloads\u0026quot;: 10, \u0026quot;log-driver\u0026quot;: \u0026quot;json-file\u0026quot;, \u0026quot;log-level\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;log-opts\u0026quot;: { \u0026quot;max-size\u0026quot;: \u0026quot;20m\u0026quot;, \u0026quot;max-file\u0026quot;: \u0026quot;2\u0026quot; } }  具体参数请参见docker官方文档\n配置docker信任私有镜像仓库 如果你的私有镜像仓库未配置https或者自签发https证书需要配置docker信任.\n 1. 未配置https或者自签发证书(不被浏览器信任的),则需要配置dockerinsecure-registries值,需要完需要重启docker  \u0026quot;insecure-registries\u0026quot;: [\u0026quot;goodrain.me\u0026quot;,\u0026quot;hub.test.com\u0026quot;],   2. 自签发证书，且docker不需要重启  需要将自签发域名的证书拷贝到如下路径 /etc/docker/certs.d/\u0026lt;私有镜像仓库域名\u0026gt;/\n示例goodrain.me\nroot@compute-node-99:/etc/docker/certs.d/goodrain.me# ls server.crt  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/etcd/",
	"title": "etcd/etcd-proxy组件说明",
	"tags": [],
	"description": "etcd&amp;etcd-proxy组件参数说明",
	"content": " 守护运行方式  第一次是通过默认systemd配置文件启动，在node启动完成后由node接管\nnode会重新生成etcd的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat etcd获取etcd的systemd配置文件\netcd/etcd-proxy服务是通过镜像运行\n etcd默认配置文件/opt/rainbond/conf/etcd.yaml (管理节点) etcd-proxy默认配置文件 /opt/rainbond/conf/etcd-proxy.yaml (计算节点)\n常用参数说明 具体参数请参见etcd官方文档\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/tools/grclis/",
	"title": "grclis",
	"tags": [],
	"description": "Rainbond grclis",
	"content": " 启动/停止服务 # 启动所有服务 grclis start # 停某服务 grclis stop \u0026lt;某服务\u0026gt; # 停所有服务 grclis stop  更新服务 # 更新Rainbond所有组件 grclis upgrade all # 更新node grclis upgrade node # 更新Rainbond某组件 grclis upgrade \u0026lt;组件\u0026gt;  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/tools/grctl/",
	"title": "grctl",
	"tags": [],
	"description": "Rainbond CLI工具集",
	"content": "  grctl命令是rainbond自带的集群管理工具，它具备如下主要功能特性：\n    功能模块 命令示例     平台应用控制 grctl service get \u0026lt;应用别名\u0026gt; -t \u0026lt;团队别名\u0026gt; 查看应用详情\ngrctl service stop \u0026lt;团队别名\u0026gt;/\u0026lt;应用别名\u0026gt; 关闭指定团队内某个应用\ngrctl service start \u0026lt;团队别名\u0026gt;/\u0026lt;应用别名\u0026gt; 启动指定团队内某个应用\ngrctl service list -t \u0026lt;团队别名\u0026gt; 列出应用信息\ngrctl tenant list列出所有团队\ngrctl tenant get \u0026lt;团队别名\u0026gt;列出该团队所有应用\ngrctl tenant res \u0026lt;团队别名\u0026gt;该团队使用资源grctl tenant batchstop \u0026lt;团队别名\u0026gt;批量停团队应用\ngrctl exec \u0026lt;PODNAME\u0026gt; \u0026lt;CMD\u0026gt;\ngrctl msg应用异常处理   集群节点控制 grctl init初始化数据中心\ngrctl cluster 查看集群情况\ngrctl node list 查看集群节点列表\ngrctl node get \u0026lt;节点ID\u0026gt;查看节点状态\ngrctl node down \u0026lt;节点ID\u0026gt;下线指定节点\ngrctl node up \u0026lt;节点ID\u0026gt;上线指定节点\ngrctl node delete \u0026lt;节点ID\u0026gt;删除指定节点\ngrctl node cordon \u0026lt;节点ID\u0026gt;将某个节点设置为不可调度\ngrctl node uncordon \u0026lt;节点ID\u0026gt;恢复某个节点的调度\ngrctl node resource查看集群资源使用情况\ngrctl node rule节点身份属性\ngrctl node label节点label标签\ngrctl node condition节点condition\n   集群运维控制 grctl node add节点扩容\ngrctl reset重置当前节点\ngrclt domain调整集群默认解析grctl msg/alerting集群报警功能     如何得知当前应用的 \u0026lt;团队别名\u0026gt; \u0026lt;应用别名\u0026gt;？\n 更多信息可通过help命令获取\n[root@node1 ~]# grctl -h NAME: grctl - A new cli application USAGE: grctl [global options] command [command options] [arguments...] VERSION: 5.1.1-5cb66ee-2019-03-21-10 COMMANDS: alerting alerting rule manage buildtest build test source code, If it can be build, you can build in rainbond cluster show curren cluster datacenter info conf Cluster and service configuration manage cmd domain Default *.grapps.cn domain resolution exec open pod ttl console。grctl exec POD_NAME COMMAND init grctl init cluster msg manage exception notification events。grctl msg node rainbond node manage cmd reset reset the current node service about application service operation，grctl service -h show Display region api address after installation tenant grctl tenant -h help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --config value, -c value default \u0026lt;USER_HOME\u0026gt;/.rbd/grctl.yaml --kubeconfig value, --kube value default \u0026lt;USER_HOME\u0026gt;/.kube/config --help, -h show help --version, -v print the version  应用级别 # 获取应用详情 grctl service get grac5e3c -t 4ur5male  应用异常处理 使用grctl msg get默认获取三天内未处理的应用异常事件，如果你需要查询某时间段的异常事件，可以使用--st和--et分别指定开始时间戳与结束时间戳，如果只有开始时间并不指定结束时间，则结束时间默认为当前时间。\n# 获取异常信息 grctl msg get --st 1539267839 --et 1544538239 # 处理异常 grctl msg handle -n gr9c80c9 -m '应用已处理'  集群级别  查看集群信息  grctl cluster   列出集群节点信息  grctl node list   获取某个节点的详细信息  # 可以获取这个节点集群服务的健康状态 grctl node get dfbb29b0d7b8b340120b4bb81a49efff   下线与上线某个节点  # 下线节点 grctl node down dfbb29b0d7b8b340120b4bb81a49efff # 上线节点 grctl node up dfbb29b0d7b8b340120b4bb81a49efff   禁止/允许调度到某个节点  # 禁止调度到某个节点 grct node cordon dfbb29b0d7b8b340120b4bb81a49efff # 允许调度到某个节点 grctl node uncordon dfbb29b0d7b8b340120b4bb81a49efff   进行容器内部  grctl exec \u0026lt;PodName\u0026gt; bash   修改域名解析  grctl domain --ip \u0026lt;ip address\u0026gt;  节点初始化重要参数说明 USAGE: grctl init [command options] [arguments...] OPTIONS: --role value Node identity property (default: \u0026quot;manage,compute\u0026quot;) --iip value Internal IP --eip value External IP --rainbond-version value Rainbond Install Version. default 5.1 (default: \u0026quot;5.1\u0026quot;) --rainbond-repo value Rainbond install repo (default: \u0026quot;https://github.com/goodrain/rainbond-ansible.git\u0026quot;) --install-type value Install Type: online/offline (default: \u0026quot;online\u0026quot;) --deploy-type value Deploy Type: onenode/multinode/thirdparty,默认onenode (default: \u0026quot;onenode\u0026quot;) --domain value Application domain --pod-cidr value Configuration pod-cidr --storage value Storage type, default:NFS (default: \u0026quot;nfs\u0026quot;) --network value Network type, support calico/flannel/midonet,default: calico (default: \u0026quot;calico\u0026quot;) --enable-check value enable check cpu/mem. default: enable/disable (default: \u0026quot;enable\u0026quot;) --storage-args value Stores mount parameters (default: \u0026quot;/grdata nfs rw 0 0\u0026quot;) --enable-exdb value default disable external database --exdb-type value external database type(mysql,postgresql) --exdb-host value external database host --exdb-port value external database port (default: \u0026quot;3306\u0026quot;) --exdb-user value external database user --exdb-passwd value external database password --excsdb-host value external console database host --excsdb-port value external console database port (default: \u0026quot;3306\u0026quot;) --excsdb-user value external console database user --excsdb-passwd value external console database password --enable-excsdb-only value Additional support for the console to configure the database separately     参数 默认值 可选值 说明     role manage,compute manage,compute,manage 节点身份属性,默认是管理节点计算节点复用   iip   当前节点内网ip,未指定内网ip，当多网卡时会随机选择一个内网地址(多网卡建议指定)   eip   当前节点公网ip(SLB或者弹性ip等),如果指定公网ip,则默认域名(grapps.cn)会解析到此公网ip   rainbond-version 5.1 5.0,devel(测试分支) 默认是当前稳定版本   rainbond-repo https://github.com/goodrain/rainbond-ansible.git  rainbond-ansible仓库地址   install-type online offline 安装类型:在线安装/离线安装   deploy-type onenode thirdparty 部署类型:内置k8s/对接k8s   domain   应用默认分配域名,在线未指定域名，则会生成grapps.cn默认域名;离线未指定会生成pass.example.com或pass.grapps.cn   pod-cidr   应用的ip   storage nfs nas,gfs 存储类型   storage-args   存储参数,示例nas: \u0026ldquo;82b554a292-rvg38.cn-huhehaote.nas.aliyuncs.com:/ /grdata nfs vers=3,nolock,noatime 0 0\u0026rdquo;   network calico flannel 应用网络类型   enable-check enable disable 默认开启系统检查    # 示例初始化集群，使用阿里云NAS ./grctl init --iip 172.24.202.225 --eip 39.104.75.32 --rainbond-version devel --rainbond-repo https://github.com/ysicing/rainbond-ansible.git --storage nas --storage-args \u0026quot;82b554a292-rvg38.cn-huhehaote.nas.aliyuncs.com:/ /grdata nfs vers=3,nolock,noatime 0 0\u0026quot;  初始化时对接外部数据库  5.1.3版本支持\n    参数 说明     \u0026ndash;enable-exdb 默认禁用使用外部数据库，启动值为true   \u0026ndash;exdb-type 默认数据库类型，目前只支持mysql   \u0026ndash;exdb-host/\u0026ndash;exdb-port/\u0026ndash;exdb-user/\u0026ndash;exdb-passwd 外部数据库连接信息   \u0026ndash;enable-excsdb-only console使用外部数据库   \u0026ndash;excsdb-host/\u0026ndash;excsdb-port/\u0026ndash;excsdb-user/\u0026ndash;excsdb-passwd 外部数据库(console)连接信息    当启用外部数据库时,其他配置项才生效  # 此示例表示, 数据中心数据库和控制台数据库都使用外部数据库(不分离) ./grctl init --enable-exdb true --exdb-host 139.196.72.60 --exdb-port 21355 --exdb-user admin --exdb-passwd c13dc213 # 此示例表示, 数据中心数据库使用本地数据库(rbd-db), 控制台数据库都使用外部数据库 ./grctl init --enable-exdb true --enable-excsdb-only true --excsdb-host 139.196.72.60 --excsdb-port 21355 --excsdb-user admin --excsdb-passwd c13dc213 # 此示例表示, 数据中心数据库和控制台数据库都使用外部数据库(分离) ./grctl init --enable-exdb true --exdb-host 139.196.72.60 --exdb-port 21356 --exdb-user admin --exdb-passwd c13dc213 --enable-excsdb-only true --excsdb-host 139.196.72.60 --excsdb-port 21355 --excsdb-user admin --excsdb-passwd c13dc213  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/kubelet/",
	"title": "kubelet组件说明",
	"tags": [],
	"description": "kubelet组件参数说明",
	"content": " 守护运行方式  通过二进制运行,由node生成systemd文件并启动\n kubelet默认配置文件/opt/rainbond/conf/k8s-worker.yaml (计算节点)\n常用参数说明 `ExecStart=/bin/bash -c 'NODE_UUID=959eba4b-6bbe-4ad5-ba0f-ecfad17d378d/opt/rainbond/scripts/kubelet.sh'` 其中NODE_UUID值为当前节点node的uuid  具体参数请参见k8s官方文档\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/k8s/",
	"title": "kubernetes master组件说明",
	"tags": [],
	"description": "kubernetes master组件参数说明",
	"content": " 守护运行方式  由node生成systemd文件并启动,以镜像方式运行.\n kubernetes master组件默认配置文件/opt/rainbond/conf/k8s-master.yaml\n常用参数说明 具体参数请参见k8s官方文档\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/node/",
	"title": "node组件说明",
	"tags": [],
	"description": "Rainbond Node组件参数说明",
	"content": "  node: 集群监控与控制服务,通过二进制运行\n 守护运行方式  通过systemd守护运行,可以通过systemctl cat node获取node的systemd配置文件\n # /opt/rainbond/scripts/start-node.sh NODE_OPTS=\u0026quot;--log-level=info --auto-scheduler=true --hostIP=172.20.0.101 --run-mode master --noderule manage,compute --etcd=http://127.0.0.1:2379 --kube-conf=/opt/rainbond/etc/kubernetes/kubecfg/admin.kubeconfig \u0026quot; exec /usr/local/bin/node $NODE_OPTS  常用参数说明 仅列出启动常用参数，其他未列出参数默认即可\n--auto-registnode (当集群中未注册此节点时自动注册节点,默认启用) --auto-scheduler (当节点不健康时自动将节点设置为不可调度,仅计算节点时生效,默认启用) --etcd (etcd地址,默认 [http://127.0.0.1:2379]) --hostIP (当前节点ip,未指定时获取eth0 ip) --kube-conf (k8s admin用户配置文件 \u0026quot;/opt/rainbond/etc/kubernetes/kubecfg/admin.kubeconfig\u0026quot;) --log-level (日志级别，默认info) --nodeid-file (节点标识文件路径，默认\u0026quot;/opt/rainbond/etc/node/node_host_uuid.conf\u0026quot;,内容格式为`host_uuid=959eba4b-6bbe-4ad5-ba0f-ecfad17d378d`,不存在则会默认生成) --noderule (节点删除属性，默认是compute) --run-mode (node属性,默认是worker)  其他扩展命令 # 更新服务配置并启动，不指定组件名则默认为全部 node service update \u0026lt;组件名\u0026gt; # 启动停止服务 node service start/stop \u0026lt;组件名\u0026gt;  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/etc/rainbondfile/",
	"title": "rainbondfile源码定义环境配置文件",
	"tags": [],
	"description": "讲解rainbondfile文件的用法",
	"content": " rainbondfile介绍 rainbondfile 是Rainbond基于代码指定服务运行环境的策略。其本身是一个普通的yaml格式的文本文件，需要将其放到代码的根目录中，其适用于所有基于源码构建的服务类型。目前rainbondfile支持定义环境变量 端口 持久化存储 启动命令四个项目。Rainbond在创建服务的过程中将识别其中定义的内容自动设置到服务属性中，在Rainbond控制台可以查阅。 完整用例如下：\nlanguage: Java-maven buildpath: target/ ports: - port: 8080 protocol: http #如需开启多个端口，则继续添加端口并指定协议 - port: 5000 protocol: tcp envs: ENV_KEY1: ENV_VALUE1 ENV_KEY2: ENV_VALUE2 # 适用于Dockerfile、NetCore源码类型 cmd: java -jar xxxx.jar  rainbondfile作用 源码定义环境是Rainbond推荐的服务管理策略。通过rainbondfile的定义可以便捷的批量添加环境变量等服务属性，后续版本将逐步增加可配置的属性。\n支持的配置项目说明  language 源码类型 ports 服务端口列表 envs 服务环境变量列表 buildpath 服务主目录不在当前目录时有用，指定二级目录地址 cmd 指定服务运行方式，适用于Dockerfile、NetCore源码类型，其他语言通过Procfile指定运行方式  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-api/",
	"title": "rbd-api组件说明",
	"tags": [],
	"description": "rbd-api组件参数说明",
	"content": " 守护运行方式  node会生成rbd-api的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-api获取rbd-api的systemd配置文件\nrbd-api服务是通过镜像运行\n rbd-api默认配置文件/opt/rainbond/conf/master.yaml\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-app-ui/",
	"title": "rbd-app-ui组件说明",
	"tags": [],
	"description": "rbd-app-ui组件参数说明",
	"content": " 守护运行方式  node会生成rbd-app-ui的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-app-ui获取rbd-app-ui的systemd配置文件\nrbd-app-ui服务是通过镜像运行\n rbd-app-ui默认配置文件/opt/rainbond/conf/ui.yaml\n常用参数说明 日志文件在/opt/rainbond/logs/rbd-app-ui\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-chaos/",
	"title": "rbd-chaos(builder)组件说明",
	"tags": [],
	"description": "rbd-chaos(builder)组件参数说明",
	"content": " 守护运行方式  node会生成rbd-chaos的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-chaos获取rbd-chaos的systemd配置文件\nrbd-chaos服务是通过镜像运行\n rbd-chaos默认配置文件/opt/rainbond/conf/master.yaml\n环境变量 GITHUB_PROXY  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-db/",
	"title": "rbd-db组件说明",
	"tags": [],
	"description": "rbd-db组件参数说明",
	"content": " 守护运行方式  node会生成rbd-db的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-db获取rbd-db的systemd配置文件\nrbd-db服务是通过镜像运行\n rbd-db默认配置文件/opt/rainbond/conf/db.yaml\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-dns/",
	"title": "rbd-dns组件说明",
	"tags": [],
	"description": "rbd-dns组件参数说明",
	"content": " 守护运行方式  node会生成rbd-dns的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-dns获取rbd-dns的systemd配置文件\nrbd-dns服务是通过镜像运行\n rbd-dns默认配置文件/opt/rainbond/conf/dns.yaml\n常用参数说明 --nameservers 上游dns --recoders 解析记录  如果需要通过rbd-dns解析某个域名\n--recoders=goodrain.me=192.168.195.1,*.goodrain.me=192.168.195.1,buhuibaidu.me=172.20.0.101,*.buhuigoogle.me=172.20.0.102  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-eventlog/",
	"title": "rbd-eventlog组件说明",
	"tags": [],
	"description": "rbd-eventlog组件参数说明",
	"content": " 守护运行方式  node会生成rbd-eventlog的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-eventlog获取rbd-eventlog的systemd配置文件\nrbd-eventlog服务是通过镜像运行\n rbd-eventlog默认配置文件/opt/rainbond/conf/master.yaml\n环境变量 DOCKER_LOG_SAVE_DAY: 日志保留时间(默认7天)  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-gateway/",
	"title": "rbd-gateway组件说明",
	"tags": [],
	"description": "rbd-gateway组件参数说明",
	"content": " 守护运行方式  node会生成rbd-gateway的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-gateway获取rbd-gateway的systemd配置文件\nrbd-gateway服务是通过镜像运行\n rbd-gateway默认配置文件/opt/rainbond/conf/lb.yaml\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-hub/",
	"title": "rbd-hub组件说明",
	"tags": [],
	"description": "rbd-hub组件参数说明",
	"content": "  rbd-hub基于registry镜像\n 守护运行方式  node会生成rbd-hub的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-hub获取rbd-hub的systemd配置文件\nrbd-hub服务是通过镜像运行\n rbd-hub默认配置文件/opt/rainbond/conf/base.yaml\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-monitor/",
	"title": "rbd-monitor组件说明",
	"tags": [],
	"description": "rbd-monitor组件参数说明",
	"content": " 守护运行方式  node会生成rbd-monitor的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-monitor获取rbd-monitor的systemd配置文件\nrbd-monitor服务是通过镜像运行\n rbd-monitor默认配置文件/opt/rainbond/conf/master.yaml\n常用参数说明 --alertmanager-address AlertManager地址 --cadvisor-listen-port kubelet cadvisor监听端口 --config.file Prometheus 配置文件路径 --rules-config.file Prometheus alerting rules文件路径 --storage.tsdb.retention 数据保留时间，默认7天  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-mq/",
	"title": "rbd-mq组件说明",
	"tags": [],
	"description": "rbd-mq组件参数说明",
	"content": " 守护运行方式  node会生成rbd-mq的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-mq获取rbd-mq的systemd配置文件\nrbd-mq服务是通过镜像运行\n rbd-mq默认配置文件/opt/rainbond/conf/master.yaml\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-repo/",
	"title": "rbd-repo组件说明",
	"tags": [],
	"description": "rbd-repo组件参数说明",
	"content": " 守护运行方式  node会生成rbd-repo的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-repo获取rbd-repo的systemd配置文件\nrbd-repo服务是通过镜像运行\n rbd-repo默认配置文件/opt/rainbond/conf/base.yaml\nJava程序,推荐配置2核4G起,启动时比较占资源  "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-webcli/",
	"title": "rbd-webcli组件说明",
	"tags": [],
	"description": "rbd-webcli组件参数说明",
	"content": " 守护运行方式  node会生成rbd-webcli的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-webcli获取rbd-webcli的systemd配置文件\nrbd-webcli服务是通过镜像运行\n rbd-webcli默认配置文件/opt/rainbond/conf/master.yaml\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/component/rbd-worker/",
	"title": "rbd-worker组件说明",
	"tags": [],
	"description": "rbd-worker组件参数说明",
	"content": " 守护运行方式  node会生成rbd-worker的systemd配置文件,并通过systemd守护运行,可以通过systemctl cat rbd-worker获取rbd-worker的systemd配置文件\nrbd-worker服务是通过镜像运行\n rbd-worker默认配置文件/opt/rainbond/conf/master.yaml\n常用参数说明 --node-name=\u0026lt;当前节点Node的UUID\u0026gt;  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/java_more/webapp-runner/",
	"title": "webapp-runner使用指南",
	"tags": [],
	"description": "how-to-use-rainbond",
	"content": " webapp-runner可以在任何安装有JRE环境的系统中利用Tomcat将应用程序启动。使用webapp-runner不需要安装Tomcat。它只是一个jar文件可以用java命令运行和配置。\n版本说明  Webapp Runner 是基于Tomcat server的。默认Rainbond支持的版本如下:\n    web服务支持 web服务版本 自定义Procfile中jar文件名     tomcat7 webapp-runner-7.0.91.0.jar webapp-runner.jar   tomcat8 webapp-runner-8.0.52.0.jar webapp-runner.jar   tomcat85 (默认) webapp-runner-8.5.38.0.jar webapp-runner.jar   tomcat9 webapp-runner-9.0.16.0.jar webapp-runner.jar   jetty7 jetty-runner-7.5.4.v20111024.jar jetty-runner.jar   jetty9 jetty-runner-9.4.0.v20161208.jar jetty-runner.jar    Webapp Runner 是如何工作的 在本地或Rainbond使用webapp-runner启动应用程序时的命令类似如下格式：\n$ java -jar ./webapp-runner.jar myProject.war  or\n$ java -jar ./webapp-runner.jar path/to/my/project  help\n$ java -jar ./webapp-runner.jar --help  如果你是Maven项目,你可以通过这样的方式启动：\n$ java -jar ./webapp-runner.jar target/\u0026lt;appname\u0026gt;.war  webapp-unner 会利用给定的war文件启动一个Tomcat实例。它会使用Tomcat提供的内嵌API来把程序跑起来，与jetty-runner提供的选项有些类似。 webapp-runner 是 开源 软件，你可以随时查阅项目源码。\n高级特性配置 目前Rainbond提供的Webapp-runner都支持session管理.\nsession管理 $ java -jar ./webapp-runner.jar --session-store memcache target/\u0026lt;appname\u0026gt;.war  然后确保有三个环境变量可供配置 MEMCACHE_SERVERS, MEMCACHE_USERNAME, MEMCACHE_PASSWORD\n或者\n$ java -jar ./webapp-runner.jar --session-store redis target/\u0026lt;appname\u0026gt;.war  然后确保Redis环境变量可用于配置：REDIS_URL\n设置访问路径 $ java -jar ./webapp-runner.jar --path /phone target/\u0026lt;appname\u0026gt;.war  更多参数配置 $ java -jar webapp-runner.jar --help The specified path \u0026quot;src/main/webapp\u0026quot; does not exist. Usage: \u0026lt;main class\u0026gt; [options] Options: --access-log Enables AccessLogValue to STDOUT Default: false --access-log-pattern If --access-log is enabled, sets the logging pattern Default: common --basic-auth-pw Password to be used with basic auth. Defaults to BASIC_AUTH_PW env variable. --basic-auth-user Username to be used with basic auth. Defaults to BASIC_AUTH_USER env variable. --bind-on-init Controls when the socket used by the connector is bound. By default it is bound when the connector is initiated and unbound when the connector is destroyed., default value: true Default: true --compressable-mime-types Comma delimited list of mime types that will be compressed when using GZIP compression. Default: text/html,text/xml,text/plain,text/css,application/json,application/xml,text/javascript,application/javascript --context-xml The path to the context xml to use. --enable-basic-auth Secure the app with basic auth. Use with --basic-auth-user and --basic-auth-pw or --tomcat-users-location Default: false --enable-client-auth Specify -Djavax.net.ssl.keyStore and -Djavax.net.ssl.keyStorePassword in JAVA_OPTS Default: false --enable-compression Enable GZIP compression on responses Default: false --enable-naming Enables JNDI naming Default: false --enable-ssl Specify -Djavax.net.ssl.keyStore, -Djavax.net.ssl.keyStorePassword, -Djavax.net.ssl.trustStore and -Djavax.net.ssl.trustStorePassword in JAVA_OPTS. Note: should not be used if a reverse proxy is terminating SSL for you (such as on Heroku) Default: false --expand-war-file Expand the war file and set it as source Default: true --expanded-dir-name The name of the directory the WAR file will be expanded into. Default: expanded --help Default: false --max-threads Set the maximum number of worker threads Default: 0 --path The context path Default: \u0026lt;empty string\u0026gt; --port The port that the server will accept http requests on. Default: 8080 --proxy-base-url Set proxy URL if tomcat is running behind reverse proxy Default: \u0026lt;empty string\u0026gt; --scanBootstrapClassPath Set jar scanner scan bootstrap classpath. Default: false --session-store Session store to use (valid options are 'memcache' or 'redis') --session-store-ignore-pattern Request pattern to not track sessions for. Valid only with memcache session store. (default is '.*\\.(png|gif|jpg|css|js)$'. Has no effect for 'redis') Default: .*\\.(png|gif|jpg|css|js)$ --session-store-locking-mode Session locking mode for use with memcache session store. (default is all. Has no effect for 'redis') Default: all --session-store-operation-timeout Operation timeout for the memcache session store. (default is 5000ms) Default: 5000 --session-store-pool-size Pool size of the session store connections (default is 10. Has no effect for 'memcache') Default: 10 --session-timeout The number of minutes of inactivity before a user's session is timed out. --shutdown-override Overrides the default behavior and casues Tomcat to ignore lifecycle failure events rather than shutting down when they occur. Default: false --temp-directory Define the temp directory, default value: ./target/tomcat.PORT --tomcat-users-location Location of the tomcat-users.xml file. (relative to the location of the webapp-runner jar file) --uri-encoding Set the URI encoding to be used for the Connector. --use-body-encoding-for-uri Set if the entity body encoding should be used for the URI. Default: false -A Allows setting HTTP connector attributes. For example: -Acompression=on Syntax: -Akey=value Default: {}  关于设置设置HTTP连接属性,如 -Acompression=on,可以参考 Apache Attributes\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/business-center/business-center/",
	"title": "企业中心",
	"tags": [],
	"description": "平台设置、团队管理",
	"content": " 功能描述 企业管理员可以设置平台信息，管理企业下的团队。\n企业信息 展示包含着企业名称、创建时间以及平台版本。\n平台设置  如果您是企业管理员，平台设置模块才会显示\n 设置用户是否允许注册 添加用户 填写用户名\u0026gt;所属团队\u0026gt;密码\u0026gt;邮箱\u0026gt;角色权限\n 提示: 填写团队时,输入框会根据您输入的值匹配企业下的所有团队在下拉框里列出\n提示: 填写\u0008角色权限时,下拉框所列出的角色权限是根据团队所分配的\n 团队管理 管理该平台下的所有团队,\u0008包括添加团队，删除团队。\n 提示：如果您是企业管理员，团队管理模块才会显示。\n 添加团队 如果您具有团队权限设置权限，才可以进行操作，点击确定后方可在所选的数据中心下创建团队 删除团队 企业管理员可以删除（可以删除的）团队，哪怕你不是该团队的管理员。 "
},
{
	"uri": "http://skyzhangyf.github.io/user-operations/tools/other/",
	"title": "其他命令行工具",
	"tags": [],
	"description": "其他命令行工具(dps,din等)",
	"content": " din 进入指定容器\ndin \u0026lt;容器ID/容器Name\u0026gt;  如报错容器中没有bash，则在命令后加 sh  dps 查看所有容器\ncclear 清理已经退出的容器\nctop 查看容器资源使用情况\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-creation/language-support/etc/envs/",
	"title": "其他环境变量设置",
	"tags": [],
	"description": "其他环境变量设置",
	"content": " 源码应用设置locale 设置运行环境语言\n# 变量名 变量值 LANGUAGE en_US.UTF-8 LANG en_US:zh_CN.UTF-8 LC_ALL C  "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/connection-git-server/",
	"title": "对接私有源码仓库（Git、Svn）",
	"tags": [],
	"description": "讲解Rainbond如何获取私有源代码仓库进行源码构建",
	"content": " 原理解读 通过自定义源码的方式创建应用 当你填写Git地址时，平台会自动判断地址的协议，如果是HTTP的Git地址，平台会提示你输入Git仓库的用户名和密码，如果是公开项目，用户名密码可以省略。当输入的Git地址是SSH协议时，平台会提示你将Rainbond的SSH公钥复制到Git仓库中。Rainbond会为每个团队生成独立的公钥以避免多团队密钥冲突。\n当你填写Svn代码地址时，平台提示输入账号名和密码，如果是私有仓库，请务必输入账号。\n操作流程 本文主要讲解通过 SSH 公钥的方式对接私有部署的Git仓库，以 GitLab为示例进行说明。\nGitlab创建新项目  如果你已有项目，此步骤跳过\n  新建项目   填写项目名称   创建示例代码  切换到SSH地址后，需要记住项目的SSH地址，后续创建应用时需要用到，这里的地址是 `git@172.16.210.205:test/helloworld.git`  新建一个index.html 的文件，内容为 hello world,hello goodrain! 提交。\n配置SSH公钥对接私有仓库 获取公钥 进入【创建应用】-【从源码创建】-【自定义源码】，将项目的SSh协议的地址复制到【Git仓库地址】栏中时，会提示【配置授权Key】连接，点开显示详细信息：\n将公钥添加到Git仓库  切换到项目首页   添加SSH公钥   SSH 公钥添加完成  测试对接是否成功 通过私有仓库创建应用的方式来测试云帮能否通过SSH关于获取Git仓库中的代码。\n 创建服务  能够识别语言，代表对接成功\n  在Rainbond部署GitLab私有仓库服务 上文介绍的是对接现有GitLab的情况，如果你还没有Git仓库，Rainbond可以一键部署GitLab应用，下面主要介绍对接云帮上部署的GitLab\n创建GitLab应用 通过 【新建应用】-【应用市场】搜索到GitLab应用，选择需要的版本安装即可。\n配置GitLab GitLab安装完成后，可以在应用的端口页面看到对外打开的端口号，如下图：\n 端口号：应用内部监听的端口，本例中监听了22和80端口 访问地址：云帮映射的地址与端口，本例中 22端口映射的地址为172.16.210.205，端口为20006 ，80端口地址为80.grea7fc4.zggk.48mt2.goodrain.org，端口为80  - Rainbond为HTTP协议的应用端口默认分配一个访问域名 - Rainbond为非HTTP协议的应用端口默认分配一个访问地址和一个随机的映射端口，但端口映射与应用端口唯一对应，不会变化，因此本例的端口可能与你实际情况不一致。  设置GitLab的HTTP和SSH地址 GitLab应用通过 GITLAB_SSH_HOST 和 GITLAB_HOST 环境变量来设置SSH和HTTP的地址，因此需要将这两个变量设置到GitLab应用中。\n设置环境变量后，需要重启GitLab应用。  创建应用时Git地址中的端口配置 由于SSH协议使用的是非默认的22端口，因此在创建应用时，填写的Git地址也需要加上端口信息，格式如下：\n# 默认地址 git@172.16.210.205:test/helloworld.git # 修改为 git@172.16.210.205:20006/test/helloworld.git  "
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/ab-released-app/",
	"title": "应用A/B测试实践",
	"tags": [],
	"description": "基于Rainbond的应用A/B测试操作方案详解",
	"content": " 功能说明 对照实验，也叫随机实验和A /B测试。在软件开发中，产品需求通过多种技术手段来实现。 A/B测试实验提供了一个有价值的方式来评估新功能对客户行为的影响。 运行网站和服务的A/B测试实验能力，从而可以用更科学方法来评估规划过程中不同阶段的想法价值。一屋子人拍桌子瞪眼的争辩到底哪个设计好？哪个文案好？哪个执行策略有效，还不如让真实的用户和数据来告诉你答案。\n落实到技术本身上来，A/B测试讲究为不同的客户端提供不同的服务，这里的两个不同非常关键。\n 不同的客户端   一般是通过某种方式将客户端进行分类，比如HTTP协议，通常根据用户信息设置Header请求头、Cookie从而区分不同客户端。\n  不同的服务   一般是指不同的应用的不同版本，在Rainbond平台是不同的服务组件。\n {{site.data.alerts.callout_success}}\nRainbond目前支持HTTP协议的A/B测试实践，这也是目前应用面最广的协议。\n{{site.data.alerts.end}}\n服务需要进行A/B测试，需要区分其是属于内部服务还是对外服务。内部服务的A/B测试特性由ServiceMesh层提供，对外服务由应用网关提供。\n我们以下述场景为例，分别对 外部服务 外部服务2 内部服务 内部服务2 进行A/B测试实践。\n2. 对外服务的A/B测试实践 对外服务的A/B测试是最常使用的场景，因为对外服务是直接面对用户的服务。业务程序需要通过一定的业务策略将用户标识信息注入到Cookie中或者是通过移动端APP注入到Header请求头中。Rainbond应用网关可以识别这些标识并根据用户配置的策略匹配相应的服务提供给用户。\n如上图例子所示，外部服务 外部服务2 我已经提前创建，模拟为同一个业务程序的两个版本\n通过 应用网关 -\u0026gt; 访问策略 添加以下两个HTTP访问策略：\n 用法一：通过Header请求头标识客户端     域名 请求头 服务     www.test.com 无 外部服务   www.test.com user:test 外部服务2    测试方式：\n# 模拟请求外部服务,请注意，域名请按照添加访问策略文档提示正确进行DNS解析设置或本地HOST文件设置 curl www.test.com # 模拟请求外部服务2 curl -H user:test www.test.com  此方式适用于C/S架构下的服务端。比如移动端APP与API的交互。\n 用法二：通过Cookie标识客户端     域名 Cookie 服务     www.test.com 无 外部服务   www.test.com user=test 外部服务2    测试方式：\n# 模拟请求外部服务 curl www.test.com # 模拟请求外部服务2 curl --cookie \u0026quot;user=test\u0026quot; www.test.com  此方式适用于Web服务和其他HTTP请求服务。\n内部服务的A/B测试实践 内部服务不直接服务于用户，一般是为其他服务提供API支持，它的通信路径不会经过应用网关，因此不能通过应用网关来进行A/B控制。运行于Rainbond的所有业务都默认按照服务化的方式进行管理，以ServiceMesh的治理思想进行服务通信治理，A/B测试就是服务治理的功能之一。\n上文我们的事例中有 内部服务 和 内部服务2 ,我们已经提前创建。内部服务之间的通信需要建立依赖关系以完成内部服务注册和服务发现。在初始状态下 内部服务2 还属于独立状态，在将它加入的 外部服务 的下级依赖之间我们需要知道这样一个问题：\n两个内部服务本质上是同一个业务，使用了相同的服务端口，若在默认情况下有端口冲突是不能同时依赖它们的。这是我们需要先为外部服务 开通工作在7层的网络治理插件（平台默认提供），插件的工作原理将复用80端口，通过不同的域名等HTTP元素实现高级路由来选择使用的下级依赖服务。因此，要使用此插件的前提是：\n 模拟外部服务 请求 内部服务的通信地址必须是 主机名(顶级域名)\n比如请求用户服务API，请求地址: http://user/***\nRainbond环境下会默认解析主机名(顶级域名)\n我们通常建议将通信地址和端口读取环境变量的方式，只需要在内部服务上设置 连接信息 变量即可。\n  外部服务 依赖 内部服务2 ，操作方式见 添加服务依赖 或直接 操作拓扑图添加 为 外部服务 开通 服务网络治理插件  \n 配置路由策略，与基于应用网关的配置方法类似，不同的是只支持基于Header的处理方式。  \n如上配置完成后内部服务同样具备了A/B测试的能力。\n4. 数据反馈 在A/B测试过程中最关键的环节就是关注数据反馈，及时调整策略。Rainbond提供的业务级性能分析监控可以为你提供实时的请求情况分析，以辅助你的决策。在此之外，如果你有自己的监控方式，请根据你的监控结果合理调整策略，上诉的所有控制策略都能够修改动态生效。\n5. 存在的缺陷和改进计划  目前内部服务的A/B测试需要对每个服务进行配置，暂不支持全局性配置，后续的版本将支持ServiceMesh的全局配置。 目前未提供针对A/B测试的流程控制，后续的版本中流程化会突出迭代。 监控数据与测试过程自动化协调，实现自动化 A/B 测试  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-manage/share-app/",
	"title": "应用分享与发布",
	"tags": [],
	"description": "讲解Rainbond应用发布到应用市场功能说明",
	"content": " 应用分享 应用市场定义了支持大型分布式的数字化业务系统的标准云原生应用模型、它可以包含1-N个服务组件，模型包含其中每个服务组件资源及配置，插件资源及配置，拓扑关系、部署关系等。精心制作完成即可一键发布、一键安装。 在Rainbond中，服务是Rainbond可管理的最小服务单元，用户可以将多个服务组成一个复杂的业务系统，这套业务系统可以对外提供服务，也可以分享给其他组织独立部署，你可以将整套业务系统打包成一个云市应用，并选择将该应用发布到团队、公司、好雨公有云市。分享后的应用可供团队、公司或云市的用户一键安装部署完整的服务体系，实现标准化得一键交付部署。分享到不同的范围，可见性也有所不同，具体可见范围如下：\n 团队：只有当前团队下的成员可见 公司：当前企业下的所有成员可见 好雨云市：连接好雨公有云市的所有企业及用户可见  我们将一个应用内完整的业务解决方案集成体整体打包成一个云市应用，发布成功后，其他用户在创建应用时可以选择从应用市场安装的方式一键安装部署完整的服务体系，实现标准化得一键交付部署。\n需要注意的是，Rainbond内置应用市场跨数据中心应用安装和交付属于企业版功能，开源版本不支持。  应用发布流程 选择要分享的应用，点击发布到市场。\n 提示：发布应用时，应用内所有服务的状态必须为运行中\n 完善应用信息\n 填写应用基本信息\n  应用名：要发布的应用名称 版本：应用发布版本 ，当同一应用组多次发布时，如果版本号相同，则会覆盖已发布的该版本应用，如果版本不同，将发布为新的版本。 分享范围：发布的可见范围。 应用说明：应用的描述，便于使用者了解应用的作用。 图标：应用LOGO   填写每个服务的配置信息\n  环境变量：编辑该服务默认的环境变量，勾选可修改，则其他用户安装此应用后可编辑这个环境的值，反之不可编辑。 伸缩规则：定义该服务可伸缩的最大最小节点数，及节点伸缩步长，最小安装内存限制。 连接信息：通常连接信息中会出现密码类的信息，Rainbond提供了自动生成此类变量的值的功能可选。  提交发布任务\n完善应用信息后，点击提交，向数据中心发起同步任务。由数据中心的rbd-chaos组件对应用中的每一个服务进行数据同步。如果是发布到好雨公有云市，数据中心会将应用所需的镜像或源码包同步到好雨公有仓库及FTP服务器存储，并将应用的模版数据保存到Console数据库并发送到好雨云市保存。如果是发布到团队或公司，则应用所需的镜像或源码包同步到本数据中心，并将应用的模版数据保存在Console数据库。\n确认发布\n当应用中的所有服务及插件全部完成同步后，点击确认发布，即可完成应用发布。发布成功后可在创建应用下的从应用市场安装中对应的范围下看到你发布的应用。\n上架应用\n如果想要可以在公有云市中找到发布的应用，那么需要在云市中上架该应用。上架后的应用可以被连接好雨公有云市的所有企业及用户看到。\n 登录Goodrain官网,进入 企业中心 \u0026gt; 应用市场 \u0026gt; 自有市场 \u0026gt; 分享应用管理。 \u0026gt; 登录的时候需要用该企业管理员的Rainbond账号登陆。\n 信息编辑。使用Markdown编写应用的详细介绍，完善应用README，让用户可以更好地去了解使用应用。\n   设置价格。   上架。  完成上架之后，我们就可以在云端中找到你上架的应用。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-manage/upgrade_app/",
	"title": "应用升级",
	"tags": [],
	"description": "从应用市场安装的应用升级到新版本",
	"content": " 应用升级 应用升级功能是应用市场在易用性方面的一次全面提升, 通过简单的操作即可把从应用市场安装的应用, 从旧版本升级到新版本.\n升级的对象是什么\n在应用管理菜单下, 有多个我们创建的应用, 我们把它这些应用叫做应用组, 每组应用有多个服务.\n我们在往应用组中添加组件时, 可以直接从应用市场安装一个打包好的云市应用, 每个应用组可以安装多个云市应用, 所以应用组下的这些服务是来自不同的云市应用.\n我们查找了这些服务的安装来源, 找出了这个组安装好的所有云市应用, 针对每个云市应用做升级操作.\n什么时候可以升级\n当云市应用中的服务有变化 (例如：端口、环境变量、存储等) 或 新版本增加了新的服务组件时, 我们会在云市应用升级按钮的左侧, 给您用绿点提示.\n应用升级流程 选择要升级的应用，点击云市场应用升级。\n查看来自应用市场的应用\n 选择有新版本的应用进行升级\n 查看升级信息\n 如果有多个可升级版本, 可按需选择期望升级到的版本.\n当然也可根据意愿, 按需选择期望升级的服务.\n 升级信息主要包括, 每个服务的变更信息, 以及新增服务的信息.\n在上图中 🔼 标志代表服务是可升级的, ➕标志代表服务是新增的. 没有标志代表该服务没有变化, 无需升级.\n点击升级\n升级时, 我们对升级之前的服务状态做一个备份, 升级完成之后提供回滚功能\n升级完成\n 现在升级已经完成了, 让我们看看升级前后的对比\n 回滚\n 当然有升级就有回滚\n不过有点小小的限制:\n 为了保证回滚的可靠性, 现在只允许对最后一次的升级操作进行回滚 新增的服务是不能通过回滚删除的   查看升级记录\n查看升级记录详情\n 这里记录了之前升级\n  我们可以从这里回滚升级(只能是最后一次升级哦)\n当然, 回滚哪些服务也是可以按照意愿去选择.\n ~~时光倒流\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-manage/app-backup/",
	"title": "应用备份管理",
	"tags": [],
	"description": "Rainbond应用全量备份、迁移和恢复",
	"content": " 应用备份、恢复与迁移 Rainbond目前提供应用级的全量备份功能，主要用于两类场景：\n 应用整体的版本备份，包含代码和运行环境，持久化数据，服务\u0026amp;应用配置等所有属性。有了备份，应用即可随时恢复到备份版本。 应用迁移，将应用完整迁移到其他团队或其他数据中心。  Rainbond备份功能目前的设计是全量的冷备份机制，传统意义上我们对服务的备份主要是对持久化数据的备份，比如Mysql数据库的数据。在微服务架构的状态下，如果只是备份某一个服务的数据，应用内包含多个服务时很难在出现故障的情况下同步恢复到历史状态。我们对于应用管理的追求必须要做到应用级的完整备份。在容器化的情况下，对于代码和运行环境的备份是容易的，我们可以方便的做到对所有服务的运行环境热备份。但是对于持久化数据，特别是有状态服务的持久化数据，我们不能保证在工作状态下将数据能够安全备份。因此Rainbond目前要求备份应用时需要停止有状态服务。\n后续的版本中我们将以operator的方式支持有状态服务的数据热备份，然后接入应用整体备份流程中。即可实现对应用的完整热备份和定期备份。\n应用备份 从应用的操作列表中即可进入应用备份管理页面，备份操作分为本地备份和云端备份两种。\n 本地备份：将一组应用备份在本地，本地备份的应用无法进行跨数据中心和租户的迁移操作。 云端备份：Rainbond企业版本支持，将备份数据存储于云端。  只需要添加备份，选择备份模式即可，备份是一个异步的过程，且根据服务的数量的不同耗时不同。如果应用下存在运行中的有状态服务，将拒绝备份操作。\n在5.0以后的版本中新添加全部备份页面，进入后会展示出当前团队数据中心下的所有备份记录，以便清晰查看，同时也解决了之前版本应用有备份记录无法删除的问题。\n备份恢复 恢复对于已经备份成功的一组应用，使用恢复可以将该组应用进行恢复操作。恢复通常是在当前应用出现不可解决的问题。 恢复操作如下：  恢复操作过程中请勿关闭恢复页面，否则可能会导致恢复失败。为了保证您的数据安全，恢复操作过程我们会生成一份您的备份应用的拷贝，您可以在恢复的最后一步中选择删除原有的应用。\n  导出备份 导出备份会将会导出一份备份的数据，目前只有云端备份支持备份的导出。\n 导入备份 在导出备份以后，您可以在别的云帮平台（可以访问网络）将导出的备份进行导入，导入后会生成相应的备份记录，您可继续后续操作。\n  本地恢复后的注意事项 应用恢复后网关访问策略需要用户手工配置。\n应用的跨租户和跨数据中心迁移 由于我们做到全局的全量备份，借助此我们可以做到应用的整体迁移，包括跨租户迁移和跨数据中心迁移。\n在已经备份的情况下，可以选择迁移操作来进行应用的迁移 迁移操作如下：\n应用完成迁移以后，会跳转到对应的数据中心和租户以方便您查看迁移后的应用。\nRainbond开源版只能进行当前数据中心下的跨团队迁移，企业版支持跨数据中心迁移。  "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/app-manage/app-topology/",
	"title": "应用拓扑图",
	"tags": [],
	"description": "展现应用包含的所有服务的网络关系、业务关系和业务逻辑",
	"content": " 展示模式 拓扑图以图形化的方式展示应用的所有服务组件实时状态，它将展示如下几个维度的信息：\n 服务网络拓扑关系  图中可以清楚的展示服务直接的网络调用关系以及公网开放情况，结合流量状态可以便捷发现通信状态。\n 服务整体业务依赖关系  图中服务之间的连线表示服务业务依赖关系，让用户可以一看便知复杂业务系统的业务关系。\n 服务流量跟踪状态  拓扑图中的每条线在开通了性能分析插件后将实时呈现每条通信链路的吞吐率和响应时间，未来还会将错误率和分布式跟踪情况展现在链路中\n 服务运行状态  服务以颜色展示服务状态，对应关系如下：\n   颜色 未构建/未启动     黑色/灰色 未构建/未启动   绿色 运行中   浅绿色 升级中   红色 已关闭     如果服务六方体呈现为叠加状，表明当前服务运行了多个实例。\n 编辑模式 编辑拓扑图目前支持:服务组件连接建立或取消依赖关系、打开或关闭服务组件对外端口，\u0008方便快捷；\n 删除动作  点击连接线按下delete键快速删除组件依赖关系、关闭服务组件所有对外端口，\u0008方便快捷；\n 增加动作  点击起点焦点拖拽到终点即可建立两个服务间的依赖关系或打开外网访问。\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/gray-released-app/",
	"title": "应用灰度发布实践方案",
	"tags": [],
	"description": "Rainbond应用灰度发布操作方案详解",
	"content": " 功能说明 灰度发布主要是按照一定策略选取部分用户，让他们先行体验新版本的应用，通过收集这部分用户对新版本应用的反馈，以及对新版本功能、性能、稳定性等指标进行评论，进而决定继续放大新版本投放范围直至全量升级或回滚至老版本。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。\n灰度发布策略可以平滑、可控的调整新旧版本的流量负载情况。\n灰度发布实践  基于A/B测试的实践  A/B测试策略本身就是灰度发布的一种实践，在继续下文之前，请务必阅读并掌握 A/B测试实践\n 基于权重的灰度发布实践  在A/B测试用例中我们主要强调通过客户端标识明确的标识客户请求来精确控制。当然不是所有场景都需要这样的精确控制，或者我们只需要从流量的维度进行控制，比如开始先 10%流量切换到新版本，后续逐步增加这个权重，在正常的情况下直到旧版权重较少到 0。 内部服务和外部服务都支持基于权重的路由控制。\n 外部服务  依然通过 应用网关 -\u0026gt; 访问策略 添加以下两个HTTP访问策略：\n   域名 权重 服务     www.test.com 90 外部服务   www.test.com 10 外部服务2    根据需要逐步分别降低和升高权重即可。\n 内部服务  同样通过网络治理插件设置以下参数，权重是在 PREFIX DOMAINS HEADERS 完全一致的情况下生效。\n PREFIX：URL前缀path配置，例如/api DOMAINS：内网请求域名配置，基于配置的域名转发至下游应用，仅支持一级域名 WEIGHT：转发权重设置，范围1~100。规定相同的DOMAINS与PREFIX组合情况下，权重总和为100。数值越大，权重越高。 HEADERS：HTTP请求头设置，多个参数以;分隔，您可以根据请求头中的参数不同来决定去请求哪个下游应用 LIMITS：TCP限速，设值值为0则熔断  存在的缺陷和改进计划 主要缺陷和计划与A/B测试文档描述的一致。\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/gateway/gateway/",
	"title": "应用网关说明",
	"tags": [],
	"description": "Rainbond默认提供的应用网关功能说明文档",
	"content": " 这篇文章将会介绍如何在 什么是应用网关, 以及应用网关的作用.\n应用网关定义 在百度百科中, 网关的定义是这样子的: 网关(Gateway)就是一个网络连接到另一个网络的\u0026rdquo;关口\u0026rdquo;. 类似的, 应用网关是 Rainbond 中的一个组件(rbd-gateway), 它是外部流量\u0008流入应用的\u0026quot;关口\u0026quot;. 也可以说是南北向流量中, 北向流量流向南向流量的一个\u0026rdquo;关口\u0026rdquo;.\n应用网关的作用 在介绍应用网关的作用前, 首先\u0008需要提一下 Ingress. Kubernetes 官方对 Ingress 的介绍是: 在Kubernetes v1.1 中添加的 Ingress, 暴露了从集群外部到集群内服务的 HTTP 和 HTTPs 路由. 流量路由 Ingress 定义的策略控制.\n 注意, Ingress 只是定义了从集群外部到集群内服务的路由策略, 并没有\u0008实现这些策略. \u0008\n 应用网关的作用就是实现 Ingress 中定义的各种策略. 除了 HTTP 和 HTTPs 路由外, 应用网关还提供了其他丰富的功能. 目前支持的功能有:\n HTTP 和 HTTPs 策略 TCP/UDP 策略 泛域名策略 多种负载均衡算法 高级路由: 根据访问路径, 请求头, Cookie, 权重的访问控制 服务与域名访问情况监控  HTTP 和 HTTPs 策略 HTTP（HTTPs）策略是当前IT领域中最重要的服务访问策略，目前Rainbond对HTTP访问策略的支持如下：\n 路由规则 Rainbond对Http协议的路由规范进行标准化支持，Http路由规范主要以域名、Path、Header、Cookie为判断条件，Rainbond只支持对服务进行路由选择，不支持对服务的多个实例进行路由选择。需要对多实例进行负载控制时采用不同的负载均衡算法，比如一致性Hash负载均衡等。  基于路由规则可以有多种业务场景，例如：\n 灰度发布场景  例如： www.example.com 20% 流量路由到服务A1-80端口\n​ www.example.com 80% 流量路由到服务A2-80端口\n 多服务聚合场景  例如 www.example.com/path1 流量路由到服务B-80端口\n​ www.example.com/path2 流量路由到服务C-8080端口\n 高级参数 \n 策略动态生效\n  策略配置的所有属性保存后自动在应用网关生效。\nTCP/UDP 策略 在配置 TCP/UDP 策略的时候, 目前只支持端口的自定义, 自定义的端口默认绑定到网关所在服务器的所有绑定IP地址上。\n企业版本中我们支持虚拟IP管理，即TCP策略可以通过绑定虚拟IP实现多个IP可用。\n泛域名策略 泛域名在实际使用中作用是非常广泛的, 为此, 应用网关也对泛域名进行了支持. 泛域名有不少的作用:\n 可以让域名支持无限的子域名(这也是泛域名解析最大的用途) 防止用户错误输入导致的应用不能访问的问题 可以让直接输入网址的用户输入简洁的网址即可访问应用 在域名前添加任何子域名，均会被解析到同一个 IP  负载均衡 为了保证应用的高可用, 以及提高应用的性能, 我们一般会为应用部署多个实例. 这时候, 就必须要考虑负载均衡了. 应用网关目前默认的负载均衡算法是轮询, 也是\u0008目前支持的唯一一种负载均衡算法 . 当然, 在下个版本中将会支持更多的负载均衡算法.\n 轮询(Round Robin): 为第一个请求选择列表中的第一个服务器, 然后按顺序向下移动列表直到结尾, 然后循环.\n 高级路由(A/B 测试, 灰度发布) 只有 HTTP 或 HTTPs 策略才支持高级路由, TCP/UDP 策略不\u0008支持高级路由. 在应用网关中的高级路由是指, 通过\u0008设置策略中的path, cookie, header 和 权重, 让同一个域名可以访问不同的应用.\n高级路由主要是为 A/B 测试(A/B testing) 和 灰度\u0008\u0008发布(金丝雀部署, canary deployments) 服务.\nA/B 测试 A/B 测试的本质是一个实验, 它\u0008将应用的两个或多个版本(变体)随机地显示给用户, 通过统计\u0008分析确认能够在给定指标中胜出的版本(变体).\n我们可以在应用网关中, 为各个版本的应用\u0008配置域名相同, 但是cookie, header 或 权重不同的\u0008策略, 让用户通过同一个\u0008域名访问不同版本的应用. 然后对数据进行统计分析, \u0008找出在给定指标下的\u0008胜者, 从而实现 A/B 测试.\n灰度发布 灰度发布是将版本部署到服务器子集的模式. 首先将版本部署到一小部分服务器，对其进行测试，然后将版本扩散到其余服务器灰度发布可作为预警指示，对停机时间影响较小：如果灰度发布失败了，其余服务器不会受到影响.\n为了\u0008实现灰度发布所要的效果, 我们只需为灰度发布的服务器分配较小的权重, \u0008然后再慢慢地扩散, 增加权重.\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/app-create/gitlab/",
	"title": "快速部署Gitlab源码管理服务",
	"tags": [],
	"description": "基于Rainbond快速部署生产可用的源代码管理服务",
	"content": " Gitlab简介 GitLab是利用 Ruby on Rails 一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。同时Gitlab集成了一系列的CI功能。不得不说，Gitlab在企业中是的使用率非常高。\nRainbond非常推荐用户使用Git代码仓库管理代码，从而获取更好的源代码管理和自动化CI体验。话不多说，接下来我们用10分钟的时间完成Gitlab服务在Rainbond的完整部署。\n准备工作  准备一个可用的域名（如果你可以准备），比如 git.example.com 准备域名对应的证书（如果你可以准备） Rainbond平台已安装完成，参考文档Rainbond快速安装 Rainbond平台处在能够连接互联网的环境下。  部署步骤 本教程我们将采用基于已制作完成的Docker镜像安装的方式部署Gitlab。部署完成后在Rainbond的运行效果如下：\n 我们在Rainbond部署一个开源的项目，基于Docker镜像的方式是最快，最简单的方式，特别是一些根据云原生的建议制作的镜像在Rainbond运行兼容性和体验都非常优越。\n 我们今天部署的Gitlab服务包括Postgresql组件、Redis组件和Gitlab-Server组件，它们的网络依赖关系如上图你看到一样，我们根据依赖关系从小到上依次部署。\n首先创建应用 GItlab然后从应用管理页面开始添加服务组件：\n我们采用基于DockerRun命令的方式创建服务，参考文档 基于镜像创建服务 ,\n此次部署的Gitlab镜像由社区提供，是目前使用最广的镜像。源码参考 docker-gitlab\n部署Postgresql组件 添加服务组件，基于以下DockerRun命令，Rainbond将从下面的命令中获取镜像名称和持久化存储目录。\ndocker run --name gitlab-postgresql -d \\ --volume /srv/docker/gitlab/postgresql:/var/lib/postgresql \\ sameersbn/postgresql:10  服务构建源识别完成后，通常的过程是直接创建并启动，但是我们这里还需要设置服务的运行类型为有状态服务，并且还需要设置一下连接信息。因此我们需要选择创建不启动。方式如下：\n强调一下，取消图中红色框框中的单选框，这一步非常重要  确认后页面直接跳转到服务管理页面，我们做以下几步设置：\n 更改端口别名，设置连接信息  进入服务端口管理页面，服务已默认添加了5432端口，更改端口协议为TCP, 打开端口的对内服务按钮，同时单击\u0026rdquo;使用别名\u0026rdquo;后方的端口别名信息，在弹出窗中设置端口别名为 \u0026ldquo;DB\u0026rdquo;。确认后将自动生成DB_HOST和DB_POST两个连接信息，在服务\u0026rdquo;依赖\u0026rdquo;页面可以查询连接信息, 同时我们继续添加以下连接信息：\n   变量名 值 说明     DB_EXTENSION pg_trgm    DB_NAME gitlabhq_production 数据库名称   DB_PASS password 密码，你自己可以随便定义值   DB_USER gitlab 连接数据库用户名    添加这些连接信息有两个作用：\n Postgresql将读取这些变量自动创建用户和数据库 Postgresql服务被Gitlab-Server依赖后将注入到Gitlab-Server环境中，Gitlab-Server将根据这些变量信息连接数据库。  更多信息参考文档 服务端口管理 服务连接信息管理\n 更改服务部署类型  由于Postgresql属于数据库类，我们需要将服务部署类型设置为有状态服务，进入服务\u0026rdquo;其他设置\u0026rdquo;页面，在\u0026rdquo;基础信息\u0026rdquo;信息中将服务的部署类型切换为有状态服务。\n 创建服务  设置完成，点击构建开始构建并启动服务，这时候我们可以开始下一个组件的部署了。\n部署Redis组件 部署Redis组件的过程与Postgresql一致，唯一的不同是不需要添加过多的连接信息。\n 基于下述DockerRun命令添加服务\ndocker run --name gitlab-redis -d \\ --volume /srv/docker/gitlab/redis:/var/lib/redis \\ sameersbn/redis:4.0.9-1  完成检查后设置创建不启动，进入服务管理页面\n 设置6379端口别名为REDIS,并开启端口对内服务。完成后在服务依赖页面可以查看到REDIS_HOST和REDIS_PORT两个连接信息变量，此变量将被注入到Gitlab服务中。\n 更改服务的部署类型为有状态服务。\n 创建服务，现在可以进入下一个环节了。\n  部署Gitlab-Server组件  使用下述的DockerRun命令创建组件，选择创建不启动。\ndocker run --name gitlab -d \\ --publish 10022:22 --publish 10080:80 \\ -e GITLAB_PORT=80 \\ -e GITLAB_HOST=git.example.com \\ -e GITLAB_SSH_PORT=10022 \\ -e GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alpha-numeric-string \\ -e GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alpha-numeric-string \\ -e GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alpha-numeric-string \\ --volume /srv/docker/gitlab/gitlab:/home/git/data \\ sameersbn/gitlab:11.8.2   这里需要说明的是其中的几个变量信息：\n   变量 值 说明     GITLAB_PORT 80    GITLAB_HOST git.example.com 之前准备的域名，如果没有准备后续设置Rainbond默认分配的域名即可（创建后可更改）   GITLAB_SSH_PORT 20222 Gitlab server 22端口开启外网访问后分配的端口（创建后可更改）   GITLAB_SSH_HOST 10.10.10.10 Gitlab server 22端口开启外网访问后的IP（创建后可更改）     创建服务后依赖上面建立的两个服务。直接进入拓扑图编辑模式，将Gitlab Server与redis和postgresql服务连线即可。参考文档 建立服务依赖 构建服务，等待服务启动完成。   注意，Gitlab服务第一次启动过程比较缓慢，等待服务启动完成。\n 配置网关访问策略 gitlab服务提供80端口的HTTP访问和22端口的SSH代码访问，分别为其添加访问策略。\n 80端口，配置HTTP访问策略，使用预先准备的域名比如(git.example.com)，这与GITLAB_HOST配置的必须一致。绑定域名对应的证书。\n 添加完成后进入访问策略列表，选择刚刚添加的策略，进入参数配置，将\u0026rdquo;上传限制\u0026rdquo;调整为10000 Mb,基本就是不限制了。\n  参考文档 [添加HTTP访问策略]()\n 为22端口添加TCP策略，生成的IP和端口需要与GITLAB_SSH_HOST GITLAB_SSH_PORT 两个变量一致。  到此，Gitlab服务部署完成，你可以直接访问服务了。第一次进入时将设置root账号的密码。\nFAQ  安装完成，访问返回Gitlab的502页面   这个时候Gitlab正在进行初始化和启动过程，内部的某些进程还未启动完成。这个时候只需要等待服务启动完成即可，第一次启动大概5-10分钟。\n  上述过程还是有点复杂，能不能直接一键部署。   那当然是可以的，我已将Gitlab服务分享到Rainbond公有应用市场，供给Rainbond用户一键安装，应用市场搜索\u0026rdquo;Gitlab代码仓库服务\u0026rdquo; 选择版本v11.8.2，同步后直接安装即可。需要注意的是，安装完成后需要根据你的网关访问策略重新配置Gitlab的GITLAB_HOST、GITLAB_SSH_HOST等信息。\n 暂无其他答疑，如你有疑问，请留言。\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/upgrade-stateless-app/",
	"title": "无影响滚动升级无状态应用",
	"tags": [],
	"description": "无影响滚动升级无状态应用",
	"content": " 无状态应用可以包含多个实例，其中所有实例都相同，但各实例之间相互独立，互不依赖，任意一个Web请求完全与其他请求隔离,用户不需要保存应用的状态或者持久化数据，访问时系统会自动为多实例的应用分发请求，所有实例共享存储卷。Rainbond针对无状态应用采用滚动升级策略。\n应用场景 应用部署运行时，如果应用不需要任何稳定的状态标示、有序的部署、更新升级、删除和扩展，建议使用无状态(Deployment)方式部署。大多数Web类和API类都可以选用无状态应用。平台创建应用默认是无状态应用。\n平台设置 源码构建还是镜像构建，配置流程一致，这里以镜像创建为例。\n创建应用时设置应用类型 应用检测通过后可以配置高级设置\n已创建应用修改应用类型 目前只能对已关闭应用进行应用类型修改。\n在应用的其他设置基础信息里可配置应用类型,修改应用类型会丢数据。\n滚动升级(RollingUpdate) Rainbond默认使用Deployment类型来部署Web类应用, 应用升级策略方面采用了滚动升级策略.所谓的滚动升级策略就是采用逐步替换的方式，使用新的实例逐步更新替换旧的实例.好处是不会中断服务，但会导致调用时出现应用版本不一致情况，输出内容不一致。\n滚动更新策略 # 默认RollingUpdateStrategy 25% max unavailable, 25% max surge  部署可以确保在更新时只有一定数量的实例可能会关闭。默认情况下，它确保至少比所需的实例数量少25％（25% max unavailable,）。 部署还可以确保在所需数量的实例之上只能创建一定数量的实例。默认情况下，它确保最多比所需数量的实例多25％（25% max surge）。 如果你的实例数为3,确保可用实例至少为2，并且保证实例数总数最多为4.\n操作 滚动升级在平台体现在两个方面的操作流程，一个是构建并启动过程，另外一个就是伸缩过程。\n如果仔细查看上面的部署，您将看到它首先创建了一个新的Pod，然后删除了一些旧的Pod并创建了新的Pod。在有足够数量的新Pod出现之前，它不会杀死旧的Pod，并且在足够数量的旧Pod被杀之前不会创建新的Pod。它确保可用Pod的数量至少为2，并且Pod的总数最多为4。 也可以通过命名行方式查看具体event事件，来确定滚动更新具体流程。\nName: eb02a36a5f8d0b349b2254461393369e-deployment Namespace: 34869bb254f6491e97d4993980a2cf85 Annotations: deployment.kubernetes.io/revision=4 Selector: name=gr93369e,service_id=eb02a36a5f8d0b349b2254461393369e,tenant_id=34869bb254f6491e97d4993980a2cf85 Replicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailable StrategyType: RollingUpdate MinReadySeconds: 0 RollingUpdateStrategy: 25% max unavailable, 25% max surge Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailable OldReplicaSets: \u0026lt;none\u0026gt; NewReplicaSet: eb02a36a5f8d0b349b2254461393369e-deployment-9fcdf797 (3/3 replicas created) Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 27m deployment-controller Scaled up replica set eb02a36a5f8d0b349b2254461393369e-deployment-84dc79c979 to 1 #第一次部署，新建实例数设置为1 Normal ScalingReplicaSet 25m deployment-controller Scaled up replica set eb02a36a5f8d0b349b2254461393369e-deployment-d5ff5fbd4 to 1 #构建操作，新建实例数设置为1 Normal ScalingReplicaSet 24m deployment-controller Scaled down replica set eb02a36a5f8d0b349b2254461393369e-deployment-84dc79c979 to 0 #构建操作，旧实例数设置为0 Normal ScalingReplicaSet 24m deployment-controller Scaled up replica set eb02a36a5f8d0b349b2254461393369e-deployment-66b58566c9 to 1 #伸缩操作，新建实例数设置为1 Normal ScalingReplicaSet 24m deployment-controller Scaled down replica set eb02a36a5f8d0b349b2254461393369e-deployment-d5ff5fbd4 to 0 #伸缩操作，旧实例数设置为0 Normal ScalingReplicaSet 30s deployment-controller Scaled up replica set eb02a36a5f8d0b349b2254461393369e-deployment-66b58566c9 to 3 #伸缩操作，新建实例数设置为3 Normal ScalingReplicaSet 22s deployment-controller Scaled up replica set eb02a36a5f8d0b349b2254461393369e-deployment-9fcdf797 to 1 #构建操作，新建实例数设置为1 Normal ScalingReplicaSet 20s deployment-controller Scaled down replica set eb02a36a5f8d0b349b2254461393369e-deployment-66b58566c9 to 2 #构建操作，旧实例数设置为2 Normal ScalingReplicaSet 20s deployment-controller Scaled up replica set eb02a36a5f8d0b349b2254461393369e-deployment-9fcdf797 to 2 #构建操作，新实例数设置为2 Normal ScalingReplicaSet 18s deployment-controller Scaled down replica set eb02a36a5f8d0b349b2254461393369e-deployment-66b58566c9 to 1 #构建操作，旧实例数设置为1 Normal ScalingReplicaSet 18s deployment-controller Scaled up replica set eb02a36a5f8d0b349b2254461393369e-deployment-9fcdf797 to 3 #构建操作，新实例数设置为3 Normal ScalingReplicaSet 16s deployment-controller Scaled down replica set eb02a36a5f8d0b349b2254461393369e-deployment-66b58566c9 to 0 #构建操作，旧实例数设置为0  无影响升级 无影响的前提，是已经多实例部署了。如果单实例部署，需要保证应用启动即服务。\n配置应用健康检查 Rainbond提供应用健康检查功能，用于查看应用和用户业务是否正常运行，设置健康检查可以在应用运行过程中，根据设置需要定时检查应用健康状态。如果不设置健康检测，我们默认应用和用户业务都是正常运行的;如果设置健康检测，我们会根据配置去探测应用或者业务是否正常运行，保证业务的可靠性。\n默认我们提供了两种健康检查方式：\n 应用启动时检查(应用实例存活检查): 探测应用实例是否已经启动，该检查方式用于检测实例是否存活或者服务是否启动，类似于执行ps检查进程是否存在。如果检查失败，会将应用状态设置为不健康;若检查成功不执行任何操作。 应用运行时检查(应用业务就绪检查): 探测应用业务是否已经就绪，该检查方式用于检测实例是否准备好开始处理用户请求或者运行过程中业务是否异常退出情况。如果检查失败，会重启该实例；若检查成功不执行任何操作。  具体如何配置健康检查请参考:应用健康检查\n微服务架构下分布式session共享 在某些场景下，单实例情况下多数将session存在到内存中,所有用户请求由单实例进行响应处理，达到保持用户状态的需求。随着微服务架构的普及发展,需要对原有单一实例的应用进行改造拆分，实现应用向云平台迁移。拆分每一个微应用都具有自己的Web页面，这些Web页面都会通过浏览器客户端展现给用户，整个微应用架构可以近似地看作是一个大型的分布式应用，所以每个微应用都需要有Session对象，同时整个微应用架构中，同一用户的Session数据应该是一致的。因此，在微服务架构下，对session的处理不再保存在内存中, 而是在架构中引入独立的中间存储介质如redis或memcache，将企业应用的session统一管理。\n针对这类场景, 可以参考: Tomcat基于Redis实现Session共享 \n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/config-file/",
	"title": "服务配置文件实践",
	"tags": [],
	"description": "Rainbond为服务添加配置文件的方法实践",
	"content": " 这篇文章将会介绍 Rainbond 中的配置文件, \u0008并且会以 mariadb 为例, 演示配置文件的使用.\n配置文件的介绍 Rainbond 结合了 Kubernetes 的 ConfigMap 实现的配置文件, 是一种特殊的存储类型, 此类型允许用户直接定义文件内容, 通常是指配置文件.\n配置文件有两大特性：动态渲染环境变量 和 配置文件共享.\n动态渲染环境变量 动态渲染配置文件解析环境变量的语法:\n${环境变量名} ${环境变量名:默认值}  如果服务中存在指定的环境变量, 那么 Rainbond 会\u0008将该环境变量的值解析到配置文件中; 如果服务中不存在该环境变量, 那么 Rainbond 会\u0008将默认\u0008值解析到配置文件中。\n如果指定的环境变量不存在, 且没有设置默认值, 那么 Rainbond 不会进行解析  配置文件共享 可以通过存储共享的机制来共享配置文件, 如果你有多个服务使用同一个配置文件的场景, 可以直接共享, 无需多次编辑设置.共享的配置文件只会解析当前服务的环境变量.\n配置文件在 Mariadb 中的应用 mariadb, Docker 的官方镜像, 给出了两种自定义 MySQL 配置文件的方法.\nMariadb 官方的配置方法 第一种方法是在宿主机创建一个配置文件, 并将这个配置文件挂载到容器的 /etc/mysql/conf.d 目录下\u0008. /etc/mysql/conf.d下的配置文件就会覆盖默认配置文件 /etc/mysql/my.cnf. 这种方法不\u0008够灵活, \u0008\u0008无法在\u0008创建服务时确认 Pod 会被调度在\u0008哪个节点上(数据中心通常是集群), 需要服务创建完成后才能挂载配置文件, 然后重启服务使\u0008其生效.\n第二种方法是在 docker run 命令中传入 mysqld 的\u0008参数, 比如, 通过 character-set-server 和 collation-server 两个参数修改l默认的编码和校对规则:\ndocker run --name some-mariadb -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mariadb:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci  这种方法同样不够灵活, 如果设置的参数\u0008\u0008非常多, 那么这个 docker run 命令将会非常的长.\nRainbond 的配置方法 第三种方法, 是 Rainbond 结合 k8s 的 ConfigMap \u0008实现的配置文件. 这种方法灵活性比较高, 可以 动态渲染环境变量, 还可以共享给\u0008其它服务使用.\n创建配置文件 创建 mariadb 时 在高级设置中添加一块类型是 配置文件 的存储. 如\u0008图所示:\n配置文件完整的内容如下:\n# MariaDB-specific config file. # Read by /etc/mysql/my.cnf [client] # Default is Latin1, if you need UTF-8 set this (also in server section) default-character-set = ${DEFAULT_CHARACTER_SET:utf8} [mysqld] # # * Character sets # # Default is Latin1, if you need UTF-8 set all this (also in client section) # character-set-server = ${CHARACTER_SET_SERVER:utf8} collation-server = ${COLLATION_SERVER:utf8_general_ci} character_set_server = ${CHARACTER_SET_SERVER:utf8} collation_server = ${COLLATION_SERVER:utf8_general_ci} default_storage_engine = ${DEFAULT_STORAGE_ENGINE:innodb} # Import all .cnf files from configuration directory !includedir /etc/mysql/mariadb.conf.d/  在这个配置文件中, 我们设置了 DEFAULT_CHARACTER_SET, CHARACTER_SET_SERVER, DEFAULT_STORAGE_ENGINE 等可以解析环境\u0008变量的变量, 并给它们设置了默认\u0008值.\n添加环境变量 为\u0008\u0008应用添加环境变量 DEFAULT_STORAGE_ENGINE=myisam 和 MYSQL_ROOT_PASSWORD=rainbond. 等 mariadb 创建成功后, 进入容器, \u0008检查 /etc/mysql/mariadb 的内容:\nroot@gr52b3ee-0:/# cat /etc/mysql/mariadb.cnf # MariaDB-specific config file. # Read by /etc/mysql/my.cnf [client] # Default is Latin1, if you need UTF-8 set this (also in server section) default-character-set = utf8 [mysqld] # # * Character sets # # Default is Latin1, if you need UTF-8 set all this (also in client section) # character-set-server = utf8 collation-server = utf8_general_ci character_set_server = utf8 collation_server = utf8_general_ci default_storage_engine = myisam # Import all .cnf files from configuration directory !includedir /etc/mysql/mariadb.conf.d/  可以看到, Rainbond 没有找到 DEFAULT_CHARACTER_SET, CHARACTER_SET_SERVER \u0008等没有\u0008对应环境变量的变量, 则使用它们对应的默认值进行了解析; 找到了 DEFAULT_STORAGE_ENGINE 对应的环境变量, 则使用环境变量 DEFAULT_STORAGE_ENGINE 的\u0008值 myisam 进行解析.\n我们再登录 MySQL, 看这些配置有没有生效:\n# 登录 MySQL root@gr52b3ee-0:/# mysql -uroot -prainbond # 检查编码和校对规则 MariaDB [(none)]\u0026gt; show variables like \u0026quot;%character%\u0026quot;; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ # 查看存储引擎 MariaDB [(none)]\u0026gt; SHOW STORAGE ENGINES; +--------------------+---------+----------------------------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------------------------+--------------+------+------------+ | MRG_MyISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | CSV | YES | Stores tables as CSV files | NO | NO | NO | | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | MyISAM | DEFAULT | Non-transactional engine with good performance and small data footprint | NO | NO | NO | | Aria | YES | Crash-safe tables with MyISAM heritage | NO | NO | NO | | InnoDB | YES | Supports transactions, row-level locking, foreign keys and encryption for tables | YES | YES | YES | | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | SEQUENCE | YES | Generated tables filled with sequential values | YES | NO | YES | +--------------------+---------+----------------------------------------------------------------------------------+--------------+------+------------+  可以看出, 编码, 校对规则, 存储引擎 的设置都已经生效.\n共享配置文件 接下来, 我们再创建一个 mariadb, 并挂载上面创建的 mariadb 的配置文件. 如图所示:\n创建完成后, 可以看到文件/etc/mysql/mariadb.cnf的片段如下:\ndefault_storage_engine = innodb  可以看到, 由于当前应用没有设置 DEFAULT_STORAGE_ENGINE 变量, 所以 Rainbond 使用它的默认\u0008值 innodb 进行解析.\n总结 这篇文章以 mariadb 为例, 演示了 Rainbond 配置文件的使用, 包括对环境变量的渲染和共享配置文件. 希望大家看完这篇文章后, 可以\u0008灵活地对应用进行配置.\n"
},
{
	"uri": "http://skyzhangyf.github.io/quick-start/release-cycle/",
	"title": "版本发布周期",
	"tags": [],
	"description": "Rainbond版本发布周期",
	"content": " 一、版本号规范 版本格式：A.B.C\n A : 表示大版本号，一般当软件整体重写，底层组件大版本升级（Docker，Kubernetes）或出现不向后兼容的改变时，增加A B : 表示功能更新，出现新功能时增加B C : 表示小修改，如修复bug，只要有修改就增加C  版本示例：3.6.1 表示，第3个大版本中的第6个功能更新版本，并且在这个功能更新版本中进行了一个版本的bug修复。\n二、版本更新周期    版本类型 更新周期 说明     A: 大版本号 6~12个月 版本重构，底层关键组件升级，向后不兼容   B: 功能更新版本 1~3个月 功能更新   C: Bug修复 1~2周 Bug或安全补丁    三、当前版本及说明    版本号 说明     3.4 历史版本，不再维护   3.5.2 历史版本，不再维护   3.6.1 历史版本，不再维护   3.7.2 历史版本，不再维护   5.0.X 当前生产主要版本   5.1.X 当前最新版本    "
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/user-registration-login/user-register/",
	"title": "用户、管理员注册",
	"tags": [],
	"description": "Rainbond 用户、管理员管理和注册文档说明",
	"content": " 功能描述 如果您第一次使用rainbond平台，\u0008首先得\u0008注册一个账户，以方便您访问rainbond应用控制平台。用户在Rainbond平台中只作为操作身份的标识，不具备给类资源所属权，Rainbond的服务、应用、网关策略、插件等资源只属于团队,用户只能从团队中获取操作权。 每一个用户可以加入多个团队，主动加入团队时需要团队管理员审核。\n平台管理员注册 Rainbond注册的第一个用户是（平台）企业管理员，拥有管理员所拥有的权限，能够对平台的一些基础功能进行设置管理，同时具备对团队的管理权，后续再注册的用户为普通用户。企业管理员用户可以查看当前企业下所有团队的资源信息。\n 企业版中企业管理员可以登录管理后台 企业版中可以通过管理后台添加更多的企业管理员用户。  普通用户注册 在开启用户注册功能的情况下，注册流程由用户完成，过程如下： - 点击 注册账户 - 填写用户名，邮箱，密码，验证码 - 点击 注册 - 选择其中一个团队加入，等待\u0008平台管理员审核 - 审核通过可进入平台\n 提示: 进入到某一个团队才能\u0008拥有团队所拥有的资源的操作权限\n  用户登录页面演示\n  用户注册页面演示\n  非管理员用户注册完成后必须加入到某个团队才能进入系统。\n  等待团队管理员审核通过\n 关闭注册功能 为了适应企业账号管理方式，管理员可以通过 企业管理 页面关闭用户注册功能，采用人工添加用户的方式。\n与第三方用户体系集成 Rainbond计划支持LDAP,Auth2.0等标准规范的第三方用户管理集成策略。\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/practices/thirdparty-service-practice2/",
	"title": "第三方服务实践-统一管理集群内服务访问集群外数据库",
	"tags": [],
	"description": "集群内服务访问无法或尚未迁移到 Rainbond 的集群外数据库或其他服务。",
	"content": " 如果在公有云(比如阿里云, AWS)上的分布式数据库, 无法迁移到 Rainbond 上; 或是其他尚未迁移到 Rainbond 的数据库, 那么你可以使用第三方服务将它们注册到 Rainbond 中, 从而使得集群内服务也可以访问它们。本文将演示如何把集群外的 MySQL 通过第三方服务注册到 Rainbond 集群中, 并为其定义共享环境变量，从而解决多个服务重复定义数据库连接信息变量的问题。\n 如果Rainbond安装在阿里云，请注意使用阿里云RDS云数据库时必须与Rainbond集群处于同一个区域。\n 前期准备  请确保你已经安装了 Rainbond V5.1 或更高的版本。\n 需要添加的服务, 本文使用的是 Rainbond 集群外的一个 MySQL。\n phpMyAdmin, 可以在应用云市中安装, 也可以通过镜像的方式创建.\n  你可以\u0008假设这个 MySQL 是非常复杂的, 比如它是一个分布式, 主从复制, 读写分享的 MySQL, 迁移的难度比较在; 那么你可以先不迁移这个 MySQL, 通过第三方服务将这个 MySQL 的实例添加到 Rainbond 集群中, 让它也可以使用 Rainbond 服务通信治理, 服务拓扑关系等功能.\n步骤 1: 填写第三方服务信息 登录 Rainbond 控制台, 进入 创建应用 -\u0026gt; 添加第三方服务.\n填写 服务名称, 应用名称, 服务注册方式(以 API 注册为例), 服务地址等信息.\n点击 创建服务, 并在检测通过后, 点击 创建.\n步骤 2: 添加实例地址 1. 获取添加实例的 API 地址和秘钥 添加实例的 API 地址和秘钥等信息在服务的总览 页面中, 如下图所示:\n2. 能过 Restful API 添加服务实例 在你的终端中, 结合 1 中的 API 和秘钥, 输入类似以下的 curl 命令, 发起 PUT 请求, 将实例192.168.1.107添加到服务中.\ncurl -X PUT \\ --url http://192.168.1.200:7070/console/third_party/bb9371b3a3288e5abb329d780d85507b \\ -H \u0026quot;Content-Type: application/json\u0026quot; \\ -d '{\u0026quot;secret_key\u0026quot;:\u0026quot;jErDmpot\u0026quot;,\u0026quot;ip\u0026quot;:\u0026quot;192.168.1.107\u0026quot;,\u0026quot;is_online\u0026quot;:true}' {\u0026quot;msg\u0026quot;:\u0026quot;success\u0026quot;,\u0026quot;code\u0026quot;:200,\u0026quot;data\u0026quot;:{\u0026quot;bean\u0026quot;:{},\u0026quot;list\u0026quot;:[]},\u0026quot;msg_show\u0026quot;:\u0026quot;修改成功\u0026quot;}  详细的 API 注册请参考: 基于API注册的第三方服务\n步骤 3: 添加端口 创建完成后, 会进入到服务的管理页面. 在导航中选择 端口.\n点击添加端口, 输入端口为 3306, 选择 mysql 协议.\n添加完成后, 打开对内服务, 开启服务的服务通信治理功能.\n这里需要注意的是, 内部的服务可以添加多个端口, 而第三方服务只能添加一个端口.  步骤 4: 定义和分享连接信息 在导航中选择 连接信息, 然后定义 MySQL 的连接信息(连接信息实际上是服务的环境变量). 如图所示:\n这样, 当其他服务依赖了这个 MySQL 后, 就可以直接使用它的连接信息. 也就是说, 定义后的连接信息, 是可以分享出去的.\n步骤 5: 确认服务 打开对内服务后, 该服务就可以使用 Rainbond 的服务通信治理功能.\n使准备好的 phpMyAdmin, 与依赖第三方服务建立依赖; 然后更新或启动 phpMyAdmin.\n在 phpMyAdmin 的 Dashboard 中, 点击访问, 对其进行访问, 并输入 MySQL 的账号密码.\n你应该会在浏览器中看到类似下面的网页:\n这表明, 你已经成功地将集群外的服务(MySQL), 通过第三方服务添加到了集群中.\n进入 phpMyAdmin 的实例容器, 查看环境变量, 你应该可以看到步骤 4 中定义的 MySQL 连接信息:\n# env | grep MYSQL MYSQL_PASS=rainbond MYSQL_HOST=127.0.0.1 MYSQL_USER=root MYSQL_PORT=3306  这表明, MySQL 的连接信息已经成功地被分享给 phpMyAdmin 了. 在这个例子中, phpMyAdmin 没有使用这些连接信息, 你实际的使用过程中, 你可以根据实际的情况对这些连接信息进行利用.\n总结 至此, 相信你已经了解了如何将 Rainbond 集群外的服务注册到集群中, 并为定义和分享其环境变量. 第三方服务注册到集群后, 可以像内部服务一样, 使用通信治理, 服务拓扑关系等功能.\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/practices/thirdparty-service-practice1/",
	"title": "第三方服务实践-通过Rainbond应用网关访问企业内网应用",
	"tags": [],
	"description": "使用Rainbond第三方服务管理, 让应用网关访问企业内网的其他服务",
	"content": " 企业基于Rainbond建设自己的私有云，管理企业所有的应用的过程中，会遇到这样一个问题，有一些应用需要被公网访问，但是由于各种原因，应用尚未迁移到 Rainbond 中。但是 公司只有一个公网 IP。用户为了能够使Rainbond集群内外的应用可以同时对外网提供服务，不得不单独部署一个nginx服务来作为最外层的应用负载。这样带来的问题就是没办法直接方便的使用Rainbond网关，每开放一个应用都需要手动配置nginx的规则，如果不了解Rainbond网关的工作原理，这个过程将更加复杂。\n为了解决这个问题，结合其他方面的需求，Rainbond第三方服务管理集成功能应运而生。参考第三方服务定义\n本文将会实践如何使用第三方服务, 让未迁移到Rainbond集群的应用也能够直接动态注册到Rainbond网关，从而实现基于Rainbond网关来管理企业所有的对外提供服务的应用。\n前期准备  请确保你已经安装了 Rainbond V5.1 或更高的版本。\n 企业内网的\u0008其他服务, 本文使用一个Nginx应用来说明。\n  步骤 1: 填写第三方服务信息 登录 Rainbond 控制台, 进入 创建应用 -\u0026gt; 添加第三方服务.\n填写 服务名称, 应用名称, 服务注册方式(以静态注册为例), 服务地址等信息.\n点击 创建服务, 并在检测通过后, 点击 创建.\n步骤 2: 添加端口 创建完成后, 会进入到服务的管理页面. 在导航中选择 端口.\n点击添加端口, 输入端口为 80, 选择 http 协议.\n添加完成后, 打开对外服务, 让应用网关代理该服务.\n这里需要注意的是, 内部的服务可以添加多个端口, 而第三方服务只能添加一个端口.  步骤 3: 确认服务 打开对外服务后, 你会得到一个类似http://80.grf53077.ex05o2yt.2cbcac.grapps.cn/的域名, 这是 Rainbond 为该服务会分配一个默认的域名, 最关键的是这时候你可以在网关中为该服务自定义域名和设置需要的访问策略参数。\n参考文档 网关访问策略管理\n如果需要设置Https证书，参考文档 证书管理\n在浏览器中输入平台分配的默认域名, 以查看服务是否正在运行.\n你应该会在浏览器中看到类似下面的网页:\n此时, 你已经将 Nginx(192.168.1.123:80) 作为第三方服务添加到了 Rainbond 上, 并使用网关成功地代理了 Nginx 默认页面.\n步骤 4: 总览页面 在导航中选择 总览, 你可以看到服务的实例的信息, 包括实例的数量, 地址, 健康状态和是否上线等.\n除了可以查看服务的实例的信息外, 你还可以在总览页面中对实例进行新增, 删除, 上线和下线等操作.\n1. 新增 点击新增, 输入实例地址192.168.1.200.\n新增实例时, 默认会将该实例上线.\n如下图所示:\n实例地址不能是 127.0.0.1  2. 下线 接下来, 将刚才新增的实例192.168.1.200下线. 选中实例192.168.1.200, 点击\u001d下线.\n然后, 你可以看到下线后的实例192.168.1.200, 会没有健康状态(显示为\u0026rsquo;-\u0026lsquo;). 如图所示:\n总结 至此, 你应该了解了 Rainbond V5.1 的新特性 第三方服务 的基础使用. 并了解了通过网关访问集群内的\u0008其他服务.\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/gateway/traffic-control/",
	"title": "访问控制",
	"tags": [],
	"description": "Rainbond应用网关访问策略管理，这是网关最关键的配置。",
	"content": " 这篇文章将会介绍如何在配置应用网关中的规则, 从而\u0008对应用的访问进行控制.\n在这篇文章中, 你将会完成:\n添加 HTTP 策略 添加 HTTP 强转 HTTPs 策略 添加 TCP 策略 添加 泛域名 策略 添加 A/B 测试, 灰度发布策略 参数配置\n前期准备 请确保你能够满足以下条件:\n 一个状态健康的 Rainbond. 一个或多个运行中的服务 一个可用, 并且已经解析到应用网关所在机器上的域名(\u0008机器的 IP 可以在\u0008添加策略的面板上找到)  添加 HTTP 策略  准备一个服务，参考服务创建文档 点击 应用网关 -\u0026gt; 访问控制 -\u0026gt; 添加策略 填写路由条件等信息 点击 确认   配置完成后, 就\u0008可以通过域名(www.test.com)对应用(Nginx)进行访问了.\nHTTPs 策略, HTTP 强转 HTTPs 策略  准备一个服务，参考服务创建文档 点击 应用网关 -\u0026gt; 访问控制 -\u0026gt; 添加策略 填写 域名, 绑定证书, 应用(组), 服务组件, 端口号, HTTP Rewrite HTTPs 等信息 点击 确认   如果没有勾选 HTTP Rewrite HTTPs, 那么将会是单纯的HTTPs\n 配置完成后, 用 http://www.test.com 进行访问, 将被强制转成 https://www.test.com.\nTCP 访问策略  准备一个服务，参考服务创建文档 点击 应用网关 -\u0026gt; 访问控制 -\u0026gt; TCP/UDP -\u0026gt; 添加策略 填写 IP, 端口, 应用(组), 服务组件, 端口号, 负载均衡 点击 确认   TCP 策略会有一个\u0008系统自动分配的端口, 你也可以指定端口, 但是要注意端口冲突的问题.\n 配置完成后, 就可以通过 IP+Port(47.92.168.60:20128)访问应用了.\n泛域名  准备一个服务，参考服务创建文档 点击 应用网关 -\u0026gt; 访问控制 -\u0026gt; 添加策略 填写 泛域名, 应用(组), 服务组件, 端口 点击 确认  配置完成后, 任何一个解析到47.92.168.60的 test.com 的子域名都会\u0008访问同一个应用(Nginx).\n高级路由(A/B 测试, 灰度发布) 在高级路由中, \u0008我们可以对不同的服务绑定同\u0008一个\u0008域名, 通过\u0008\u0008设置不同的 请求路径, Cookie, Header, \u0008将流量路由到相应的服务上. 另外, 我们还可以通过\u0008设置权重, 将流量按权重分配到不同的服务上. 以上的\u0008功能, 可以帮助我们轻松地\u0008实现 A/B 测试, 灰度发布.\nCookie 在 HTTP 策略中添加两个Cookie信息, branch=v5.0和version=beta, 如下图所示:\n设置了Cookie后, 单纯的通过域名已经无法访问应用了:\n172:~ abe$ curl test.goodrain.com \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;502 Bad Gateway\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; ...  在访问的时候需要带上Cookie信息才能正常地对应用进行访问:\u0008\n172:~ abe$ curl --cookie \u0026quot;branch=v5.0;version=beta\u0026quot; test.goodrain.com \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ...  Header 在 HTTP 策略中添加两个请求头信息, branch=v5.0 和 version=beta, 如下图所示:\n设置了请求头后, 单纯的通过域名已经无法访问应用了:\n172:~ abe$ curl test.goodrain.com \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;502 Bad Gateway\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; ...  在访问的时候需要带上请求头信息才能正常地对应用进行访问:\u0008\n172:~ abe$ curl -H \u0026quot;branch:v5.0\u0026quot; -H \u0026quot;version:beta\u0026quot; test.goodrain.com \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ...  权重 首先, 准备两个应用, 2048和Nginx:\n然后, 给这两个应用, 分别添加一条 除了权重, 其他信息都一样的策略. 2048的权重设置为75, Nginx的权重设置为25.\n最后, 通过他们的域名test.goodrain.com访问; 可以发现, 有75%的概率访问的是2048, 25%的概率访问的是Nginx. 通过以上对 Cookie, Header, 权重的配置, 就可以灵活地配置 A/B 测试 和 灰度发布.\n参数配置 网关目前支持的参数有以下几个:\n连接超时时间 定义与上游服务器(upstream)建立连接的超时时间. 单位是秒, 默认: 75.\n请求超时时间 设置将请求传输到上游服务器(upstream)的超时时间. 单位是秒, 默认: 60. 仅在两次连续写入操作之间设置超时时间, 而不是为整个请求的传输. 如果上游服务器服务器在此时间内未收到任何内容，则关闭连接.\n响应超时时间 定义从上游服务器(upstream)读取响应的超时时间. 单位是秒, 默认: 60. 仅在两个连续的读操作之间设置超时, 而不是为整个响应的传输. 如果上游服务器在此时间内未传输任何内容, 则关闭连接.\n上传限制 设置上传内容(或请求正文)的最大限制, 将大小设置为0将不作限制. 单位是 Mb, 默认: 1.\n自定义请求头 设置了自定义请求头后, 每个发往上游服务器(upstream)的请求都会带上这些请求头.\n后端响应缓冲区 对应 Nginx 的 proxy_buffering 参数, 默认关闭. 如果关闭了后端响应缓冲区，那么 Nginx 会立即把从后端收到的响应内容传送给客户端;. 如果开启了后端响应缓冲区, 那么 Nignx 会把后端返回的内容先放到缓冲区当中，然后再返回给客户端; 并且这个过程是边收边传，不是全部接收完再传给客户端.\nWebsoket 在网关支持的 WebSocket 与单纯的 WebSocket 不同, 是在 HTTP 的基础上, 使用 HTTP Upgrade 机制将连接从 HTTP 升级到 WebSocket. 这个 HTTP Upgrade 机制是在请求中添加两个自定义请求头, 分别是 \u0026lsquo;Upgrade $http_upgrade\u0026rsquo; 和 \u0026lsquo;Connection \u0026ldquo;Upgrade\u0026rdquo;\u0026rsquo;, 当勾选了 Websoket, 网关会自动为当前的策加上这两个请求头. 更多的信息可以参考: NGINX as a WebSocket Proxy\n"
},
{
	"uri": "http://skyzhangyf.github.io/user-manual/gateway/cert-management/",
	"title": "证书管理",
	"tags": [],
	"description": "Rainbond网关管理之Https证书管理文档",
	"content": " 证书管理\u0008的作用是管理 HTTPs 所需的证书. 包括 添加证书, 编辑证书和删除证书.\n添加证书 证书管理 正确的证书添加后Rainbond会自动识别签发的域名和过期时间，以确保用户绑定域名时选择正确的域名证书。过期时间可以让用户便捷的发现证书的有效期，及时更新证书。\n"
},
{
	"uri": "http://skyzhangyf.github.io/contribution/",
	"title": "贡献",
	"tags": [],
	"description": "",
	"content": " Rainbond项目的终极目标是建设成为\u0026rdquo;企业应用操作系统\u0026rdquo;,因此参与Rainbond项目除了可以参与项目本身以外，同时也可以贡献Rainbond应用生态。\n参与Rainbond项目  了解Rainbond设计思想和技术架构 了解Rainbond涉及的开源项目  Rainbond Rainbond数据中心组件仓库 Rainbond-Console Rainbond控制台业务层 Rainbond-Console-UI Rainbond控制台UI组件 Rainbond-Install Rainbond安装工具 Rainbond-Builder Rainbond源码构建工具集 Rainbond-Docs Rainbond文档  加入Rainbond社区 社区 参与定期举行的开发者讨论 提交的PR，积累一定数量的PR后加入到开发者兴趣小组  贡献Rainbond应用 如果你是Rainbond的使用用户，你一定体验到了Rainbond应用市场带来的便利，我们非常欢迎你将你创造的有用的、有趣的应用或解决方案发布到社区。 贡献应用参考文档\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/devops/application-delivery/",
	"title": "通过应用市场做应用交付与升级",
	"tags": [],
	"description": "基于Rainbond做应用交付与升级",
	"content": " 概述 在企业选定Rainbond作为生产交付平台后，如何将开发好的应用交付到最终用户的生产环境中去，就变成了一个非常重要的课题。本文通过实际的测试流程，讲解了如何通过Rainbond应用市场做应用的交付，以及在原始应用有升级后，如何将升级内容同步到其他已经通过原始版本的应用市场部署的应用。\n基于Rainbond应用市场交付的流程 事先准备 完成这个操作需要两套Rainbond环境。一套作为应用的发布平台，用于应用的发布与升级；另一套作为部署平台，我们将会通过离线导出/导入市场应用的方式，实现应用的交付与升级操作。\n本文在写作的时候搭建了两套Rainbond v3.7.2 作为测试环境，来演示与验证通过应用市场做应用交付与升级。\n应用的发布与导出 本次测试挑选了一个基于Maven构建的 spring boot 项目。搭配了 mysql 组成了一个完整的应用。接下来，将其发布为一个应用市场的应用,并将其导出为包。这里提供本次导出的测试应用包，以供用户进行测试。\n应用包的导入 接下来，我们会在一个新的环境导入刚刚导出的应用包。此过程对应了离线环境下，基于Rainbond应用市场的交付场景。\n导入完成后，即可以使用从应用市场构建，来将导入的包构建为应用。基于Rainbond应用市场的应用交付就完成了。\n应用市场升级操作 应用的重新发布 对于已发布到应用市场的应用，该如何才能升级呢？这涉及到同一个应用的重复发布。在这里指出很重要的一点：\n 将应用发布到应用市场后，不要将原始应用删除。未来的升级将以原始应用为基础，进行调整。在调整完成后，重新发布到应用市场，即可完成应用市场中应用的升级。\n 接下来，依然以spring boot为基础，完整的实现一次升级操作。在开始之前，通过未升级的应用市场部署一个应用 app_delivery作为测试用例；并为应用的源码仓库添加了一个标示文件 new_file_for_test 模拟应用源码发生变更。\n重新构建来升级原始应用\n重新发布来升级应用市场中的应用\n 需要注意的是，重新发布同一个应用的时候，版本 应与原应用保持一致，方视为对原应用的升级；否则，会发布出一个新的应用。\n 同Rainbond下应用市场部署应用的升级 对于使用了应用市场中应用的首个版本部署的应用 app_delivery 。在重新发布应用后，就可以进行升级操作了。Rainbond会自动检测应用市场应用的版本，并体现 应用升级按钮。\n不同Rainbond下应用市场应用的升级 对于已交付的其他Rainbond环境，我们在升级了应用后，如何在交付环境中升级呢？我们需要将应用重新导出，再导入到交付环境中去。导出的方式以及介绍过了，这里提供本次导出的测试应用升级包，以供用户进行测试。\n成功将应用市场应用升级后，就可以对已通过原始版本的应用进行升级操作了。\n"
},
{
	"uri": "http://skyzhangyf.github.io/advanced-scenarios/app-create/create-middleware-cluster/",
	"title": "部署Mysql主从集群应用",
	"tags": [],
	"description": "基于Rainbond部署Mysql主从集群应用",
	"content": "  Mysql主从同步原理 1）在Slave 服务器上执行sart slave命令开启主从复制开关，开始进行主从复制。\n2）此时，Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接master服务器，并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从复制服务时执行change master命令指定的）之后开始发送binlog日志内容。\n3）Master服务器接收到来自Slave服务器的IO线程的请求后，其上负责复制的IO线程会根据Slave服务器的IO线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回给Slave端的IO线程。返回的信息中除了binlog日志内容外，还有在Master服务器端记录的IO线程。返回的信息中除了binlog中的下一个指定更新位置。\n4）当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到Slave端自身的Relay Log（即中继日志）文件（Mysql-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取master端新binlog日志时能告诉Master服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容。\n5）Slave服务器端的SQL线程会实时检测本地Relay Log 中IO线程新增的日志内容，然后及时把Relay LOG 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样sql语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点。\nMysql主从同步注意事项  master节点和slave节点的uuid不同 master节点和slave节点的server_id不同  制作Mysql容器镜像 同一镜像区创建不同容器的uuid 用同一mysql镜像创建mysql主从集群时，发现每台mysql服务的uuid都是相同的，是因为在数据初始化时将uuid写在了/var/lib/mysql/auto.cnf文件中，造成每个容器的uuid都是相同的。\n为了解决不同容器的uuid不同问题，需要在mysql启动生成配置文件后并在启动前 随机生成一个uuid写入到/var/lib/mysql/auto.cnf，这样就可以确保同一镜像生成的容器的uuid都不相同。\n同一服务不同实例的server_id处理 用同一mysql镜像创建mysql主从集群时，如何确保每个mysql服务的server_id不同？\nk8s在创建容器时，会为每个容器创建创建一个主机名( 如：gr78648d-0)，创建多个容器后面的数字会依次递增，所以可以利用这一特性生成不同的server_id（主机名数字部分 + 环境变量数字），然后在maser和slave使用不同的环境变量数字数字即可。\n3.3 创建镜像，并将镜像推到dockerhub上 基于镜像创建服务 创建master服务 通过指定镜像创建服务 参考文档 基于镜像创建服务\nmaster服务 开启内部的3306端口 master服务 设置依赖所需要连接的配置信息 Master节点设置同步的数据库名称 通过设置环境变量 MYSQLC_MYSQLD_binlog_do_db 设置同步数据库名。\n创建Slave服务 slave服务 开启内部的3306端口\n​ slave服务设置依赖所需要连接的配置信息\n​ 设置slave依赖master\n将slave服务实例水平伸缩为2\n从应用市场安装Mysql主从集群应用 应用市场安装mysql主从集群应用。\nmysql主从同步配置 ​ 查看master节点状态，记录二进制文件名(mysql-bin.000003)和位置(154)\n​ slave节点执行同步SQL语句(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)\n"
}]